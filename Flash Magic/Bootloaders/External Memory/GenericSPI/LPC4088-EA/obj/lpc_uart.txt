; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\lpc_uart.o --asm_dir=.\obj\ --list_dir=.\obj\ --depend=.\obj\lpc_uart.d --cpu=Cortex-M4.fp --apcs=interwork -O0 -I.\Core\CMSIS\Include -I.\Core\Device\NXP\LPC407x_8x_177x_8x\Include -I.\Drivers\include -I..\..\Core -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\NXP\LPC407x_8x_177x_8x -D__MICROLIB -D__RAM_MODE__ -DUSE_SPIFI_LIB -DCORE_M4 --omf_browse=.\obj\lpc_uart.crf Drivers\source\lpc_uart.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  uart_get_pointer PROC
;;;203     **********************************************************************/
;;;204    LPC_UART_TypeDef *uart_get_pointer(UART_ID_Type UartID)
000000  4601              MOV      r1,r0
;;;205    {
;;;206        LPC_UART_TypeDef *UARTx = NULL;
000002  2000              MOVS     r0,#0
;;;207        switch(UartID)
000004  b121              CBZ      r1,|L1.16|
000006  2902              CMP      r1,#2
000008  d004              BEQ      |L1.20|
00000a  2903              CMP      r1,#3
00000c  d106              BNE      |L1.28|
00000e  e003              B        |L1.24|
                  |L1.16|
;;;208        {
;;;209            case UART_0:
;;;210                UARTx = LPC_UART0;
000010  48f7              LDR      r0,|L1.1008|
;;;211                break;
000012  e004              B        |L1.30|
                  |L1.20|
;;;212            case UART_2:
;;;213                UARTx = LPC_UART2;
000014  48f7              LDR      r0,|L1.1012|
;;;214                break;
000016  e002              B        |L1.30|
                  |L1.24|
;;;215            case UART_3:
;;;216                UARTx = LPC_UART3;
000018  48f7              LDR      r0,|L1.1016|
;;;217                break;
00001a  e000              B        |L1.30|
                  |L1.28|
;;;218            default:
;;;219                break;
00001c  bf00              NOP      
                  |L1.30|
00001e  bf00              NOP                            ;211
;;;220        }
;;;221        return UARTx;
;;;222    }
000020  4770              BX       lr
;;;223    
                          ENDP

                  uart_set_divisors PROC
;;;66      **********************************************************************/
;;;67     static Status uart_set_divisors(UART_ID_Type UartID, uint32_t baudrate)
000022  e92d4ff3          PUSH     {r0,r1,r4-r11,lr}
;;;68     {
000026  b08b              SUB      sp,sp,#0x2c
000028  4688              MOV      r8,r1
;;;69         Status errorStatus = ERROR;
00002a  2000              MOVS     r0,#0
00002c  9009              STR      r0,[sp,#0x24]
;;;70     
;;;71         uint32_t uClk;
;;;72         uint32_t d, m, bestd, bestm, tmp;
;;;73         uint64_t best_divisor, divisor;
;;;74         uint32_t current_error, best_error;
;;;75         uint32_t recalcbaud;
;;;76     
;;;77         /* get UART block clock */
;;;78         uClk = CLKPWR_GetCLK(CLKPWR_CLKTYPE_PER);
00002e  2001              MOVS     r0,#1
000030  f7fffffe          BL       CLKPWR_GetCLK
000034  9008              STR      r0,[sp,#0x20]
;;;79     
;;;80         /* In the Uart IP block, baud rate is calculated using FDR and DLL-DLM registers
;;;81         * The formula is :
;;;82         * BaudRate= uClk * (mulFracDiv/(mulFracDiv+dividerAddFracDiv) / (16 * (DLL)
;;;83         * It involves floating point calculations. That's the reason the formulae are adjusted with
;;;84         * Multiply and divide method.*/
;;;85         
;;;86         /* The value of mulFracDiv and dividerAddFracDiv should comply to the following expressions:
;;;87         * 0 < mulFracDiv <= 15, 0 <= dividerAddFracDiv <= 15 */
;;;88         best_error = 0xFFFFFFFF; /* Worst case */
000036  f04f30ff          MOV      r0,#0xffffffff
00003a  9003              STR      r0,[sp,#0xc]
;;;89         bestd = 0;
00003c  2000              MOVS     r0,#0
00003e  9006              STR      r0,[sp,#0x18]
;;;90         bestm = 0;
000040  4682              MOV      r10,r0
;;;91         best_divisor = 0;
000042  2100              MOVS     r1,#0
000044  460c              MOV      r4,r1
000046  460d              MOV      r5,r1
;;;92         
;;;93         for (m = 1 ; m <= 15 ;m++)
000048  2601              MOVS     r6,#1
00004a  e048              B        |L1.222|
                  |L1.76|
;;;94         {
;;;95             for (d = 0 ; d < m ; d++)
00004c  2000              MOVS     r0,#0
00004e  9007              STR      r0,[sp,#0x1c]
000050  e03d              B        |L1.206|
                  |L1.82|
;;;96             {
;;;97                 divisor = ((uint64_t)uClk << 28)*m / (baudrate*(m+d));
000052  9807              LDR      r0,[sp,#0x1c]
000054  4430              ADD      r0,r0,r6
000056  fb00f708          MUL      r7,r0,r8
00005a  2100              MOVS     r1,#0
00005c  0709              LSLS     r1,r1,#28
00005e  9808              LDR      r0,[sp,#0x20]
000060  ea411110          ORR      r1,r1,r0,LSR #4
000064  0702              LSLS     r2,r0,#28
000066  2300              MOVS     r3,#0
000068  fba20c06          UMULL    r0,r12,r2,r6
00006c  fb01c106          MLA      r1,r1,r6,r12
000070  fb021103          MLA      r1,r2,r3,r1
000074  463a              MOV      r2,r7
000076  e9cd0100          STRD     r0,r1,[sp,#0]
00007a  f7fffffe          BL       __aeabi_uldivmod
00007e  e9cd0104          STRD     r0,r1,[sp,#0x10]
;;;98                 current_error = divisor & 0xFFFFFFFF;
000082  f8ddb010          LDR      r11,[sp,#0x10]
;;;99     
;;;100                tmp = divisor>>32;
000086  f8dd9014          LDR      r9,[sp,#0x14]
;;;101    
;;;102                /* Adjust error */
;;;103                if(current_error > ((uint32_t)1<<31))
00008a  f1bb4f00          CMP      r11,#0x80000000
00008e  d903              BLS      |L1.152|
;;;104                {
;;;105                    current_error = -current_error;
000090  f1cb0b00          RSB      r11,r11,#0
;;;106                    tmp++;
000094  f1090901          ADD      r9,r9,#1
                  |L1.152|
;;;107                }
;;;108    
;;;109                /* Out of range */
;;;110                if(tmp < 1 || tmp > 65536)
000098  f1b90f00          CMP      r9,#0
00009c  d002              BEQ      |L1.164|
00009e  f5b93f80          CMP      r9,#0x10000
0000a2  d900              BLS      |L1.166|
                  |L1.164|
;;;111                    continue;
0000a4  e010              B        |L1.200|
                  |L1.166|
;;;112    
;;;113                if( current_error < best_error)
0000a6  9803              LDR      r0,[sp,#0xc]
0000a8  4583              CMP      r11,r0
0000aa  d20c              BCS      |L1.198|
;;;114                {
;;;115                    best_error = current_error;
0000ac  f8cdb00c          STR      r11,[sp,#0xc]
;;;116                    best_divisor = tmp;
0000b0  2500              MOVS     r5,#0
0000b2  464c              MOV      r4,r9
;;;117                    bestd = d;
0000b4  9807              LDR      r0,[sp,#0x1c]
0000b6  9006              STR      r0,[sp,#0x18]
;;;118                    bestm = m;
0000b8  46b2              MOV      r10,r6
;;;119                    
;;;120                    if(best_error == 0) 
0000ba  f8ddb00c          LDR      r11,[sp,#0xc]
0000be  f1bb0f00          CMP      r11,#0
0000c2  d100              BNE      |L1.198|
;;;121                        break;
0000c4  e006              B        |L1.212|
                  |L1.198|
0000c6  bf00              NOP                            ;111
                  |L1.200|
0000c8  9807              LDR      r0,[sp,#0x1c]         ;95
0000ca  1c40              ADDS     r0,r0,#1              ;95
0000cc  9007              STR      r0,[sp,#0x1c]         ;95
                  |L1.206|
0000ce  9807              LDR      r0,[sp,#0x1c]         ;95
0000d0  42b0              CMP      r0,r6                 ;95
0000d2  d3be              BCC      |L1.82|
                  |L1.212|
0000d4  bf00              NOP      
;;;122                }
;;;123            } /* end of inner for loop */
;;;124    
;;;125            if (best_error == 0)
0000d6  9803              LDR      r0,[sp,#0xc]
0000d8  b900              CBNZ     r0,|L1.220|
;;;126                break;
0000da  e002              B        |L1.226|
                  |L1.220|
0000dc  1c76              ADDS     r6,r6,#1              ;93
                  |L1.222|
0000de  2e0f              CMP      r6,#0xf               ;93
0000e0  d9b4              BLS      |L1.76|
                  |L1.226|
0000e2  bf00              NOP      
;;;127        } /* end of outer for loop  */
;;;128    
;;;129        /* can not find best match */
;;;130        if(best_divisor == 0) 
0000e4  2100              MOVS     r1,#0
0000e6  ea840001          EOR      r0,r4,r1
0000ea  4069              EORS     r1,r1,r5
0000ec  4308              ORRS     r0,r0,r1
0000ee  d102              BNE      |L1.246|
                  |L1.240|
;;;131            return ERROR;
;;;132    
;;;133        recalcbaud = (uClk >> 4) * bestm / (best_divisor * (bestm + bestd));
;;;134    
;;;135        /* reuse best_error to evaluate baud error*/
;;;136        if(baudrate > recalcbaud) 
;;;137            best_error = baudrate - recalcbaud;
;;;138        else 
;;;139            best_error = recalcbaud -baudrate;
;;;140    
;;;141        best_error = best_error * 100 / baudrate;
;;;142    
;;;143        if (best_error < UART_ACCEPTED_BAUDRATE_ERROR)
;;;144        {
;;;145            if (UartID == UART_1)
;;;146            {
;;;147                LPC_UART1->LCR |= UART_LCR_DLAB_EN;
;;;148                
;;;149                LPC_UART1->DLM = UART_LOAD_DLM(best_divisor);
;;;150                
;;;151                LPC_UART1->DLL = UART_LOAD_DLL(best_divisor);
;;;152                
;;;153                /* Then reset DLAB bit */
;;;154                LPC_UART1->LCR &= (~UART_LCR_DLAB_EN) & UART_LCR_BITMASK;
;;;155                
;;;156                LPC_UART1->FDR = (UART_FDR_MULVAL(bestm)
;;;157                                                        | UART_FDR_DIVADDVAL(bestd)) & UART_FDR_BITMASK;
;;;158            }
;;;159            else if (UartID == UART_4)
;;;160            {
;;;161                LPC_UART4->LCR |= UART_LCR_DLAB_EN;
;;;162                
;;;163                LPC_UART4->DLM = UART_LOAD_DLM(best_divisor);
;;;164                
;;;165                LPC_UART4->DLL = UART_LOAD_DLL(best_divisor);
;;;166                
;;;167                /* Then reset DLAB bit */
;;;168                LPC_UART4->LCR &= (~UART_LCR_DLAB_EN) & UART_LCR_BITMASK;
;;;169                
;;;170                LPC_UART4->FDR = (UART_FDR_MULVAL(bestm)
;;;171                                                        | UART_FDR_DIVADDVAL(bestd)) & UART_FDR_BITMASK;
;;;172            }
;;;173                
;;;174            else
;;;175            {
;;;176                LPC_UART_TypeDef *UARTx = uart_get_pointer(UartID);
;;;177                UARTx->LCR |= UART_LCR_DLAB_EN;
;;;178                
;;;179                UARTx->DLM = UART_LOAD_DLM(best_divisor);
;;;180                
;;;181                UARTx->DLL = UART_LOAD_DLL(best_divisor);
;;;182                
;;;183                /* Then reset DLAB bit */
;;;184                UARTx->LCR &= (~UART_LCR_DLAB_EN) & UART_LCR_BITMASK;
;;;185                
;;;186                UARTx->FDR = (UART_FDR_MULVAL(bestm) \
;;;187                                | UART_FDR_DIVADDVAL(bestd)) & UART_FDR_BITMASK;
;;;188            }
;;;189            errorStatus = SUCCESS;
;;;190        }
;;;191    
;;;192        return errorStatus;
;;;193    }
0000f0  b00d              ADD      sp,sp,#0x34
0000f2  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.246|
0000f6  9808              LDR      r0,[sp,#0x20]         ;133
0000f8  0900              LSRS     r0,r0,#4              ;133
0000fa  fb00f70a          MUL      r7,r0,r10             ;133
0000fe  9806              LDR      r0,[sp,#0x18]         ;133
000100  4450              ADD      r0,r0,r10             ;133
000102  2100              MOVS     r1,#0                 ;133
000104  fba02304          UMULL    r2,r3,r0,r4           ;133
000108  fb013104          MLA      r1,r1,r4,r3           ;133
00010c  fb001005          MLA      r0,r0,r5,r1           ;133
000110  4603              MOV      r3,r0                 ;133
000112  e9cd2000          STRD     r2,r0,[sp,#0]         ;133
000116  4638              MOV      r0,r7                 ;133
000118  2100              MOVS     r1,#0                 ;133
00011a  f7fffffe          BL       __aeabi_uldivmod
00011e  9002              STR      r0,[sp,#8]            ;133
000120  9802              LDR      r0,[sp,#8]            ;136
000122  4580              CMP      r8,r0                 ;136
000124  d904              BLS      |L1.304|
000126  9802              LDR      r0,[sp,#8]            ;137
000128  eba80000          SUB      r0,r8,r0              ;137
00012c  9003              STR      r0,[sp,#0xc]          ;137
00012e  e003              B        |L1.312|
                  |L1.304|
000130  9802              LDR      r0,[sp,#8]            ;139
000132  eba00008          SUB      r0,r0,r8              ;139
000136  9003              STR      r0,[sp,#0xc]          ;139
                  |L1.312|
000138  2164              MOVS     r1,#0x64              ;141
00013a  9803              LDR      r0,[sp,#0xc]          ;141
00013c  4348              MULS     r0,r1,r0              ;141
00013e  fbb0f0f8          UDIV     r0,r0,r8              ;141
000142  9003              STR      r0,[sp,#0xc]          ;141
000144  9803              LDR      r0,[sp,#0xc]          ;143
000146  2803              CMP      r0,#3                 ;143
000148  d258              BCS      |L1.508|
00014a  980b              LDR      r0,[sp,#0x2c]         ;145
00014c  2801              CMP      r0,#1                 ;145
00014e  d119              BNE      |L1.388|
000150  48aa              LDR      r0,|L1.1020|
000152  7b00              LDRB     r0,[r0,#0xc]          ;147
000154  f0400080          ORR      r0,r0,#0x80           ;147
000158  49a8              LDR      r1,|L1.1020|
00015a  7308              STRB     r0,[r1,#0xc]          ;147
00015c  0a20              LSRS     r0,r4,#8              ;149
00015e  ea406005          ORR      r0,r0,r5,LSL #24      ;149
000162  7108              STRB     r0,[r1,#4]            ;149
000164  700c              STRB     r4,[r1,#0]            ;151
000166  4608              MOV      r0,r1                 ;154
000168  7b00              LDRB     r0,[r0,#0xc]          ;154
00016a  f000007f          AND      r0,r0,#0x7f           ;154
00016e  7308              STRB     r0,[r1,#0xc]          ;154
000170  20f0              MOVS     r0,#0xf0              ;156
000172  ea00100a          AND      r0,r0,r10,LSL #4      ;156
000176  9906              LDR      r1,[sp,#0x18]         ;156
000178  f001010f          AND      r1,r1,#0xf            ;156
00017c  4308              ORRS     r0,r0,r1              ;156
00017e  499f              LDR      r1,|L1.1020|
000180  6288              STR      r0,[r1,#0x28]         ;156
000182  e039              B        |L1.504|
                  |L1.388|
000184  980b              LDR      r0,[sp,#0x2c]         ;159
000186  2804              CMP      r0,#4                 ;159
000188  d11b              BNE      |L1.450|
00018a  489d              LDR      r0,|L1.1024|
00018c  68c0              LDR      r0,[r0,#0xc]          ;161
00018e  f0400080          ORR      r0,r0,#0x80           ;161
000192  499b              LDR      r1,|L1.1024|
000194  60c8              STR      r0,[r1,#0xc]          ;161
000196  0a20              LSRS     r0,r4,#8              ;163
000198  ea406005          ORR      r0,r0,r5,LSL #24      ;163
00019c  b2c0              UXTB     r0,r0                 ;163
00019e  6048              STR      r0,[r1,#4]            ;163
0001a0  b2e0              UXTB     r0,r4                 ;165
0001a2  6008              STR      r0,[r1,#0]            ;165
0001a4  4608              MOV      r0,r1                 ;168
0001a6  68c0              LDR      r0,[r0,#0xc]          ;168
0001a8  f000007f          AND      r0,r0,#0x7f           ;168
0001ac  60c8              STR      r0,[r1,#0xc]          ;168
0001ae  20f0              MOVS     r0,#0xf0              ;170
0001b0  ea00100a          AND      r0,r0,r10,LSL #4      ;170
0001b4  9906              LDR      r1,[sp,#0x18]         ;170
0001b6  f001010f          AND      r1,r1,#0xf            ;170
0001ba  4308              ORRS     r0,r0,r1              ;170
0001bc  4990              LDR      r1,|L1.1024|
0001be  6288              STR      r0,[r1,#0x28]         ;170
0001c0  e01a              B        |L1.504|
                  |L1.450|
0001c2  980b              LDR      r0,[sp,#0x2c]         ;176
0001c4  f7fffffe          BL       uart_get_pointer
0001c8  4607              MOV      r7,r0                 ;176
0001ca  7b38              LDRB     r0,[r7,#0xc]          ;177
0001cc  f0400080          ORR      r0,r0,#0x80           ;177
0001d0  7338              STRB     r0,[r7,#0xc]          ;177
0001d2  0a20              LSRS     r0,r4,#8              ;179
0001d4  ea406005          ORR      r0,r0,r5,LSL #24      ;179
0001d8  7138              STRB     r0,[r7,#4]            ;179
0001da  703c              STRB     r4,[r7,#0]            ;181
0001dc  7b38              LDRB     r0,[r7,#0xc]          ;184
0001de  f000007f          AND      r0,r0,#0x7f           ;184
0001e2  7338              STRB     r0,[r7,#0xc]          ;184
0001e4  20f0              MOVS     r0,#0xf0              ;186
0001e6  ea00100a          AND      r0,r0,r10,LSL #4      ;186
0001ea  9906              LDR      r1,[sp,#0x18]         ;186
0001ec  f001010f          AND      r1,r1,#0xf            ;186
0001f0  4308              ORRS     r0,r0,r1              ;186
0001f2  f8870028          STRB     r0,[r7,#0x28]         ;186
0001f6  bf00              NOP                            ;188
                  |L1.504|
0001f8  2001              MOVS     r0,#1                 ;189
0001fa  9009              STR      r0,[sp,#0x24]         ;189
                  |L1.508|
0001fc  9809              LDR      r0,[sp,#0x24]         ;192
0001fe  e777              B        |L1.240|
;;;194    /*********************************************************************//**
                          ENDP

                  UART_Init PROC
;;;245     *********************************************************************/
;;;246    void UART_Init(UART_ID_Type UartID, UART_CFG_Type *UART_ConfigStruct)
000200  e92d41f0          PUSH     {r4-r8,lr}
;;;247    {
000204  4606              MOV      r6,r0
000206  460f              MOV      r7,r1
;;;248        uint32_t tmp;
;;;249        switch (UartID)
000208  2e05              CMP      r6,#5
00020a  d23e              BCS      |L1.650|
00020c  e8dff006          TBB      [pc,r6]
000210  033e0405          DCB      0x03,0x3e,0x04,0x05
000214  7200              DCB      0x72,0x00
;;;250        {
;;;251            case UART_0:
;;;252            case UART_2:
000216  bf00              NOP      
;;;253            case UART_3:
000218  bf00              NOP      
;;;254            {
;;;255                LPC_UART_TypeDef *UARTx = uart_get_pointer(UartID);
00021a  4630              MOV      r0,r6
00021c  f7fffffe          BL       uart_get_pointer
000220  4605              MOV      r5,r0
;;;256                if(UartID == UART_0)
000222  b926              CBNZ     r6,|L1.558|
;;;257                    /* Set up clock and power for UART module */
;;;258                    CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART0, ENABLE);
000224  2101              MOVS     r1,#1
000226  2008              MOVS     r0,#8
000228  f7fffffe          BL       CLKPWR_ConfigPPWR
00022c  e00c              B        |L1.584|
                  |L1.558|
;;;259                else if(UartID == UART_2)
00022e  2e02              CMP      r6,#2
000230  d104              BNE      |L1.572|
;;;260                    /* Set up clock and power for UART module */
;;;261                    CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART2, ENABLE);
000232  2101              MOVS     r1,#1
000234  0608              LSLS     r0,r1,#24
000236  f7fffffe          BL       CLKPWR_ConfigPPWR
00023a  e005              B        |L1.584|
                  |L1.572|
;;;262                else if(UartID == UART_3)
00023c  2e03              CMP      r6,#3
00023e  d103              BNE      |L1.584|
;;;263                    /* Set up clock and power for UART module */
;;;264                    CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART3, ENABLE);;
000240  2101              MOVS     r1,#1
000242  0648              LSLS     r0,r1,#25
000244  f7fffffe          BL       CLKPWR_ConfigPPWR
                  |L1.584|
;;;265                /* FIFOs are empty */
;;;266                UARTx->FCR = ( UART_FCR_FIFO_EN | UART_FCR_RX_RS | UART_FCR_TX_RS);
000248  2007              MOVS     r0,#7
00024a  7228              STRB     r0,[r5,#8]
;;;267    
;;;268                // Disable FIFO
;;;269                UARTx->FCR = 0;
00024c  2000              MOVS     r0,#0
00024e  7228              STRB     r0,[r5,#8]
;;;270    
;;;271                // Dummy reading
;;;272                while (UARTx->LSR & UART_LSR_RDR)
000250  e000              B        |L1.596|
                  |L1.594|
;;;273                {
;;;274                    tmp = UARTx->RBR;
000252  782c              LDRB     r4,[r5,#0]
                  |L1.596|
000254  7d28              LDRB     r0,[r5,#0x14]         ;272
000256  f0000001          AND      r0,r0,#1              ;272
00025a  2800              CMP      r0,#0                 ;272
00025c  d1f9              BNE      |L1.594|
;;;275                }
;;;276    
;;;277                UARTx->TER = UART_TER_TXEN;
00025e  2080              MOVS     r0,#0x80
000260  f8850030          STRB     r0,[r5,#0x30]
;;;278    
;;;279                // Wait for current transmit complete
;;;280                while (!(UARTx->LSR & UART_LSR_THRE));
000264  bf00              NOP      
                  |L1.614|
000266  7d28              LDRB     r0,[r5,#0x14]
000268  f0000020          AND      r0,r0,#0x20
00026c  2800              CMP      r0,#0
00026e  d0fa              BEQ      |L1.614|
;;;281    
;;;282                // Disable Tx
;;;283                UARTx->TER = 0;
000270  2000              MOVS     r0,#0
000272  f8850030          STRB     r0,[r5,#0x30]
;;;284    
;;;285                // Disable interrupt
;;;286                UARTx->IER = 0;
000276  6068              STR      r0,[r5,#4]
;;;287    
;;;288                // Set LCR to default state
;;;289                UARTx->LCR = 0;
000278  7328              STRB     r0,[r5,#0xc]
;;;290    
;;;291                // Set ACR to default state
;;;292                UARTx->ACR = 0;
00027a  6228              STR      r0,[r5,#0x20]
;;;293    
;;;294                // Set RS485 control to default state
;;;295                UARTx->RS485CTRL = 0;
00027c  f885004c          STRB     r0,[r5,#0x4c]
;;;296    
;;;297                // Set RS485 delay timer to default state
;;;298                UARTx->RS485DLY = 0;
000280  f8850054          STRB     r0,[r5,#0x54]
;;;299    
;;;300                // Set RS485 addr match to default state
;;;301                UARTx->ADRMATCH = 0;
000284  f8850050          STRB     r0,[r5,#0x50]
;;;302    
;;;303                // Dummy reading
;;;304                tmp = UARTx->LSR;
000288  7d2c              LDRB     r4,[r5,#0x14]
                  |L1.650|
;;;305            }
;;;306            break;
00028a  e05d              B        |L1.840|
;;;307            case UART_1:
;;;308            {
;;;309                /* Set up clock and power for UART module */
;;;310                CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART1, ENABLE);
00028c  2101              MOVS     r1,#1
00028e  2010              MOVS     r0,#0x10
000290  f7fffffe          BL       CLKPWR_ConfigPPWR
;;;311    
;;;312                /* FIFOs are empty */
;;;313                LPC_UART1->FCR = ( UART_FCR_FIFO_EN | UART_FCR_RX_RS | UART_FCR_TX_RS);
000294  2007              MOVS     r0,#7
000296  4959              LDR      r1,|L1.1020|
000298  7208              STRB     r0,[r1,#8]
;;;314    
;;;315                // Disable FIFO
;;;316                LPC_UART1->FCR = 0;
00029a  2000              MOVS     r0,#0
00029c  7208              STRB     r0,[r1,#8]
;;;317    
;;;318                // Dummy reading
;;;319                while (LPC_UART1->LSR & UART_LSR_RDR)
00029e  e001              B        |L1.676|
                  |L1.672|
;;;320                {
;;;321                    tmp = LPC_UART1->RBR;
0002a0  4856              LDR      r0,|L1.1020|
0002a2  7804              LDRB     r4,[r0,#0]
                  |L1.676|
0002a4  4855              LDR      r0,|L1.1020|
0002a6  7d00              LDRB     r0,[r0,#0x14]         ;319
0002a8  f0000001          AND      r0,r0,#1              ;319
0002ac  2800              CMP      r0,#0                 ;319
0002ae  d1f7              BNE      |L1.672|
;;;322                }
;;;323    
;;;324                LPC_UART1->TER = UART_TER_TXEN;
0002b0  2080              MOVS     r0,#0x80
0002b2  4952              LDR      r1,|L1.1020|
0002b4  3130              ADDS     r1,r1,#0x30
0002b6  7008              STRB     r0,[r1,#0]
;;;325    
;;;326                // Wait for current transmit complete
;;;327                while (!(LPC_UART1->LSR & UART_LSR_THRE));
0002b8  bf00              NOP      
                  |L1.698|
0002ba  4850              LDR      r0,|L1.1020|
0002bc  7d00              LDRB     r0,[r0,#0x14]
0002be  f0000020          AND      r0,r0,#0x20
0002c2  2800              CMP      r0,#0
0002c4  d0f9              BEQ      |L1.698|
;;;328    
;;;329                // Disable Tx
;;;330                LPC_UART1->TER = 0;
0002c6  2000              MOVS     r0,#0
0002c8  494c              LDR      r1,|L1.1020|
0002ca  3130              ADDS     r1,r1,#0x30
0002cc  7008              STRB     r0,[r1,#0]
;;;331    
;;;332                // Disable interrupt
;;;333                LPC_UART1->IER = 0;
0002ce  494b              LDR      r1,|L1.1020|
0002d0  6048              STR      r0,[r1,#4]
;;;334    
;;;335                // Set LCR to default state
;;;336                LPC_UART1->LCR = 0;
0002d2  7308              STRB     r0,[r1,#0xc]
;;;337    
;;;338                // Set ACR to default state
;;;339                LPC_UART1->ACR = 0;
0002d4  6208              STR      r0,[r1,#0x20]
;;;340    
;;;341                // Set RS485 control to default state
;;;342                LPC_UART1->RS485CTRL = 0;
0002d6  f881004c          STRB     r0,[r1,#0x4c]
;;;343    
;;;344                // Set RS485 delay timer to default state
;;;345                LPC_UART1->RS485DLY = 0;
0002da  4948              LDR      r1,|L1.1020|
0002dc  3154              ADDS     r1,r1,#0x54
0002de  7008              STRB     r0,[r1,#0]
;;;346    
;;;347                // Set RS485 addr match to default state
;;;348                LPC_UART1->ADRMATCH = 0;
0002e0  4946              LDR      r1,|L1.1020|
0002e2  f8810050          STRB     r0,[r1,#0x50]
;;;349    
;;;350                // Dummy reading
;;;351                tmp = LPC_UART1->LSR;
0002e6  4608              MOV      r0,r1
0002e8  7d04              LDRB     r4,[r0,#0x14]
;;;352    
;;;353                // Set Modem Control to default state
;;;354                LPC_UART1->MCR = 0;
0002ea  2000              MOVS     r0,#0
0002ec  7408              STRB     r0,[r1,#0x10]
;;;355    
;;;356                //Dummy Reading to Clear Status
;;;357                tmp = LPC_UART1->MSR;
0002ee  4608              MOV      r0,r1
0002f0  7e04              LDRB     r4,[r0,#0x18]
;;;358            }
;;;359            break;
0002f2  e029              B        |L1.840|
;;;360            case UART_4:
;;;361            {
;;;362                /* Set up clock and power for UART module */
;;;363                CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART4, ENABLE);
0002f4  2101              MOVS     r1,#1
0002f6  0208              LSLS     r0,r1,#8
0002f8  f7fffffe          BL       CLKPWR_ConfigPPWR
;;;364    
;;;365                /* FIFOs are empty */
;;;366                LPC_UART4->FCR = ( UART_FCR_FIFO_EN | UART_FCR_RX_RS | UART_FCR_TX_RS);
0002fc  2007              MOVS     r0,#7
0002fe  4940              LDR      r1,|L1.1024|
000300  6088              STR      r0,[r1,#8]
;;;367    
;;;368                // Disable FIFO
;;;369                LPC_UART4->FCR = 0;
000302  2000              MOVS     r0,#0
000304  6088              STR      r0,[r1,#8]
;;;370    
;;;371                // Dummy reading
;;;372                while (LPC_UART4->LSR & UART_LSR_RDR)
000306  e001              B        |L1.780|
                  |L1.776|
;;;373                {
;;;374                    tmp = LPC_UART4->RBR;
000308  483d              LDR      r0,|L1.1024|
00030a  6804              LDR      r4,[r0,#0]
                  |L1.780|
00030c  483c              LDR      r0,|L1.1024|
00030e  6940              LDR      r0,[r0,#0x14]         ;372
000310  f0000001          AND      r0,r0,#1              ;372
000314  2800              CMP      r0,#0                 ;372
000316  d1f7              BNE      |L1.776|
;;;375                }
;;;376    
;;;377                LPC_UART4->TER = UART4_TER_TXEN;
000318  2001              MOVS     r0,#1
00031a  4939              LDR      r1,|L1.1024|
00031c  65c8              STR      r0,[r1,#0x5c]
;;;378    
;;;379                // Wait for current transmit complete
;;;380                while (!(LPC_UART4->LSR & UART_LSR_THRE));
00031e  bf00              NOP      
                  |L1.800|
000320  4837              LDR      r0,|L1.1024|
000322  6940              LDR      r0,[r0,#0x14]
000324  f0000020          AND      r0,r0,#0x20
000328  2800              CMP      r0,#0
00032a  d0f9              BEQ      |L1.800|
;;;381    
;;;382                // Disable Tx
;;;383                LPC_UART4->TER = 0;
00032c  2000              MOVS     r0,#0
00032e  4934              LDR      r1,|L1.1024|
000330  65c8              STR      r0,[r1,#0x5c]
;;;384    
;;;385                // Disable interrupt
;;;386                LPC_UART4->IER = 0;
000332  6048              STR      r0,[r1,#4]
;;;387    
;;;388                // Set LCR to default state
;;;389                LPC_UART4->LCR = 0;
000334  60c8              STR      r0,[r1,#0xc]
;;;390    
;;;391                // Set ACR to default state
;;;392                LPC_UART4->ACR = 0;
000336  6208              STR      r0,[r1,#0x20]
;;;393    
;;;394                // Set RS485 control to default state
;;;395                LPC_UART4->RS485CTRL = 0;
000338  64c8              STR      r0,[r1,#0x4c]
;;;396    
;;;397                // Set RS485 delay timer to default state
;;;398                LPC_UART4->RS485DLY = 0;
00033a  6548              STR      r0,[r1,#0x54]
;;;399    
;;;400                // Set RS485 addr match to default state
;;;401                LPC_UART4->ADRMATCH = 0;
00033c  6508              STR      r0,[r1,#0x50]
;;;402    
;;;403                // Dummy reading
;;;404                tmp = LPC_UART4->LSR;
00033e  4608              MOV      r0,r1
000340  6944              LDR      r4,[r0,#0x14]
;;;405    
;;;406                // Set IrDA Mode to default state
;;;407                LPC_UART4->ICR = 0;
000342  2000              MOVS     r0,#0
000344  6248              STR      r0,[r1,#0x24]
;;;408            }
;;;409            break;
000346  bf00              NOP      
                  |L1.840|
000348  bf00              NOP                            ;306
;;;410        }
;;;411    
;;;412        // Set Line Control register ----------------------------
;;;413    
;;;414        uart_set_divisors(UartID, (UART_ConfigStruct->Baud_rate));
00034a  4630              MOV      r0,r6
00034c  6839              LDR      r1,[r7,#0]
00034e  f7fffffe          BL       uart_set_divisors
;;;415    
;;;416        if (UartID == UART_1)
000352  2e01              CMP      r6,#1
000354  d104              BNE      |L1.864|
;;;417        {
;;;418            tmp = (LPC_UART1->LCR & (UART_LCR_DLAB_EN | UART_LCR_BREAK_EN)) \
000356  4829              LDR      r0,|L1.1020|
000358  7b00              LDRB     r0,[r0,#0xc]
00035a  f00004c0          AND      r4,r0,#0xc0
00035e  e00e              B        |L1.894|
                  |L1.864|
;;;419                                                        & UART_LCR_BITMASK;
;;;420        }
;;;421        else if (UartID == UART_4)
000360  2e04              CMP      r6,#4
000362  d104              BNE      |L1.878|
;;;422        {
;;;423            tmp = (LPC_UART4->LCR & (UART_LCR_DLAB_EN | UART_LCR_BREAK_EN)) \
000364  4826              LDR      r0,|L1.1024|
000366  68c0              LDR      r0,[r0,#0xc]
000368  f00004c0          AND      r4,r0,#0xc0
00036c  e007              B        |L1.894|
                  |L1.878|
;;;424                                                        & UART_LCR_BITMASK;
;;;425        }   
;;;426        else
;;;427        {
;;;428            LPC_UART_TypeDef *UARTx = uart_get_pointer(UartID);
00036e  4630              MOV      r0,r6
000370  f7fffffe          BL       uart_get_pointer
000374  4605              MOV      r5,r0
;;;429            tmp = (UARTx->LCR & (UART_LCR_DLAB_EN | UART_LCR_BREAK_EN)) & UART_LCR_BITMASK;
000376  7b28              LDRB     r0,[r5,#0xc]
000378  f00004c0          AND      r4,r0,#0xc0
;;;430        }
00037c  bf00              NOP      
                  |L1.894|
;;;431    
;;;432        switch (UART_ConfigStruct->Databits)
00037e  7978              LDRB     r0,[r7,#5]
000380  b130              CBZ      r0,|L1.912|
000382  2801              CMP      r0,#1
000384  d006              BEQ      |L1.916|
000386  2802              CMP      r0,#2
000388  d007              BEQ      |L1.922|
00038a  2803              CMP      r0,#3
00038c  d108              BNE      |L1.928|
00038e  e008              B        |L1.930|
                  |L1.912|
;;;433        {
;;;434            case UART_DATABIT_5:
;;;435                tmp |= UART_LCR_WLEN5;
000390  bf00              NOP      
;;;436                break;
000392  e009              B        |L1.936|
                  |L1.916|
;;;437    
;;;438            case UART_DATABIT_6:
;;;439                tmp |= UART_LCR_WLEN6;
000394  f0440401          ORR      r4,r4,#1
;;;440                break;
000398  e006              B        |L1.936|
                  |L1.922|
;;;441    
;;;442            case UART_DATABIT_7:
;;;443                tmp |= UART_LCR_WLEN7;
00039a  f0440402          ORR      r4,r4,#2
;;;444                break;
00039e  e003              B        |L1.936|
                  |L1.928|
;;;445    
;;;446            case UART_DATABIT_8:
0003a0  bf00              NOP      
                  |L1.930|
;;;447    
;;;448            default:
;;;449                tmp |= UART_LCR_WLEN8;
0003a2  f0440403          ORR      r4,r4,#3
;;;450                break;
0003a6  bf00              NOP      
                  |L1.936|
0003a8  bf00              NOP                            ;436
;;;451        }
;;;452    
;;;453        if (UART_ConfigStruct->Parity == UART_PARITY_NONE)
0003aa  7938              LDRB     r0,[r7,#4]
0003ac  b1c0              CBZ      r0,|L1.992|
;;;454        {
;;;455            // Do nothing...
;;;456        }
;;;457        else
;;;458        {
;;;459            tmp |= UART_LCR_PARITY_EN;
0003ae  f0440408          ORR      r4,r4,#8
;;;460            switch (UART_ConfigStruct->Parity)
0003b2  7938              LDRB     r0,[r7,#4]
0003b4  2801              CMP      r0,#1
0003b6  d006              BEQ      |L1.966|
0003b8  2802              CMP      r0,#2
0003ba  d006              BEQ      |L1.970|
0003bc  2803              CMP      r0,#3
0003be  d007              BEQ      |L1.976|
0003c0  2804              CMP      r0,#4
0003c2  d10b              BNE      |L1.988|
0003c4  e007              B        |L1.982|
                  |L1.966|
;;;461            {
;;;462                case UART_PARITY_ODD:
;;;463                    tmp |= UART_LCR_PARITY_ODD;
0003c6  bf00              NOP      
;;;464                    break;
0003c8  e009              B        |L1.990|
                  |L1.970|
;;;465    
;;;466                case UART_PARITY_EVEN:
;;;467                    tmp |= UART_LCR_PARITY_EVEN;
0003ca  f0440410          ORR      r4,r4,#0x10
;;;468                    break;
0003ce  e006              B        |L1.990|
                  |L1.976|
;;;469    
;;;470                case UART_PARITY_SP_1:
;;;471                    tmp |= UART_LCR_PARITY_F_1;
0003d0  f0440420          ORR      r4,r4,#0x20
;;;472                    break;
0003d4  e003              B        |L1.990|
                  |L1.982|
;;;473    
;;;474                case UART_PARITY_SP_0:
;;;475                    tmp |= UART_LCR_PARITY_F_0;
0003d6  f0440430          ORR      r4,r4,#0x30
;;;476                    break;
0003da  e000              B        |L1.990|
                  |L1.988|
;;;477    
;;;478                default:
;;;479                    break;
0003dc  bf00              NOP      
                  |L1.990|
0003de  bf00              NOP                            ;464
                  |L1.992|
;;;480            }
;;;481        }
;;;482    
;;;483        switch (UART_ConfigStruct->Stopbits)
0003e0  79b8              LDRB     r0,[r7,#6]
0003e2  b180              CBZ      r0,|L1.1030|
0003e4  2801              CMP      r0,#1
0003e6  d10d              BNE      |L1.1028|
;;;484        {
;;;485            case UART_STOPBIT_2:
;;;486                tmp |= UART_LCR_STOPBIT_SEL;
0003e8  f0440404          ORR      r4,r4,#4
;;;487                break;
0003ec  e00c              B        |L1.1032|
0003ee  0000              DCW      0x0000
                  |L1.1008|
                          DCD      0x4000c000
                  |L1.1012|
                          DCD      0x40098000
                  |L1.1016|
                          DCD      0x4009c000
                  |L1.1020|
                          DCD      0x40010000
                  |L1.1024|
                          DCD      0x400a4000
                  |L1.1028|
;;;488    
;;;489            case UART_STOPBIT_1:
000404  bf00              NOP      
                  |L1.1030|
;;;490    
;;;491            default:
;;;492                // Do no thing
;;;493                break;
000406  bf00              NOP      
                  |L1.1032|
000408  bf00              NOP                            ;487
;;;494        }
;;;495    
;;;496    
;;;497        // Write back to LCR, configure FIFO and Disable Tx
;;;498        if (UartID == UART_1)
00040a  2e01              CMP      r6,#1
00040c  d102              BNE      |L1.1044|
;;;499        {
;;;500            LPC_UART1->LCR = (uint8_t)(tmp & UART_LCR_BITMASK);
00040e  49fb              LDR      r1,|L1.2044|
000410  730c              STRB     r4,[r1,#0xc]
000412  e00b              B        |L1.1068|
                  |L1.1044|
;;;501        }
;;;502        else if (UartID == UART_4)
000414  2e04              CMP      r6,#4
000416  d103              BNE      |L1.1056|
;;;503        {
;;;504            LPC_UART4->LCR = (uint8_t)(tmp & UART_LCR_BITMASK);
000418  b2e0              UXTB     r0,r4
00041a  49f9              LDR      r1,|L1.2048|
00041c  60c8              STR      r0,[r1,#0xc]
00041e  e005              B        |L1.1068|
                  |L1.1056|
;;;505        }   
;;;506        else
;;;507        {
;;;508            LPC_UART_TypeDef *UARTx = uart_get_pointer(UartID);
000420  4630              MOV      r0,r6
000422  f7fffffe          BL       uart_get_pointer
000426  4605              MOV      r5,r0
;;;509            UARTx->LCR = (uint8_t)(tmp & UART_LCR_BITMASK);
000428  732c              STRB     r4,[r5,#0xc]
;;;510        }
00042a  bf00              NOP      
                  |L1.1068|
;;;511    }
00042c  e8bd81f0          POP      {r4-r8,pc}
;;;512    
                          ENDP

                  UART_TxCmd PROC
;;;1334    **********************************************************************/
;;;1335   void UART_TxCmd(UART_ID_Type UartID, FunctionalState NewState)
000430  b570              PUSH     {r4-r6,lr}
;;;1336   {
000432  4604              MOV      r4,r0
000434  460d              MOV      r5,r1
;;;1337       if (NewState == ENABLE)
000436  2d01              CMP      r5,#1
000438  d11e              BNE      |L1.1144|
;;;1338       {
;;;1339           if (UartID == UART_1)
00043a  2c01              CMP      r4,#1
00043c  d108              BNE      |L1.1104|
;;;1340           {
;;;1341               LPC_UART1->TER |= UART_TER_TXEN;
00043e  48ef              LDR      r0,|L1.2044|
000440  3030              ADDS     r0,r0,#0x30
000442  7800              LDRB     r0,[r0,#0]
000444  f0400080          ORR      r0,r0,#0x80
000448  49ec              LDR      r1,|L1.2044|
00044a  f8810030          STRB     r0,[r1,#0x30]
00044e  e02f              B        |L1.1200|
                  |L1.1104|
;;;1342           }
;;;1343           else if (UartID == UART_4)
000450  2c04              CMP      r4,#4
000452  d106              BNE      |L1.1122|
;;;1344           {
;;;1345               LPC_UART4->TER |= UART4_TER_TXEN;
000454  48ea              LDR      r0,|L1.2048|
000456  6dc0              LDR      r0,[r0,#0x5c]
000458  f0400001          ORR      r0,r0,#1
00045c  49e8              LDR      r1,|L1.2048|
00045e  65c8              STR      r0,[r1,#0x5c]
000460  e026              B        |L1.1200|
                  |L1.1122|
;;;1346           }
;;;1347           else
;;;1348           {
;;;1349               LPC_UART_TypeDef *UARTx = uart_get_pointer(UartID);
000462  4620              MOV      r0,r4
000464  f7fffffe          BL       uart_get_pointer
000468  4606              MOV      r6,r0
;;;1350               UARTx->TER |= UART_TER_TXEN;
00046a  f8960030          LDRB     r0,[r6,#0x30]
00046e  f0400080          ORR      r0,r0,#0x80
000472  f8860030          STRB     r0,[r6,#0x30]
;;;1351           }
000476  e01b              B        |L1.1200|
                  |L1.1144|
;;;1352       }
;;;1353       else
;;;1354       {
;;;1355           if (UartID == UART_1)                     
000478  2c01              CMP      r4,#1
00047a  d107              BNE      |L1.1164|
;;;1356           {
;;;1357               LPC_UART1->TER &= (~UART_TER_TXEN) & UART_TER_BITMASK;
00047c  48df              LDR      r0,|L1.2044|
00047e  3030              ADDS     r0,r0,#0x30
000480  7800              LDRB     r0,[r0,#0]
000482  2000              MOVS     r0,#0
000484  49dd              LDR      r1,|L1.2044|
000486  f8810030          STRB     r0,[r1,#0x30]
00048a  e011              B        |L1.1200|
                  |L1.1164|
;;;1358           }
;;;1359           else if (UartID == UART_4)
00048c  2c04              CMP      r4,#4
00048e  d105              BNE      |L1.1180|
;;;1360           {
;;;1361               LPC_UART4->TER &= (~UART4_TER_TXEN) & UART4_TER_BITMASK;
000490  48db              LDR      r0,|L1.2048|
000492  6dc0              LDR      r0,[r0,#0x5c]
000494  2000              MOVS     r0,#0
000496  49da              LDR      r1,|L1.2048|
000498  65c8              STR      r0,[r1,#0x5c]
00049a  e009              B        |L1.1200|
                  |L1.1180|
;;;1362           }
;;;1363           else
;;;1364           {
;;;1365               LPC_UART_TypeDef *UARTx = uart_get_pointer(UartID);
00049c  4620              MOV      r0,r4
00049e  f7fffffe          BL       uart_get_pointer
0004a2  4606              MOV      r6,r0
;;;1366               UARTx->TER &= (~UART_TER_TXEN) & UART_TER_BITMASK;
0004a4  f8960030          LDRB     r0,[r6,#0x30]
0004a8  2000              MOVS     r0,#0
0004aa  f8860030          STRB     r0,[r6,#0x30]
;;;1367           }
0004ae  bf00              NOP      
                  |L1.1200|
;;;1368       }
;;;1369   }
0004b0  bd70              POP      {r4-r6,pc}
;;;1370   
                          ENDP

                  UART_DeInit PROC
;;;523     **********************************************************************/
;;;524    void UART_DeInit(UART_ID_Type UartID)
0004b2  b510              PUSH     {r4,lr}
;;;525    {
0004b4  4604              MOV      r4,r0
;;;526        UART_TxCmd(UartID, DISABLE);
0004b6  2100              MOVS     r1,#0
0004b8  4620              MOV      r0,r4
0004ba  f7fffffe          BL       UART_TxCmd
;;;527        if (UartID == UART_0)
0004be  b924              CBNZ     r4,|L1.1226|
;;;528        {
;;;529            /* Set up clock and power for UART module */
;;;530            CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART0, DISABLE);
0004c0  2100              MOVS     r1,#0
0004c2  2008              MOVS     r0,#8
0004c4  f7fffffe          BL       CLKPWR_ConfigPPWR
0004c8  e01b              B        |L1.1282|
                  |L1.1226|
;;;531        }
;;;532    
;;;533        else if (UartID == UART_1)
0004ca  2c01              CMP      r4,#1
0004cc  d104              BNE      |L1.1240|
;;;534        {
;;;535            /* Set up clock and power for UART module */
;;;536            CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART1, DISABLE);
0004ce  2100              MOVS     r1,#0
0004d0  2010              MOVS     r0,#0x10
0004d2  f7fffffe          BL       CLKPWR_ConfigPPWR
0004d6  e014              B        |L1.1282|
                  |L1.1240|
;;;537        }
;;;538    
;;;539        else if (UartID == UART_2)
0004d8  2c02              CMP      r4,#2
0004da  d104              BNE      |L1.1254|
;;;540        {
;;;541            /* Set up clock and power for UART module */
;;;542            CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART2, DISABLE);
0004dc  2100              MOVS     r1,#0
0004de  05e0              LSLS     r0,r4,#23
0004e0  f7fffffe          BL       CLKPWR_ConfigPPWR
0004e4  e00d              B        |L1.1282|
                  |L1.1254|
;;;543        }
;;;544    
;;;545        else if (UartID == UART_3)
0004e6  2c03              CMP      r4,#3
0004e8  d105              BNE      |L1.1270|
;;;546        {
;;;547            /* Set up clock and power for UART module */
;;;548            CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART3, DISABLE);
0004ea  2100              MOVS     r1,#0
0004ec  f04f7000          MOV      r0,#0x2000000
0004f0  f7fffffe          BL       CLKPWR_ConfigPPWR
0004f4  e005              B        |L1.1282|
                  |L1.1270|
;;;549        }
;;;550        else if (UartID == UART_4)
0004f6  2c04              CMP      r4,#4
0004f8  d103              BNE      |L1.1282|
;;;551        {
;;;552            /* Set up clock and power for UART module */
;;;553            CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART4, DISABLE);
0004fa  2100              MOVS     r1,#0
0004fc  01a0              LSLS     r0,r4,#6
0004fe  f7fffffe          BL       CLKPWR_ConfigPPWR
                  |L1.1282|
;;;554        }
;;;555    }
000502  bd10              POP      {r4,pc}
;;;556    
                          ENDP

                  UART_ConfigStructInit PROC
;;;566    *******************************************************************************/
;;;567    void UART_ConfigStructInit(UART_CFG_Type *UART_InitStruct)
000504  f44f31e1          MOV      r1,#0x1c200
;;;568    {
;;;569        UART_InitStruct->Baud_rate = 115200;
000508  6001              STR      r1,[r0,#0]
;;;570    
;;;571        UART_InitStruct->Databits = UART_DATABIT_8;
00050a  2103              MOVS     r1,#3
00050c  7141              STRB     r1,[r0,#5]
;;;572    
;;;573        UART_InitStruct->Parity = UART_PARITY_NONE;
00050e  2100              MOVS     r1,#0
000510  7101              STRB     r1,[r0,#4]
;;;574    
;;;575        UART_InitStruct->Stopbits = UART_STOPBIT_1;
000512  7181              STRB     r1,[r0,#6]
;;;576    }
000514  4770              BX       lr
;;;577    
                          ENDP

                  UART_SendByte PROC
;;;589     **********************************************************************/
;;;590    void UART_SendByte(UART_ID_Type UartID, uint8_t Data)
000516  2805              CMP      r0,#5
;;;591    {
;;;592        switch (UartID)
000518  d214              BCS      |L1.1348|
00051a  e8dff000          TBB      [pc,r0]
00051e  0306              DCB      0x03,0x06
000520  090c0f00          DCB      0x09,0x0c,0x0f,0x00
;;;593        {
;;;594            case UART_0:
;;;595                LPC_UART0->THR = Data & UART_THR_MASKBIT;
000524  4bb7              LDR      r3,|L1.2052|
000526  7019              STRB     r1,[r3,#0]
;;;596                break;
000528  e00c              B        |L1.1348|
;;;597            case UART_1:
;;;598                LPC_UART1->THR = Data & UART_THR_MASKBIT;
00052a  4bb4              LDR      r3,|L1.2044|
00052c  7019              STRB     r1,[r3,#0]
;;;599                break;  
00052e  e009              B        |L1.1348|
;;;600            case UART_2:
;;;601                LPC_UART2->THR = Data & UART_THR_MASKBIT;
000530  4bb5              LDR      r3,|L1.2056|
000532  7019              STRB     r1,[r3,#0]
;;;602                break;
000534  e006              B        |L1.1348|
;;;603            case UART_3:
;;;604                LPC_UART3->THR = Data & UART_THR_MASKBIT;
000536  4bb5              LDR      r3,|L1.2060|
000538  7019              STRB     r1,[r3,#0]
;;;605                break;
00053a  e003              B        |L1.1348|
;;;606            case UART_4:
;;;607                LPC_UART4->THR = Data & UART_THR_MASKBIT;
00053c  b2ca              UXTB     r2,r1
00053e  4bb0              LDR      r3,|L1.2048|
000540  601a              STR      r2,[r3,#0]
;;;608                break;
000542  bf00              NOP      
                  |L1.1348|
000544  bf00              NOP                            ;596
;;;609        }
;;;610    
;;;611    }
000546  4770              BX       lr
;;;612    
                          ENDP

                  UART_ReceiveByte PROC
;;;623     **********************************************************************/
;;;624    uint8_t UART_ReceiveByte(UART_ID_Type UartID)
000548  4601              MOV      r1,r0
;;;625    {
;;;626        switch (UartID)
00054a  2905              CMP      r1,#5
00054c  d214              BCS      |L1.1400|
00054e  e8dff001          TBB      [pc,r1]
000552  0306              DCB      0x03,0x06
000554  090c0f00          DCB      0x09,0x0c,0x0f,0x00
;;;627        {
;;;628            case UART_0:
;;;629                return (LPC_UART0->RBR & UART_RBR_MASKBIT);
000558  48aa              LDR      r0,|L1.2052|
00055a  7800              LDRB     r0,[r0,#0]
                  |L1.1372|
;;;630            case UART_1:
;;;631                return (LPC_UART1->RBR & UART_RBR_MASKBIT); 
;;;632            case UART_2:
;;;633                return (LPC_UART2->RBR & UART_RBR_MASKBIT);
;;;634            case UART_3:
;;;635                return (LPC_UART3->RBR & UART_RBR_MASKBIT);
;;;636            case UART_4:
;;;637                return (LPC_UART4->RBR & UART_RBR_MASKBIT);
;;;638        }
;;;639        return 0x00;
;;;640    }
00055c  4770              BX       lr
00055e  48a7              LDR      r0,|L1.2044|
000560  7800              LDRB     r0,[r0,#0]            ;631
000562  e7fb              B        |L1.1372|
000564  48a8              LDR      r0,|L1.2056|
000566  7800              LDRB     r0,[r0,#0]            ;633
000568  e7f8              B        |L1.1372|
00056a  48a8              LDR      r0,|L1.2060|
00056c  7800              LDRB     r0,[r0,#0]            ;635
00056e  e7f5              B        |L1.1372|
000570  48a3              LDR      r0,|L1.2048|
000572  6800              LDR      r0,[r0,#0]            ;637
000574  b2c0              UXTB     r0,r0                 ;637
000576  e7f1              B        |L1.1372|
                  |L1.1400|
000578  2000              MOVS     r0,#0                 ;639
00057a  e7ef              B        |L1.1372|
;;;641    
                          ENDP

                  UART_Send PROC
;;;658     **********************************************************************/
;;;659    uint32_t UART_Send(UART_ID_Type UartID, uint8_t *txbuf,
00057c  e92d4fff          PUSH     {r0-r11,lr}
;;;660                                uint32_t buflen, TRANSFER_BLOCK_Type flag)
;;;661    {
000580  b081              SUB      sp,sp,#4
000582  4680              MOV      r8,r0
000584  468a              MOV      r10,r1
000586  4693              MOV      r11,r2
;;;662        uint32_t bToSend, bSent, timeOut, fifo_cnt;
;;;663        uint8_t *pChar = txbuf;
000588  4657              MOV      r7,r10
;;;664        __IO uint32_t *LSR = NULL;
00058a  2000              MOVS     r0,#0
00058c  9000              STR      r0,[sp,#0]
;;;665    
;;;666        switch (UartID)
00058e  f1b80f05          CMP      r8,#5
000592  d218              BCS      |L1.1478|
000594  e8dff008          TBB      [pc,r8]
000598  03070b0f          DCB      0x03,0x07,0x0b,0x0f
00059c  1300              DCB      0x13,0x00
;;;667        {
;;;668            case UART_0:
;;;669                LSR = (__IO uint32_t *)&LPC_UART0->LSR;
00059e  4899              LDR      r0,|L1.2052|
0005a0  3014              ADDS     r0,r0,#0x14
0005a2  9000              STR      r0,[sp,#0]
;;;670                break;
0005a4  e00f              B        |L1.1478|
;;;671            case UART_1:
;;;672                LSR = (__IO uint32_t *)&LPC_UART1->LSR;
0005a6  4895              LDR      r0,|L1.2044|
0005a8  3014              ADDS     r0,r0,#0x14
0005aa  9000              STR      r0,[sp,#0]
;;;673                break;
0005ac  e00b              B        |L1.1478|
;;;674            case UART_2:
;;;675                LSR = (__IO uint32_t *)&LPC_UART2->LSR;
0005ae  4896              LDR      r0,|L1.2056|
0005b0  3014              ADDS     r0,r0,#0x14
0005b2  9000              STR      r0,[sp,#0]
;;;676                break;
0005b4  e007              B        |L1.1478|
;;;677            case UART_3:
;;;678                LSR = (__IO uint32_t *)&LPC_UART3->LSR;
0005b6  4895              LDR      r0,|L1.2060|
0005b8  3014              ADDS     r0,r0,#0x14
0005ba  9000              STR      r0,[sp,#0]
;;;679                break;
0005bc  e003              B        |L1.1478|
;;;680            case UART_4:
;;;681                LSR = (__IO uint32_t *)&LPC_UART4->LSR;
0005be  4890              LDR      r0,|L1.2048|
0005c0  3014              ADDS     r0,r0,#0x14
0005c2  9000              STR      r0,[sp,#0]
;;;682                break;
0005c4  bf00              NOP      
                  |L1.1478|
0005c6  bf00              NOP                            ;670
;;;683        }
;;;684    
;;;685        bToSend = buflen;
0005c8  465c              MOV      r4,r11
;;;686    
;;;687        // blocking mode
;;;688        if (flag == BLOCKING)
0005ca  9804              LDR      r0,[sp,#0x10]
0005cc  2801              CMP      r0,#1
0005ce  d125              BNE      |L1.1564|
;;;689        {
;;;690            bSent = 0;
0005d0  2500              MOVS     r5,#0
;;;691            while (bToSend)
0005d2  e020              B        |L1.1558|
                  |L1.1492|
;;;692            {
;;;693                timeOut = UART_BLOCKING_TIMEOUT;
0005d4  f04f39ff          MOV      r9,#0xffffffff
;;;694    
;;;695                // Wait for THR empty with timeout
;;;696                while (!(*LSR & UART_LSR_THRE))
0005d8  e005              B        |L1.1510|
                  |L1.1498|
;;;697                {
;;;698                    if (timeOut == 0)
0005da  f1b90f00          CMP      r9,#0
0005de  d100              BNE      |L1.1506|
;;;699                        break;
0005e0  e007              B        |L1.1522|
                  |L1.1506|
;;;700    
;;;701                    timeOut--;
0005e2  f1a90901          SUB      r9,r9,#1
                  |L1.1510|
0005e6  9800              LDR      r0,[sp,#0]            ;696
0005e8  6800              LDR      r0,[r0,#0]            ;696
0005ea  f0000020          AND      r0,r0,#0x20           ;696
0005ee  2800              CMP      r0,#0                 ;696
0005f0  d0f3              BEQ      |L1.1498|
                  |L1.1522|
0005f2  bf00              NOP                            ;699
;;;702                }
;;;703    
;;;704                // Time out!
;;;705                if(timeOut == 0)
0005f4  f1b90f00          CMP      r9,#0
0005f8  d100              BNE      |L1.1532|
;;;706                    break;
0005fa  e00e              B        |L1.1562|
                  |L1.1532|
;;;707    
;;;708                fifo_cnt = UART_TX_FIFO_SIZE;
0005fc  2610              MOVS     r6,#0x10
;;;709    
;;;710                while (fifo_cnt && bToSend)
0005fe  e007              B        |L1.1552|
                  |L1.1536|
;;;711                {
;;;712                    UART_SendByte(UartID, (*pChar++));
000600  f8171b01          LDRB     r1,[r7],#1
000604  4640              MOV      r0,r8
000606  f7fffffe          BL       UART_SendByte
;;;713    
;;;714                    fifo_cnt--;
00060a  1e76              SUBS     r6,r6,#1
;;;715    
;;;716                    bToSend--;
00060c  1e64              SUBS     r4,r4,#1
;;;717    
;;;718                    bSent++;
00060e  1c6d              ADDS     r5,r5,#1
                  |L1.1552|
000610  b10e              CBZ      r6,|L1.1558|
000612  2c00              CMP      r4,#0                 ;710
000614  d1f4              BNE      |L1.1536|
                  |L1.1558|
000616  2c00              CMP      r4,#0                 ;691
000618  d1dc              BNE      |L1.1492|
                  |L1.1562|
00061a  e019              B        |L1.1616|
                  |L1.1564|
;;;719                }
;;;720            }
;;;721        }
;;;722    
;;;723        // None blocking mode
;;;724        else
;;;725        {
;;;726            bSent = 0;
00061c  2500              MOVS     r5,#0
;;;727            while (bToSend)
00061e  e014              B        |L1.1610|
                  |L1.1568|
;;;728            {
;;;729                if (bToSend == 0)
000620  b904              CBNZ     r4,|L1.1572|
;;;730                    break;
000622  e014              B        |L1.1614|
                  |L1.1572|
;;;731    
;;;732                if (!(*LSR & UART_LSR_THRE))
000624  9800              LDR      r0,[sp,#0]
000626  6800              LDR      r0,[r0,#0]
000628  f0000020          AND      r0,r0,#0x20
00062c  b900              CBNZ     r0,|L1.1584|
;;;733                {
;;;734                    break;
00062e  e00e              B        |L1.1614|
                  |L1.1584|
;;;735                }
;;;736    
;;;737                fifo_cnt = UART_TX_FIFO_SIZE;
000630  2610              MOVS     r6,#0x10
;;;738    
;;;739                while (fifo_cnt && bToSend)
000632  e007              B        |L1.1604|
                  |L1.1588|
;;;740                {
;;;741                    UART_SendByte(UartID, (*pChar++));
000634  f8171b01          LDRB     r1,[r7],#1
000638  4640              MOV      r0,r8
00063a  f7fffffe          BL       UART_SendByte
;;;742    
;;;743                    bToSend--;
00063e  1e64              SUBS     r4,r4,#1
;;;744    
;;;745                    fifo_cnt--;
000640  1e76              SUBS     r6,r6,#1
;;;746    
;;;747                    bSent++;
000642  1c6d              ADDS     r5,r5,#1
                  |L1.1604|
000644  b10e              CBZ      r6,|L1.1610|
000646  2c00              CMP      r4,#0                 ;739
000648  d1f4              BNE      |L1.1588|
                  |L1.1610|
00064a  2c00              CMP      r4,#0                 ;727
00064c  d1e8              BNE      |L1.1568|
                  |L1.1614|
00064e  bf00              NOP                            ;730
                  |L1.1616|
;;;748                }
;;;749            }
;;;750        }
;;;751    
;;;752        return bSent;
000650  4628              MOV      r0,r5
;;;753    }
000652  b005              ADD      sp,sp,#0x14
000654  e8bd8ff0          POP      {r4-r11,pc}
;;;754    
                          ENDP

                  UART_Receive PROC
;;;772     **********************************************************************/
;;;773    uint32_t UART_Receive(UART_ID_Type UartID, uint8_t *rxbuf,
000658  e92d47f0          PUSH     {r4-r10,lr}
;;;774                                    uint32_t buflen, TRANSFER_BLOCK_Type flag)
;;;775    {
00065c  4605              MOV      r5,r0
00065e  460f              MOV      r7,r1
000660  4690              MOV      r8,r2
000662  4699              MOV      r9,r3
;;;776        uint32_t bToRecv, bRecv, timeOut;
;;;777        uint8_t *pChar = rxbuf;
000664  463c              MOV      r4,r7
;;;778        __IO uint32_t *LSR = NULL;
000666  f04f0a00          MOV      r10,#0
;;;779    
;;;780        switch (UartID)
00066a  2d05              CMP      r5,#5
00066c  d21d              BCS      |L1.1706|
00066e  e8dff005          TBB      [pc,r5]
000672  0308              DCB      0x03,0x08
000674  0d121700          DCB      0x0d,0x12,0x17,0x00
;;;781        {
;;;782            case UART_0:
;;;783                LSR = (__IO uint32_t *)&LPC_UART0->LSR;
000678  f8dfa188          LDR      r10,|L1.2052|
00067c  f10a0a14          ADD      r10,r10,#0x14
;;;784                break;
000680  e013              B        |L1.1706|
;;;785            case UART_1:
;;;786                LSR = (__IO uint32_t *)&LPC_UART1->LSR;
000682  f8dfa178          LDR      r10,|L1.2044|
000686  f10a0a14          ADD      r10,r10,#0x14
;;;787                break;
00068a  e00e              B        |L1.1706|
;;;788            case UART_2:
;;;789                LSR = (__IO uint32_t *)&LPC_UART2->LSR;
00068c  f8dfa178          LDR      r10,|L1.2056|
000690  f10a0a14          ADD      r10,r10,#0x14
;;;790                break;
000694  e009              B        |L1.1706|
;;;791            case UART_3:
;;;792                LSR = (__IO uint32_t *)&LPC_UART3->LSR;
000696  f8dfa174          LDR      r10,|L1.2060|
00069a  f10a0a14          ADD      r10,r10,#0x14
;;;793                break;
00069e  e004              B        |L1.1706|
;;;794            case UART_4:
;;;795                LSR = (__IO uint32_t *)&LPC_UART4->LSR;
0006a0  f8dfa15c          LDR      r10,|L1.2048|
0006a4  f10a0a14          ADD      r10,r10,#0x14
;;;796                break;
0006a8  bf00              NOP      
                  |L1.1706|
0006aa  bf00              NOP                            ;784
;;;797        }
;;;798        
;;;799        bToRecv = buflen;
0006ac  4642              MOV      r2,r8
;;;800    
;;;801        // Blocking mode
;;;802        if (flag == BLOCKING)
0006ae  f1b90f01          CMP      r9,#1
0006b2  d11a              BNE      |L1.1770|
;;;803        {
;;;804            bRecv = 0;
0006b4  2300              MOVS     r3,#0
;;;805            while (bToRecv)
0006b6  e015              B        |L1.1764|
                  |L1.1720|
;;;806            {
;;;807                timeOut = UART_BLOCKING_TIMEOUT;
0006b8  f04f36ff          MOV      r6,#0xffffffff
;;;808                while (!(*LSR & UART_LSR_RDR))
0006bc  e002              B        |L1.1732|
                  |L1.1726|
;;;809                {
;;;810                    if (timeOut == 0)
0006be  b906              CBNZ     r6,|L1.1730|
;;;811                        break;
0006c0  e006              B        |L1.1744|
                  |L1.1730|
;;;812    
;;;813                    timeOut--;
0006c2  1e76              SUBS     r6,r6,#1
                  |L1.1732|
0006c4  f8da0000          LDR      r0,[r10,#0]           ;808
0006c8  f0000001          AND      r0,r0,#1              ;808
0006cc  2800              CMP      r0,#0                 ;808
0006ce  d0f6              BEQ      |L1.1726|
                  |L1.1744|
0006d0  bf00              NOP                            ;811
;;;814                }
;;;815    
;;;816                // Time out!
;;;817                if(timeOut == 0)
0006d2  b906              CBNZ     r6,|L1.1750|
;;;818                    break;
0006d4  e008              B        |L1.1768|
                  |L1.1750|
;;;819    
;;;820                // Get data from the buffer
;;;821                (*pChar++) = UART_ReceiveByte(UartID);
0006d6  4628              MOV      r0,r5
0006d8  f7fffffe          BL       UART_ReceiveByte
0006dc  f8040b01          STRB     r0,[r4],#1
;;;822    
;;;823                bToRecv--;
0006e0  1e52              SUBS     r2,r2,#1
;;;824    
;;;825                bRecv++;
0006e2  1c5b              ADDS     r3,r3,#1
                  |L1.1764|
0006e4  2a00              CMP      r2,#0                 ;805
0006e6  d1e7              BNE      |L1.1720|
                  |L1.1768|
0006e8  e011              B        |L1.1806|
                  |L1.1770|
;;;826            }
;;;827        }
;;;828        // None blocking mode
;;;829        else
;;;830        {
;;;831            bRecv = 0;
0006ea  2300              MOVS     r3,#0
;;;832            while (bToRecv)
0006ec  e00c              B        |L1.1800|
                  |L1.1774|
;;;833            {
;;;834                if (!(*LSR & UART_LSR_RDR))
0006ee  f8da0000          LDR      r0,[r10,#0]
0006f2  f0000001          AND      r0,r0,#1
0006f6  b900              CBNZ     r0,|L1.1786|
;;;835                {
;;;836                    break;
0006f8  e008              B        |L1.1804|
                  |L1.1786|
;;;837                }
;;;838                else
;;;839                {
;;;840                    (*pChar++) = UART_ReceiveByte(UartID);
0006fa  4628              MOV      r0,r5
0006fc  f7fffffe          BL       UART_ReceiveByte
000700  f8040b01          STRB     r0,[r4],#1
;;;841    
;;;842                    bRecv++;
000704  1c5b              ADDS     r3,r3,#1
;;;843    
;;;844                    bToRecv--;
000706  1e52              SUBS     r2,r2,#1
                  |L1.1800|
000708  2a00              CMP      r2,#0                 ;832
00070a  d1f0              BNE      |L1.1774|
                  |L1.1804|
00070c  bf00              NOP                            ;836
                  |L1.1806|
;;;845                }
;;;846            }
;;;847        }
;;;848    
;;;849        return bRecv;
00070e  4618              MOV      r0,r3
;;;850    }
000710  e8bd87f0          POP      {r4-r10,pc}
;;;851    
                          ENDP

                  UART_ForceBreak PROC
;;;862     **********************************************************************/
;;;863    void UART_ForceBreak(UART_ID_Type UartID)
000714  2805              CMP      r0,#5
;;;864    {
;;;865        switch (UartID)
000716  d227              BCS      |L1.1896|
000718  e8dff000          TBB      [pc,r0]
00071c  030a1118          DCB      0x03,0x0a,0x11,0x18
000720  1f00              DCB      0x1f,0x00
;;;866        {
;;;867            case UART_0:
;;;868                LPC_UART0->LCR |= UART_LCR_BREAK_EN;
000722  4938              LDR      r1,|L1.2052|
000724  7b09              LDRB     r1,[r1,#0xc]
000726  f0410140          ORR      r1,r1,#0x40
00072a  4a36              LDR      r2,|L1.2052|
00072c  7311              STRB     r1,[r2,#0xc]
;;;869                break;
00072e  e01b              B        |L1.1896|
;;;870            case UART_1:
;;;871                LPC_UART1->LCR |= UART_LCR_BREAK_EN;
000730  4932              LDR      r1,|L1.2044|
000732  7b09              LDRB     r1,[r1,#0xc]
000734  f0410140          ORR      r1,r1,#0x40
000738  4a30              LDR      r2,|L1.2044|
00073a  7311              STRB     r1,[r2,#0xc]
;;;872                break;
00073c  e014              B        |L1.1896|
;;;873            case UART_2:
;;;874                LPC_UART2->LCR |= UART_LCR_BREAK_EN;
00073e  4932              LDR      r1,|L1.2056|
000740  7b09              LDRB     r1,[r1,#0xc]
000742  f0410140          ORR      r1,r1,#0x40
000746  4a30              LDR      r2,|L1.2056|
000748  7311              STRB     r1,[r2,#0xc]
;;;875                break;
00074a  e00d              B        |L1.1896|
;;;876            case UART_3:
;;;877                LPC_UART3->LCR |= UART_LCR_BREAK_EN;
00074c  492f              LDR      r1,|L1.2060|
00074e  7b09              LDRB     r1,[r1,#0xc]
000750  f0410140          ORR      r1,r1,#0x40
000754  4a2d              LDR      r2,|L1.2060|
000756  7311              STRB     r1,[r2,#0xc]
;;;878                break;
000758  e006              B        |L1.1896|
;;;879            case UART_4:
;;;880                LPC_UART4->LCR |= UART_LCR_BREAK_EN;
00075a  4929              LDR      r1,|L1.2048|
00075c  68c9              LDR      r1,[r1,#0xc]
00075e  f0410140          ORR      r1,r1,#0x40
000762  4a27              LDR      r2,|L1.2048|
000764  60d1              STR      r1,[r2,#0xc]
;;;881                break;
000766  bf00              NOP      
                  |L1.1896|
000768  bf00              NOP                            ;869
;;;882        }
;;;883    }
00076a  4770              BX       lr
;;;884    
                          ENDP

                  UART_IntConfig PROC
;;;908     *********************************************************************/
;;;909    void UART_IntConfig(UART_ID_Type UartID, UART_INT_Type UARTIntCfg, FunctionalState NewState)
00076c  b5f0              PUSH     {r4-r7,lr}
;;;910    {
00076e  4604              MOV      r4,r0
000770  460b              MOV      r3,r1
;;;911        uint32_t tmp;
;;;912        __IO uint32_t *IER = NULL;
000772  2100              MOVS     r1,#0
;;;913        uint32_t IERMask = 0;
000774  2500              MOVS     r5,#0
;;;914    
;;;915        switch (UartID)
000776  2c05              CMP      r4,#5
000778  d21d              BCS      |L1.1974|
00077a  e8dff004          TBB      [pc,r4]
00077e  0308              DCB      0x03,0x08
000780  0d121700          DCB      0x0d,0x12,0x17,0x00
;;;916        {
;;;917            case UART_0:
;;;918                IER = &LPC_UART0->IER;
000784  491f              LDR      r1,|L1.2052|
000786  1d09              ADDS     r1,r1,#4
;;;919                IERMask = UART_IER_BITMASK;
000788  f2403507          MOV      r5,#0x307
;;;920                break;
00078c  e013              B        |L1.1974|
;;;921            case UART_1:
;;;922                IER = &LPC_UART1->IER;
00078e  491b              LDR      r1,|L1.2044|
000790  1d09              ADDS     r1,r1,#4
;;;923                IERMask = UART1_IER_BITMASK;
000792  f240358f          MOV      r5,#0x38f
;;;924                break;
000796  e00e              B        |L1.1974|
;;;925            case UART_2:
;;;926                IER = &LPC_UART2->IER;
000798  491b              LDR      r1,|L1.2056|
00079a  1d09              ADDS     r1,r1,#4
;;;927                IERMask = UART_IER_BITMASK;
00079c  f2403507          MOV      r5,#0x307
;;;928                break;
0007a0  e009              B        |L1.1974|
;;;929            case UART_3:
;;;930                IER = &LPC_UART3->IER;
0007a2  491a              LDR      r1,|L1.2060|
0007a4  1d09              ADDS     r1,r1,#4
;;;931                IERMask = UART_IER_BITMASK;
0007a6  f2403507          MOV      r5,#0x307
;;;932                break;
0007aa  e004              B        |L1.1974|
;;;933            case UART_4:
;;;934                IER = &LPC_UART4->IER;
0007ac  4914              LDR      r1,|L1.2048|
0007ae  1d09              ADDS     r1,r1,#4
;;;935                IERMask = UART_IER_BITMASK;
0007b0  f2403507          MOV      r5,#0x307
;;;936                break;
0007b4  bf00              NOP      
                  |L1.1974|
0007b6  bf00              NOP                            ;920
;;;937        }
;;;938    
;;;939    
;;;940        switch(UARTIntCfg)
0007b8  2b07              CMP      r3,#7
0007ba  d215              BCS      |L1.2024|
0007bc  e8dff003          TBB      [pc,r3]
0007c0  0406080a          DCB      0x04,0x06,0x08,0x0a
0007c4  0c0e1100          DCB      0x0c,0x0e,0x11,0x00
;;;941        {
;;;942            case UART_INTCFG_RBR:
;;;943                tmp = UART_IER_RBRINT_EN;
0007c8  2001              MOVS     r0,#1
;;;944                break;
0007ca  e00d              B        |L1.2024|
;;;945    
;;;946            case UART_INTCFG_THRE:
;;;947                tmp = UART_IER_THREINT_EN;
0007cc  2002              MOVS     r0,#2
;;;948                break;
0007ce  e00b              B        |L1.2024|
;;;949    
;;;950            case UART_INTCFG_RLS:
;;;951                tmp = UART_IER_RLSINT_EN;
0007d0  2004              MOVS     r0,#4
;;;952                break;
0007d2  e009              B        |L1.2024|
;;;953    
;;;954            case UART_INTCFG_MS:
;;;955                tmp = UART1_IER_MSINT_EN;
0007d4  2008              MOVS     r0,#8
;;;956                break;
0007d6  e007              B        |L1.2024|
;;;957    
;;;958            case UART_INTCFG_CTS:
;;;959                tmp = UART1_IER_CTSINT_EN;
0007d8  2080              MOVS     r0,#0x80
;;;960                break;
0007da  e005              B        |L1.2024|
;;;961    
;;;962            case UART_INTCFG_ABEO:
;;;963                tmp = UART_IER_ABEOINT_EN;
0007dc  f44f7080          MOV      r0,#0x100
;;;964                break;
0007e0  e002              B        |L1.2024|
;;;965    
;;;966            case UART_INTCFG_ABTO:
;;;967                tmp = UART_IER_ABTOINT_EN;
0007e2  f44f7000          MOV      r0,#0x200
;;;968                break;
0007e6  bf00              NOP      
                  |L1.2024|
0007e8  bf00              NOP                            ;944
;;;969        }
;;;970    
;;;971        if (NewState == ENABLE)
0007ea  2a01              CMP      r2,#1
0007ec  d110              BNE      |L1.2064|
;;;972        {
;;;973            *IER |= tmp& IERMask;
0007ee  680e              LDR      r6,[r1,#0]
0007f0  ea000705          AND      r7,r0,r5
0007f4  433e              ORRS     r6,r6,r7
0007f6  600e              STR      r6,[r1,#0]
0007f8  e00f              B        |L1.2074|
0007fa  0000              DCW      0x0000
                  |L1.2044|
                          DCD      0x40010000
                  |L1.2048|
                          DCD      0x400a4000
                  |L1.2052|
                          DCD      0x4000c000
                  |L1.2056|
                          DCD      0x40098000
                  |L1.2060|
                          DCD      0x4009c000
                  |L1.2064|
;;;974        }
;;;975        else
;;;976        {
;;;977            *IER &= (~tmp) & IERMask;
000810  680e              LDR      r6,[r1,#0]
000812  ea250700          BIC      r7,r5,r0
000816  403e              ANDS     r6,r6,r7
000818  600e              STR      r6,[r1,#0]
                  |L1.2074|
;;;978        }
;;;979    }
00081a  bdf0              POP      {r4-r7,pc}
;;;980    
                          ENDP

                  UART_GetLineStatus PROC
;;;998     *********************************************************************/
;;;999    uint8_t UART_GetLineStatus(UART_ID_Type UartID)
00081c  4601              MOV      r1,r0
;;;1000   {
;;;1001       switch (UartID)
00081e  2905              CMP      r1,#5
000820  d214              BCS      |L1.2124|
000822  e8dff001          TBB      [pc,r1]
000826  0306              DCB      0x03,0x06
000828  090c0f00          DCB      0x09,0x0c,0x0f,0x00
;;;1002       {
;;;1003           case UART_0:
;;;1004               return ((LPC_UART0->LSR) & UART_LSR_BITMASK);
00082c  48fe              LDR      r0,|L1.3112|
00082e  7d00              LDRB     r0,[r0,#0x14]
                  |L1.2096|
;;;1005           case UART_1:
;;;1006               return ((LPC_UART1->LSR) & UART_LSR_BITMASK);
;;;1007           case UART_2:
;;;1008               return ((LPC_UART2->LSR) & UART_LSR_BITMASK);
;;;1009           case UART_3:
;;;1010               return ((LPC_UART3->LSR) & UART_LSR_BITMASK);
;;;1011           case UART_4:
;;;1012               return ((LPC_UART4->LSR) & UART_LSR_BITMASK);
;;;1013       }
;;;1014       return 0;
;;;1015   }
000830  4770              BX       lr
000832  48fe              LDR      r0,|L1.3116|
000834  7d00              LDRB     r0,[r0,#0x14]         ;1006
000836  e7fb              B        |L1.2096|
000838  48fd              LDR      r0,|L1.3120|
00083a  7d00              LDRB     r0,[r0,#0x14]         ;1008
00083c  e7f8              B        |L1.2096|
00083e  48fd              LDR      r0,|L1.3124|
000840  7d00              LDRB     r0,[r0,#0x14]         ;1010
000842  e7f5              B        |L1.2096|
000844  48fc              LDR      r0,|L1.3128|
000846  6940              LDR      r0,[r0,#0x14]         ;1012
000848  b2c0              UXTB     r0,r0                 ;1012
00084a  e7f1              B        |L1.2096|
                  |L1.2124|
00084c  2000              MOVS     r0,#0                 ;1014
00084e  e7ef              B        |L1.2096|
;;;1016   
                          ENDP

                  UART_GetIntId PROC
;;;1026    *********************************************************************/
;;;1027   uint32_t UART_GetIntId(UART_ID_Type UartID)
000850  4601              MOV      r1,r0
;;;1028   {
;;;1029       switch (UartID)
000852  2905              CMP      r1,#5
000854  d222              BCS      |L1.2204|
000856  e8dff001          TBB      [pc,r1]
00085a  0309              DCB      0x03,0x09
00085c  0f151b00          DCB      0x0f,0x15,0x1b,0x00
;;;1030       {
;;;1031           case UART_0:
;;;1032               return ((LPC_UART0->IIR) & UART_IIR_BITMASK);
000860  48f1              LDR      r0,|L1.3112|
000862  6880              LDR      r0,[r0,#8]
000864  f24032cf          MOV      r2,#0x3cf
000868  4010              ANDS     r0,r0,r2
                  |L1.2154|
;;;1033           case UART_1:
;;;1034               return ((LPC_UART1->IIR) & UART_IIR_BITMASK);
;;;1035           case UART_2:
;;;1036               return ((LPC_UART2->IIR) & UART_IIR_BITMASK);
;;;1037           case UART_3:
;;;1038               return ((LPC_UART3->IIR) & UART_IIR_BITMASK);
;;;1039           case UART_4:
;;;1040               return ((LPC_UART4->IIR) & UART_IIR_BITMASK);
;;;1041       }
;;;1042       return 0;
;;;1043   }
00086a  4770              BX       lr
00086c  48ef              LDR      r0,|L1.3116|
00086e  6880              LDR      r0,[r0,#8]            ;1034
000870  f24032cf          MOV      r2,#0x3cf             ;1034
000874  4010              ANDS     r0,r0,r2              ;1034
000876  e7f8              B        |L1.2154|
000878  48ed              LDR      r0,|L1.3120|
00087a  6880              LDR      r0,[r0,#8]            ;1036
00087c  f24032cf          MOV      r2,#0x3cf             ;1036
000880  4010              ANDS     r0,r0,r2              ;1036
000882  e7f2              B        |L1.2154|
000884  48eb              LDR      r0,|L1.3124|
000886  6880              LDR      r0,[r0,#8]            ;1038
000888  f24032cf          MOV      r2,#0x3cf             ;1038
00088c  4010              ANDS     r0,r0,r2              ;1038
00088e  e7ec              B        |L1.2154|
000890  48e9              LDR      r0,|L1.3128|
000892  6880              LDR      r0,[r0,#8]            ;1040
000894  f24032cf          MOV      r2,#0x3cf             ;1040
000898  4010              ANDS     r0,r0,r2              ;1040
00089a  e7e6              B        |L1.2154|
                  |L1.2204|
00089c  2000              MOVS     r0,#0                 ;1042
00089e  e7e4              B        |L1.2154|
;;;1044   
                          ENDP

                  UART_CheckBusy PROC
;;;1054    **********************************************************************/
;;;1055   FlagStatus UART_CheckBusy(UART_ID_Type UartID)
0008a0  4601              MOV      r1,r0
;;;1056   {
;;;1057       uint32_t LSR = 0;
0008a2  2200              MOVS     r2,#0
;;;1058       switch (UartID)
0008a4  2905              CMP      r1,#5
0008a6  d21d              BCS      |L1.2276|
0008a8  e8dff001          TBB      [pc,r1]
0008ac  03080d12          DCB      0x03,0x08,0x0d,0x12
0008b0  1700              DCB      0x17,0x00
;;;1059       {
;;;1060           case UART_0:
;;;1061               LSR = (LPC_UART0)->LSR & UART_LSR_TEMT;
0008b2  48dd              LDR      r0,|L1.3112|
0008b4  7d00              LDRB     r0,[r0,#0x14]
0008b6  f0000240          AND      r2,r0,#0x40
;;;1062               break;
0008ba  e013              B        |L1.2276|
;;;1063           case UART_1:
;;;1064               LSR = (LPC_UART1)->LSR & UART_LSR_TEMT;
0008bc  48db              LDR      r0,|L1.3116|
0008be  7d00              LDRB     r0,[r0,#0x14]
0008c0  f0000240          AND      r2,r0,#0x40
;;;1065               break;
0008c4  e00e              B        |L1.2276|
;;;1066           case UART_2:
;;;1067               LSR = (LPC_UART2)->LSR & UART_LSR_TEMT;
0008c6  48da              LDR      r0,|L1.3120|
0008c8  7d00              LDRB     r0,[r0,#0x14]
0008ca  f0000240          AND      r2,r0,#0x40
;;;1068               break;
0008ce  e009              B        |L1.2276|
;;;1069           case UART_3:
;;;1070               LSR = (LPC_UART3)->LSR & UART_LSR_TEMT;
0008d0  48d8              LDR      r0,|L1.3124|
0008d2  7d00              LDRB     r0,[r0,#0x14]
0008d4  f0000240          AND      r2,r0,#0x40
;;;1071               break;
0008d8  e004              B        |L1.2276|
;;;1072           case UART_4:
;;;1073               LSR = (LPC_UART4)->LSR & UART_LSR_TEMT;
0008da  48d7              LDR      r0,|L1.3128|
0008dc  6940              LDR      r0,[r0,#0x14]
0008de  f0000240          AND      r2,r0,#0x40
;;;1074               break;
0008e2  bf00              NOP      
                  |L1.2276|
0008e4  bf00              NOP                            ;1062
;;;1075       }
;;;1076       
;;;1077       if (LSR & UART_LSR_TEMT)
0008e6  f0020040          AND      r0,r2,#0x40
0008ea  b108              CBZ      r0,|L1.2288|
;;;1078       {
;;;1079           return RESET;
0008ec  2000              MOVS     r0,#0
                  |L1.2286|
;;;1080       }
;;;1081       return SET;
;;;1082   }
0008ee  4770              BX       lr
                  |L1.2288|
0008f0  2001              MOVS     r0,#1                 ;1081
0008f2  e7fc              B        |L1.2286|
;;;1083   
                          ENDP

                  UART_FIFOConfig PROC
;;;1096    **********************************************************************/
;;;1097   void UART_FIFOConfig(UART_ID_Type UartID, UART_FIFO_CFG_Type *FIFOCfg)
0008f4  b510              PUSH     {r4,lr}
;;;1098   {
0008f6  4602              MOV      r2,r0
;;;1099       uint8_t tmp = 0;
0008f8  2000              MOVS     r0,#0
;;;1100   
;;;1101       tmp |= UART_FCR_FIFO_EN;
0008fa  f0400001          ORR      r0,r0,#1
;;;1102   
;;;1103       switch (FIFOCfg->FIFO_Level)
0008fe  78cb              LDRB     r3,[r1,#3]
000900  b133              CBZ      r3,|L1.2320|
000902  2b01              CMP      r3,#1
000904  d006              BEQ      |L1.2324|
000906  2b02              CMP      r3,#2
000908  d007              BEQ      |L1.2330|
00090a  2b03              CMP      r3,#3
00090c  d108              BNE      |L1.2336|
00090e  e008              B        |L1.2338|
                  |L1.2320|
;;;1104       {
;;;1105           case UART_FIFO_TRGLEV0:
;;;1106               tmp |= UART_FCR_TRG_LEV0;
000910  bf00              NOP      
;;;1107               break;
000912  e009              B        |L1.2344|
                  |L1.2324|
;;;1108   
;;;1109           case UART_FIFO_TRGLEV1:
;;;1110               tmp |= UART_FCR_TRG_LEV1;
000914  f0400040          ORR      r0,r0,#0x40
;;;1111               break;
000918  e006              B        |L1.2344|
                  |L1.2330|
;;;1112   
;;;1113           case UART_FIFO_TRGLEV2:
;;;1114               tmp |= UART_FCR_TRG_LEV2;
00091a  f0400080          ORR      r0,r0,#0x80
;;;1115               break;
00091e  e003              B        |L1.2344|
                  |L1.2336|
;;;1116   
;;;1117           case UART_FIFO_TRGLEV3:
000920  bf00              NOP      
                  |L1.2338|
;;;1118   
;;;1119           default:
;;;1120               tmp |= UART_FCR_TRG_LEV3;
000922  f04000c0          ORR      r0,r0,#0xc0
;;;1121               break;
000926  bf00              NOP      
                  |L1.2344|
000928  bf00              NOP                            ;1107
;;;1122       }
;;;1123   
;;;1124       if (FIFOCfg->FIFO_ResetTxBuf == ENABLE)
00092a  784b              LDRB     r3,[r1,#1]
00092c  2b01              CMP      r3,#1
00092e  d101              BNE      |L1.2356|
;;;1125       {
;;;1126           tmp |= UART_FCR_TX_RS;
000930  f0400004          ORR      r0,r0,#4
                  |L1.2356|
;;;1127       }
;;;1128   
;;;1129       if (FIFOCfg->FIFO_ResetRxBuf == ENABLE)
000934  780b              LDRB     r3,[r1,#0]
000936  2b01              CMP      r3,#1
000938  d101              BNE      |L1.2366|
;;;1130       {
;;;1131           tmp |= UART_FCR_RX_RS;
00093a  f0400002          ORR      r0,r0,#2
                  |L1.2366|
;;;1132       }
;;;1133   
;;;1134       if (FIFOCfg->FIFO_DMAMode == ENABLE)
00093e  788b              LDRB     r3,[r1,#2]
000940  2b01              CMP      r3,#1
000942  d101              BNE      |L1.2376|
;;;1135       {
;;;1136           tmp |= UART_FCR_DMAMODE_SEL;
000944  f0400008          ORR      r0,r0,#8
                  |L1.2376|
;;;1137       }
;;;1138   
;;;1139   
;;;1140       //write to FIFO control register
;;;1141       switch (UartID)
000948  2a05              CMP      r2,#5
00094a  d21d              BCS      |L1.2440|
00094c  e8dff002          TBB      [pc,r2]
000950  03080d12          DCB      0x03,0x08,0x0d,0x12
000954  1700              DCB      0x17,0x00
;;;1142       {
;;;1143           case UART_0:
;;;1144               LPC_UART0->FCR = tmp & UART_FCR_BITMASK;
000956  f00003cf          AND      r3,r0,#0xcf
00095a  4cb3              LDR      r4,|L1.3112|
00095c  7223              STRB     r3,[r4,#8]
;;;1145               break;
00095e  e013              B        |L1.2440|
;;;1146           case UART_1:
;;;1147               LPC_UART1->FCR = tmp & UART_FCR_BITMASK;
000960  f00003cf          AND      r3,r0,#0xcf
000964  4cb1              LDR      r4,|L1.3116|
000966  7223              STRB     r3,[r4,#8]
;;;1148               break;
000968  e00e              B        |L1.2440|
;;;1149           case UART_2:
;;;1150               LPC_UART2->FCR = tmp & UART_FCR_BITMASK;
00096a  f00003cf          AND      r3,r0,#0xcf
00096e  4cb0              LDR      r4,|L1.3120|
000970  7223              STRB     r3,[r4,#8]
;;;1151               break;
000972  e009              B        |L1.2440|
;;;1152           case UART_3:
;;;1153               LPC_UART3->FCR = tmp & UART_FCR_BITMASK;
000974  f00003cf          AND      r3,r0,#0xcf
000978  4cae              LDR      r4,|L1.3124|
00097a  7223              STRB     r3,[r4,#8]
;;;1154               break;
00097c  e004              B        |L1.2440|
;;;1155           case UART_4:
;;;1156               LPC_UART4->FCR = tmp & UART_FCR_BITMASK;
00097e  f00003cf          AND      r3,r0,#0xcf
000982  4cad              LDR      r4,|L1.3128|
000984  60a3              STR      r3,[r4,#8]
;;;1157               break;
000986  bf00              NOP      
                  |L1.2440|
000988  bf00              NOP                            ;1145
;;;1158       }
;;;1159   }
00098a  bd10              POP      {r4,pc}
;;;1160   
                          ENDP

                  UART_FIFOConfigStructInit PROC
;;;1171   *******************************************************************************/
;;;1172   void UART_FIFOConfigStructInit(UART_FIFO_CFG_Type *UART_FIFOInitStruct)
00098c  2100              MOVS     r1,#0
;;;1173   {
;;;1174       UART_FIFOInitStruct->FIFO_DMAMode = DISABLE;
00098e  7081              STRB     r1,[r0,#2]
;;;1175   
;;;1176       UART_FIFOInitStruct->FIFO_Level = UART_FIFO_TRGLEV0;
000990  70c1              STRB     r1,[r0,#3]
;;;1177   
;;;1178       UART_FIFOInitStruct->FIFO_ResetRxBuf = ENABLE;
000992  2101              MOVS     r1,#1
000994  7001              STRB     r1,[r0,#0]
;;;1179   
;;;1180       UART_FIFOInitStruct->FIFO_ResetTxBuf = ENABLE;
000996  7041              STRB     r1,[r0,#1]
;;;1181   }
000998  4770              BX       lr
;;;1182   
                          ENDP

                  UART_ABCmd PROC
;;;1201    **********************************************************************/
;;;1202   void UART_ABCmd(UART_ID_Type UartID, UART_AB_CFG_Type *ABConfigStruct,
00099a  e92d41f0          PUSH     {r4-r8,lr}
;;;1203                               FunctionalState NewState)
;;;1204   {
00099e  4607              MOV      r7,r0
0009a0  4688              MOV      r8,r1
0009a2  4615              MOV      r5,r2
;;;1205       uint32_t tmp;
;;;1206   
;;;1207       tmp = 0;
0009a4  2600              MOVS     r6,#0
;;;1208       if (NewState == ENABLE)
0009a6  2d01              CMP      r5,#1
0009a8  d10b              BNE      |L1.2498|
;;;1209       {
;;;1210           if (ABConfigStruct->ABMode == UART_AUTOBAUD_MODE1)
0009aa  f8980000          LDRB     r0,[r8,#0]
0009ae  2801              CMP      r0,#1
0009b0  d101              BNE      |L1.2486|
;;;1211           {
;;;1212               tmp |= UART_ACR_MODE;
0009b2  f0460602          ORR      r6,r6,#2
                  |L1.2486|
;;;1213           }
;;;1214           if (ABConfigStruct->AutoRestart == ENABLE)
0009b6  f8980001          LDRB     r0,[r8,#1]
0009ba  2801              CMP      r0,#1
0009bc  d101              BNE      |L1.2498|
;;;1215           {
;;;1216               tmp |= UART_ACR_AUTO_RESTART;
0009be  f0460604          ORR      r6,r6,#4
                  |L1.2498|
;;;1217           }
;;;1218       }
;;;1219   
;;;1220       if (UartID == UART_1)
0009c2  2f01              CMP      r7,#1
0009c4  d119              BNE      |L1.2554|
;;;1221       {
;;;1222           if (NewState == ENABLE)
0009c6  2d01              CMP      r5,#1
0009c8  d113              BNE      |L1.2546|
;;;1223           {
;;;1224               // Clear DLL and DLM value
;;;1225               LPC_UART1->LCR |= UART_LCR_DLAB_EN;
0009ca  4898              LDR      r0,|L1.3116|
0009cc  7b00              LDRB     r0,[r0,#0xc]
0009ce  f0400080          ORR      r0,r0,#0x80
0009d2  4996              LDR      r1,|L1.3116|
0009d4  7308              STRB     r0,[r1,#0xc]
;;;1226   
;;;1227               LPC_UART1->DLL = 0;
0009d6  2000              MOVS     r0,#0
0009d8  7008              STRB     r0,[r1,#0]
;;;1228   
;;;1229               LPC_UART1->DLM = 0;
0009da  7108              STRB     r0,[r1,#4]
;;;1230   
;;;1231               LPC_UART1->LCR &= ~UART_LCR_DLAB_EN;
0009dc  4608              MOV      r0,r1
0009de  7b00              LDRB     r0,[r0,#0xc]
0009e0  f0200080          BIC      r0,r0,#0x80
0009e4  7308              STRB     r0,[r1,#0xc]
;;;1232   
;;;1233               // FDR value must be reset to default value
;;;1234               LPC_UART1->FDR = 0x10;
0009e6  2010              MOVS     r0,#0x10
0009e8  6288              STR      r0,[r1,#0x28]
;;;1235   
;;;1236               LPC_UART1->ACR = UART_ACR_START | tmp;
0009ea  f0460001          ORR      r0,r6,#1
0009ee  6208              STR      r0,[r1,#0x20]
0009f0  e03a              B        |L1.2664|
                  |L1.2546|
;;;1237           }
;;;1238           else
;;;1239           {
;;;1240               LPC_UART1->ACR = 0;
0009f2  2000              MOVS     r0,#0
0009f4  498d              LDR      r1,|L1.3116|
0009f6  6208              STR      r0,[r1,#0x20]
0009f8  e036              B        |L1.2664|
                  |L1.2554|
;;;1241           }
;;;1242       }
;;;1243       else if (UartID == UART_4)
0009fa  2f04              CMP      r7,#4
0009fc  d119              BNE      |L1.2610|
;;;1244       {
;;;1245           if (NewState == ENABLE)
0009fe  2d01              CMP      r5,#1
000a00  d113              BNE      |L1.2602|
;;;1246           {
;;;1247               // Clear DLL and DLM value
;;;1248               LPC_UART4->LCR |= UART_LCR_DLAB_EN;
000a02  488d              LDR      r0,|L1.3128|
000a04  68c0              LDR      r0,[r0,#0xc]
000a06  f0400080          ORR      r0,r0,#0x80
000a0a  498b              LDR      r1,|L1.3128|
000a0c  60c8              STR      r0,[r1,#0xc]
;;;1249   
;;;1250               LPC_UART4->DLL = 0;
000a0e  2000              MOVS     r0,#0
000a10  6008              STR      r0,[r1,#0]
;;;1251   
;;;1252               LPC_UART4->DLM = 0;
000a12  6048              STR      r0,[r1,#4]
;;;1253   
;;;1254               LPC_UART4->LCR &= ~UART_LCR_DLAB_EN;
000a14  4608              MOV      r0,r1
000a16  68c0              LDR      r0,[r0,#0xc]
000a18  f0200080          BIC      r0,r0,#0x80
000a1c  60c8              STR      r0,[r1,#0xc]
;;;1255   
;;;1256               // FDR value must be reset to default value
;;;1257               LPC_UART4->FDR = 0x10;
000a1e  2010              MOVS     r0,#0x10
000a20  6288              STR      r0,[r1,#0x28]
;;;1258   
;;;1259               LPC_UART4->ACR = UART_ACR_START | tmp;
000a22  f0460001          ORR      r0,r6,#1
000a26  6208              STR      r0,[r1,#0x20]
000a28  e01e              B        |L1.2664|
                  |L1.2602|
;;;1260           }
;;;1261           else
;;;1262           {
;;;1263               LPC_UART4->ACR = 0;
000a2a  2000              MOVS     r0,#0
000a2c  4982              LDR      r1,|L1.3128|
000a2e  6208              STR      r0,[r1,#0x20]
000a30  e01a              B        |L1.2664|
                  |L1.2610|
;;;1264           }
;;;1265       }
;;;1266       else
;;;1267       {
;;;1268           LPC_UART_TypeDef *UARTx = uart_get_pointer(UartID);
000a32  4638              MOV      r0,r7
000a34  f7fffffe          BL       uart_get_pointer
000a38  4604              MOV      r4,r0
;;;1269           if (NewState == ENABLE)
000a3a  2d01              CMP      r5,#1
000a3c  d111              BNE      |L1.2658|
;;;1270           {
;;;1271               // Clear DLL and DLM value
;;;1272               UARTx->LCR |= UART_LCR_DLAB_EN;
000a3e  7b20              LDRB     r0,[r4,#0xc]
000a40  f0400080          ORR      r0,r0,#0x80
000a44  7320              STRB     r0,[r4,#0xc]
;;;1273   
;;;1274               UARTx->DLL = 0;
000a46  2000              MOVS     r0,#0
000a48  7020              STRB     r0,[r4,#0]
;;;1275   
;;;1276               UARTx->DLM = 0;
000a4a  7120              STRB     r0,[r4,#4]
;;;1277   
;;;1278               UARTx->LCR &= ~UART_LCR_DLAB_EN;
000a4c  7b20              LDRB     r0,[r4,#0xc]
000a4e  f0200080          BIC      r0,r0,#0x80
000a52  7320              STRB     r0,[r4,#0xc]
;;;1279   
;;;1280               // FDR value must be reset to default value
;;;1281               UARTx->FDR = 0x10;
000a54  2010              MOVS     r0,#0x10
000a56  f8840028          STRB     r0,[r4,#0x28]
;;;1282   
;;;1283               UARTx->ACR = UART_ACR_START | tmp;
000a5a  f0460001          ORR      r0,r6,#1
000a5e  6220              STR      r0,[r4,#0x20]
000a60  e001              B        |L1.2662|
                  |L1.2658|
;;;1284           }
;;;1285           else
;;;1286           {
;;;1287               UARTx->ACR = 0;
000a62  2000              MOVS     r0,#0
000a64  6220              STR      r0,[r4,#0x20]
                  |L1.2662|
;;;1288           }
;;;1289       }
000a66  bf00              NOP      
                  |L1.2664|
;;;1290   }
000a68  e8bd81f0          POP      {r4-r8,pc}
;;;1291   
                          ENDP

                  UART_ABClearIntPending PROC
;;;1304    **********************************************************************/
;;;1305   void UART_ABClearIntPending(UART_ID_Type UartID, UART_ABEO_Type ABIntType)
000a6c  b570              PUSH     {r4-r6,lr}
;;;1306   {
000a6e  4605              MOV      r5,r0
000a70  460c              MOV      r4,r1
;;;1307       if (UartID == UART_1)
000a72  2d01              CMP      r5,#1
000a74  d105              BNE      |L1.2690|
;;;1308       {
;;;1309           LPC_UART1->ACR |= ABIntType;
000a76  486d              LDR      r0,|L1.3116|
000a78  6a00              LDR      r0,[r0,#0x20]
000a7a  4320              ORRS     r0,r0,r4
000a7c  496b              LDR      r1,|L1.3116|
000a7e  6208              STR      r0,[r1,#0x20]
000a80  e00f              B        |L1.2722|
                  |L1.2690|
;;;1310       }
;;;1311       else if (UartID == UART_4)
000a82  2d04              CMP      r5,#4
000a84  d105              BNE      |L1.2706|
;;;1312       {
;;;1313           LPC_UART4->ACR |= ABIntType;
000a86  486c              LDR      r0,|L1.3128|
000a88  6a00              LDR      r0,[r0,#0x20]
000a8a  4320              ORRS     r0,r0,r4
000a8c  496a              LDR      r1,|L1.3128|
000a8e  6208              STR      r0,[r1,#0x20]
000a90  e007              B        |L1.2722|
                  |L1.2706|
;;;1314       }
;;;1315       else
;;;1316       {   
;;;1317           LPC_UART_TypeDef *UARTx = uart_get_pointer(UartID);
000a92  4628              MOV      r0,r5
000a94  f7fffffe          BL       uart_get_pointer
000a98  4606              MOV      r6,r0
;;;1318           UARTx->ACR |= ABIntType;
000a9a  6a30              LDR      r0,[r6,#0x20]
000a9c  4320              ORRS     r0,r0,r4
000a9e  6230              STR      r0,[r6,#0x20]
;;;1319       }
000aa0  bf00              NOP      
                  |L1.2722|
;;;1320   }
000aa2  bd70              POP      {r4-r6,pc}
;;;1321   
                          ENDP

                  UART_IrDAInvtInputCmd PROC
;;;1380    **********************************************************************/
;;;1381   void UART_IrDAInvtInputCmd(UART_ID_Type UartID, FunctionalState NewState)
000aa4  2804              CMP      r0,#4
;;;1382   {
;;;1383       if (UartID != UART_4)
000aa6  d000              BEQ      |L1.2730|
                  |L1.2728|
;;;1384           return;
;;;1385       
;;;1386       if (NewState == ENABLE)
;;;1387       {
;;;1388           LPC_UART4->ICR |= UART_ICR_IRDAINV;
;;;1389       }
;;;1390       else if (NewState == DISABLE)
;;;1391       {
;;;1392           LPC_UART4->ICR &= (~UART_ICR_IRDAINV) & UART_ICR_BITMASK;
;;;1393       }
;;;1394       
;;;1395   }
000aa8  4770              BX       lr
                  |L1.2730|
000aaa  2901              CMP      r1,#1                 ;1386
000aac  d106              BNE      |L1.2748|
000aae  4a62              LDR      r2,|L1.3128|
000ab0  6a52              LDR      r2,[r2,#0x24]         ;1388
000ab2  f0420202          ORR      r2,r2,#2              ;1388
000ab6  4b60              LDR      r3,|L1.3128|
000ab8  625a              STR      r2,[r3,#0x24]         ;1388
000aba  e006              B        |L1.2762|
                  |L1.2748|
000abc  b929              CBNZ     r1,|L1.2762|
000abe  4a5e              LDR      r2,|L1.3128|
000ac0  6a52              LDR      r2,[r2,#0x24]         ;1392
000ac2  f002023d          AND      r2,r2,#0x3d           ;1392
000ac6  4b5c              LDR      r3,|L1.3128|
000ac8  625a              STR      r2,[r3,#0x24]         ;1392
                  |L1.2762|
000aca  bf00              NOP      
000acc  e7ec              B        |L1.2728|
;;;1396   
                          ENDP

                  UART_IrDACmd PROC
;;;1405    **********************************************************************/
;;;1406   void UART_IrDACmd(UART_ID_Type UartID, FunctionalState NewState)
000ace  2804              CMP      r0,#4
;;;1407   {
;;;1408       if (UartID != UART_4)
000ad0  d000              BEQ      |L1.2772|
                  |L1.2770|
;;;1409           return;
;;;1410       
;;;1411       if (NewState == ENABLE)
;;;1412       {
;;;1413           LPC_UART4->ICR |= UART_ICR_IRDAEN;
;;;1414       }
;;;1415       else
;;;1416       {
;;;1417           LPC_UART4->ICR &= (~UART_ICR_IRDAEN) & UART_ICR_BITMASK;
;;;1418       }
;;;1419   }
000ad2  4770              BX       lr
                  |L1.2772|
000ad4  2901              CMP      r1,#1                 ;1411
000ad6  d106              BNE      |L1.2790|
000ad8  4a57              LDR      r2,|L1.3128|
000ada  6a52              LDR      r2,[r2,#0x24]         ;1413
000adc  f0420201          ORR      r2,r2,#1              ;1413
000ae0  4b55              LDR      r3,|L1.3128|
000ae2  625a              STR      r2,[r3,#0x24]         ;1413
000ae4  e005              B        |L1.2802|
                  |L1.2790|
000ae6  4a54              LDR      r2,|L1.3128|
000ae8  6a52              LDR      r2,[r2,#0x24]         ;1417
000aea  f002023e          AND      r2,r2,#0x3e           ;1417
000aee  4b52              LDR      r3,|L1.3128|
000af0  625a              STR      r2,[r3,#0x24]         ;1417
                  |L1.2802|
000af2  bf00              NOP      
000af4  e7ed              B        |L1.2770|
;;;1420   
                          ENDP

                  UART_IrDAPulseDivConfig PROC
;;;1437    **********************************************************************/
;;;1438   void UART_IrDAPulseDivConfig(UART_ID_Type UartID, UART_IrDA_PULSE_Type PulseDiv)
000af6  b530              PUSH     {r4,r5,lr}
;;;1439   {
;;;1440       uint32_t tmp, tmp1;
;;;1441   
;;;1442       if (UartID != UART_4)
000af8  2804              CMP      r0,#4
000afa  d000              BEQ      |L1.2814|
                  |L1.2812|
;;;1443           return;
;;;1444   
;;;1445       tmp1 = UART_ICR_PULSEDIV(PulseDiv);
;;;1446   
;;;1447       tmp = LPC_UART4->ICR & (~ UART_ICR_PULSEDIV(7));
;;;1448   
;;;1449       tmp |= tmp1 | UART_ICR_FIXPULSE_EN;
;;;1450   
;;;1451       LPC_UART4->ICR = tmp & UART_ICR_BITMASK;
;;;1452   }
000afc  bd30              POP      {r4,r5,pc}
                  |L1.2814|
000afe  074c              LSLS     r4,r1,#29             ;1445
000b00  0ea3              LSRS     r3,r4,#26             ;1445
000b02  4c4d              LDR      r4,|L1.3128|
000b04  6a64              LDR      r4,[r4,#0x24]         ;1447
000b06  f0240238          BIC      r2,r4,#0x38           ;1447
000b0a  f0430404          ORR      r4,r3,#4              ;1449
000b0e  4322              ORRS     r2,r2,r4              ;1449
000b10  f002043f          AND      r4,r2,#0x3f           ;1451
000b14  4d48              LDR      r5,|L1.3128|
000b16  626c              STR      r4,[r5,#0x24]         ;1451
000b18  bf00              NOP      
000b1a  e7ef              B        |L1.2812|
;;;1453   
                          ENDP

                  UART_FullModemForcePinState PROC
;;;1466    **********************************************************************/
;;;1467   void UART_FullModemForcePinState(UART_ID_Type UartID,
000b1c  b530              PUSH     {r4,r5,lr}
;;;1468                                                       UART_MODEM_PIN_Type Pin,
;;;1469                                                       UART1_SignalState NewState)
;;;1470   {
;;;1471       uint8_t tmp = 0;
000b1e  2300              MOVS     r3,#0
;;;1472       if (UartID != UART_1)
000b20  2801              CMP      r0,#1
000b22  d000              BEQ      |L1.2854|
                  |L1.2852|
;;;1473           return;
;;;1474       switch (Pin)
;;;1475       {
;;;1476           case UART1_MODEM_PIN_DTR:
;;;1477               tmp = UART1_MCR_DTR_CTRL;
;;;1478               break;
;;;1479   
;;;1480           case UART1_MODEM_PIN_RTS:
;;;1481               tmp = UART1_MCR_RTS_CTRL;
;;;1482               break;
;;;1483   
;;;1484           default:
;;;1485               break;
;;;1486       }
;;;1487   
;;;1488       if (NewState == ACTIVE)
;;;1489       {
;;;1490           LPC_UART1->MCR |= tmp;
;;;1491       }
;;;1492       else
;;;1493       {
;;;1494           LPC_UART1->MCR &= (~tmp) & UART1_MCR_BITMASK;
;;;1495       }
;;;1496   }
000b24  bd30              POP      {r4,r5,pc}
                  |L1.2854|
000b26  b111              CBZ      r1,|L1.2862|
000b28  2901              CMP      r1,#1                 ;1474
000b2a  d104              BNE      |L1.2870|
000b2c  e001              B        |L1.2866|
                  |L1.2862|
000b2e  2301              MOVS     r3,#1                 ;1477
000b30  e002              B        |L1.2872|
                  |L1.2866|
000b32  2302              MOVS     r3,#2                 ;1481
000b34  e000              B        |L1.2872|
                  |L1.2870|
000b36  bf00              NOP                            ;1485
                  |L1.2872|
000b38  bf00              NOP                            ;1478
000b3a  2a01              CMP      r2,#1                 ;1488
000b3c  d105              BNE      |L1.2890|
000b3e  4c3b              LDR      r4,|L1.3116|
000b40  7c24              LDRB     r4,[r4,#0x10]         ;1490
000b42  431c              ORRS     r4,r4,r3              ;1490
000b44  4d39              LDR      r5,|L1.3116|
000b46  742c              STRB     r4,[r5,#0x10]         ;1490
000b48  e006              B        |L1.2904|
                  |L1.2890|
000b4a  4c38              LDR      r4,|L1.3116|
000b4c  7c24              LDRB     r4,[r4,#0x10]         ;1494
000b4e  25f3              MOVS     r5,#0xf3              ;1494
000b50  439d              BICS     r5,r5,r3              ;1494
000b52  402c              ANDS     r4,r4,r5              ;1494
000b54  4d35              LDR      r5,|L1.3116|
000b56  742c              STRB     r4,[r5,#0x10]         ;1494
                  |L1.2904|
000b58  bf00              NOP      
000b5a  e7e3              B        |L1.2852|
;;;1497   
                          ENDP

                  UART_FullModemConfigMode PROC
;;;1510    **********************************************************************/
;;;1511   void UART_FullModemConfigMode(UART_ID_Type UartID, UART_MODEM_MODE_Type Mode,
000b5c  b530              PUSH     {r4,r5,lr}
;;;1512                                               FunctionalState NewState)
;;;1513   {
000b5e  4603              MOV      r3,r0
;;;1514       uint8_t tmp;
;;;1515   
;;;1516       if(UartID != UART_1)
000b60  2b01              CMP      r3,#1
000b62  d000              BEQ      |L1.2918|
                  |L1.2916|
;;;1517           return;
;;;1518       
;;;1519       switch(Mode)
;;;1520       {
;;;1521           case UART1_MODEM_MODE_LOOPBACK:
;;;1522               tmp = UART1_MCR_LOOPB_EN;
;;;1523               break;
;;;1524   
;;;1525           case UART1_MODEM_MODE_AUTO_RTS:
;;;1526               tmp = UART1_MCR_AUTO_RTS_EN;
;;;1527               break;
;;;1528   
;;;1529           case UART1_MODEM_MODE_AUTO_CTS:
;;;1530               tmp = UART1_MCR_AUTO_CTS_EN;
;;;1531               break;
;;;1532   
;;;1533           default:
;;;1534               break;
;;;1535       }
;;;1536   
;;;1537       if (NewState == ENABLE)
;;;1538       {
;;;1539           LPC_UART1->MCR |= tmp;
;;;1540       }
;;;1541       else
;;;1542       {
;;;1543           LPC_UART1->MCR &= (~tmp) & UART1_MCR_BITMASK;
;;;1544       }
;;;1545   }
000b64  bd30              POP      {r4,r5,pc}
                  |L1.2918|
000b66  b121              CBZ      r1,|L1.2930|
000b68  2901              CMP      r1,#1                 ;1519
000b6a  d004              BEQ      |L1.2934|
000b6c  2902              CMP      r1,#2                 ;1519
000b6e  d106              BNE      |L1.2942|
000b70  e003              B        |L1.2938|
                  |L1.2930|
000b72  2010              MOVS     r0,#0x10              ;1522
000b74  e004              B        |L1.2944|
                  |L1.2934|
000b76  2040              MOVS     r0,#0x40              ;1526
000b78  e002              B        |L1.2944|
                  |L1.2938|
000b7a  2080              MOVS     r0,#0x80              ;1530
000b7c  e000              B        |L1.2944|
                  |L1.2942|
000b7e  bf00              NOP                            ;1534
                  |L1.2944|
000b80  bf00              NOP                            ;1523
000b82  2a01              CMP      r2,#1                 ;1537
000b84  d105              BNE      |L1.2962|
000b86  4c29              LDR      r4,|L1.3116|
000b88  7c24              LDRB     r4,[r4,#0x10]         ;1539
000b8a  4304              ORRS     r4,r4,r0              ;1539
000b8c  4d27              LDR      r5,|L1.3116|
000b8e  742c              STRB     r4,[r5,#0x10]         ;1539
000b90  e006              B        |L1.2976|
                  |L1.2962|
000b92  4c26              LDR      r4,|L1.3116|
000b94  7c24              LDRB     r4,[r4,#0x10]         ;1543
000b96  25f3              MOVS     r5,#0xf3              ;1543
000b98  4385              BICS     r5,r5,r0              ;1543
000b9a  402c              ANDS     r4,r4,r5              ;1543
000b9c  4d23              LDR      r5,|L1.3116|
000b9e  742c              STRB     r4,[r5,#0x10]         ;1543
                  |L1.2976|
000ba0  bf00              NOP      
000ba2  e7df              B        |L1.2916|
;;;1546   
                          ENDP

                  UART_FullModemGetStatus PROC
;;;1559    **********************************************************************/
;;;1560   uint8_t UART_FullModemGetStatus(UART_ID_Type UartID)
000ba4  4601              MOV      r1,r0
;;;1561   {
;;;1562       if(UartID != UART_1)
000ba6  2901              CMP      r1,#1
000ba8  d001              BEQ      |L1.2990|
;;;1563           return  0;
000baa  2000              MOVS     r0,#0
                  |L1.2988|
;;;1564       
;;;1565       return ((LPC_UART1->MSR) & UART1_MSR_BITMASK);
;;;1566   }
000bac  4770              BX       lr
                  |L1.2990|
000bae  481f              LDR      r0,|L1.3116|
000bb0  7e00              LDRB     r0,[r0,#0x18]         ;1565
000bb2  e7fb              B        |L1.2988|
;;;1567   
                          ENDP

                  UART_RS485Config PROC
;;;1578    **********************************************************************/
;;;1579   void UART_RS485Config(UART_ID_Type UartID, UART1_RS485_CTRLCFG_Type *RS485ConfigStruct)
000bb4  e92d5ff0          PUSH     {r4-r12,lr}
;;;1580   {
000bb8  4607              MOV      r7,r0
000bba  460c              MOV      r4,r1
;;;1581       uint32_t tmp;
;;;1582       __IO uint32_t *RS485DLY, *ADRMATCH, *RS485CTRL, *LCR;
;;;1583   
;;;1584       tmp = 0;
000bbc  2500              MOVS     r5,#0
;;;1585       if (UartID == UART_1)
000bbe  2f01              CMP      r7,#1
000bc0  d10a              BNE      |L1.3032|
;;;1586       {
;;;1587           RS485DLY = (__IO uint32_t *)&LPC_UART1->RS485DLY;
000bc2  f8df8068          LDR      r8,|L1.3116|
000bc6  f1080854          ADD      r8,r8,#0x54
;;;1588           ADRMATCH = (__IO uint32_t *)&LPC_UART1->ADRMATCH;
000bca  f1a80904          SUB      r9,r8,#4
;;;1589           LCR = (__IO uint32_t *)&LPC_UART1->LCR;
000bce  4e17              LDR      r6,|L1.3116|
000bd0  360c              ADDS     r6,r6,#0xc
;;;1590           RS485CTRL =  (__IO uint32_t *)&LPC_UART1->RS485CTRL;
000bd2  f1a90a04          SUB      r10,r9,#4
000bd6  e019              B        |L1.3084|
                  |L1.3032|
;;;1591       }
;;;1592       else if (UartID == UART_4)
000bd8  2f04              CMP      r7,#4
000bda  d10a              BNE      |L1.3058|
;;;1593       {
;;;1594           RS485DLY = (__IO uint32_t *)&LPC_UART4->RS485DLY;
000bdc  f8df8058          LDR      r8,|L1.3128|
000be0  f1080854          ADD      r8,r8,#0x54
;;;1595           ADRMATCH = (__IO uint32_t *)&LPC_UART4->ADRMATCH;
000be4  f1a80904          SUB      r9,r8,#4
;;;1596           LCR = (__IO uint32_t *)&LPC_UART4->LCR;
000be8  4e13              LDR      r6,|L1.3128|
000bea  360c              ADDS     r6,r6,#0xc
;;;1597           RS485CTRL =  (__IO uint32_t *)&LPC_UART4->RS485CTRL;
000bec  f1a90a04          SUB      r10,r9,#4
000bf0  e00c              B        |L1.3084|
                  |L1.3058|
;;;1598       }
;;;1599       else
;;;1600       {
;;;1601           LPC_UART_TypeDef *UARTx = uart_get_pointer(UartID);
000bf2  4638              MOV      r0,r7
000bf4  f7fffffe          BL       uart_get_pointer
000bf8  4683              MOV      r11,r0
;;;1602           RS485DLY = (__IO uint32_t *)&UARTx->RS485DLY;
000bfa  f10b0854          ADD      r8,r11,#0x54
;;;1603           ADRMATCH = (__IO uint32_t *)&UARTx->ADRMATCH;
000bfe  f10b0950          ADD      r9,r11,#0x50
;;;1604           LCR = (__IO uint32_t *)&UARTx->LCR;
000c02  f10b060c          ADD      r6,r11,#0xc
;;;1605            RS485CTRL =  (__IO uint32_t *)&UARTx->RS485CTRL;
000c06  f10b0a4c          ADD      r10,r11,#0x4c
;;;1606       }
000c0a  bf00              NOP      
                  |L1.3084|
;;;1607       // If Auto Direction Control is enabled -  This function is used in Master mode
;;;1608       if (RS485ConfigStruct->AutoDirCtrl_State == ENABLE)
000c0c  78e0              LDRB     r0,[r4,#3]
000c0e  2801              CMP      r0,#1
000c10  d11b              BNE      |L1.3146|
;;;1609       {
;;;1610           tmp |= UART_RS485CTRL_DCTRL_EN;
000c12  f0450510          ORR      r5,r5,#0x10
;;;1611   
;;;1612           // Set polar
;;;1613           if (RS485ConfigStruct->DirCtrlPol_Level == SET)
000c16  7960              LDRB     r0,[r4,#5]
000c18  2801              CMP      r0,#1
000c1a  d101              BNE      |L1.3104|
;;;1614           {
;;;1615               tmp |= UART_RS485CTRL_OINV_1;
000c1c  f0450520          ORR      r5,r5,#0x20
                  |L1.3104|
;;;1616           }
;;;1617   
;;;1618           // Set pin according to. This condition is only with UART1. The others are used
;;;1619           // OE pin as default for control the direction of RS485 buffer IC
;;;1620           if ((RS485ConfigStruct->DirCtrlPin == UART_RS485_DIRCTRL_DTR) &&
000c20  7920              LDRB     r0,[r4,#4]
000c22  2801              CMP      r0,#1
000c24  d10e              BNE      |L1.3140|
;;;1621                (UartID == UART_1))
000c26  e009              B        |L1.3132|
                  |L1.3112|
                          DCD      0x4000c000
                  |L1.3116|
                          DCD      0x40010000
                  |L1.3120|
                          DCD      0x40098000
                  |L1.3124|
                          DCD      0x4009c000
                  |L1.3128|
                          DCD      0x400a4000
                  |L1.3132|
000c3c  2f01              CMP      r7,#1
000c3e  d101              BNE      |L1.3140|
;;;1622           {
;;;1623               tmp |= UART_RS485CTRL_SEL_DTR;
000c40  f0450508          ORR      r5,r5,#8
                  |L1.3140|
;;;1624           }
;;;1625   
;;;1626           // Fill delay time
;;;1627           *RS485DLY = RS485ConfigStruct->DelayValue & UART_RS485DLY_BITMASK;
000c44  79e0              LDRB     r0,[r4,#7]
000c46  f8c80000          STR      r0,[r8,#0]
                  |L1.3146|
;;;1628       }
;;;1629        
;;;1630       // MultiDrop mode is enable
;;;1631       if (RS485ConfigStruct->NormalMultiDropMode_State == ENABLE)
000c4a  7820              LDRB     r0,[r4,#0]
000c4c  2801              CMP      r0,#1
000c4e  d101              BNE      |L1.3156|
;;;1632       {
;;;1633           tmp |= UART_RS485CTRL_NMM_EN;
000c50  f0450501          ORR      r5,r5,#1
                  |L1.3156|
;;;1634       }
;;;1635   
;;;1636       // Auto Address Detect function
;;;1637       if (RS485ConfigStruct->AutoAddrDetect_State == ENABLE)
000c54  78a0              LDRB     r0,[r4,#2]
000c56  2801              CMP      r0,#1
000c58  d104              BNE      |L1.3172|
;;;1638       {
;;;1639           tmp |= UART_RS485CTRL_AADEN;
000c5a  f0450504          ORR      r5,r5,#4
;;;1640   
;;;1641           // Fill Match Address
;;;1642           *ADRMATCH = RS485ConfigStruct->MatchAddrValue & UART_RS485ADRMATCH_BITMASK;
000c5e  79a0              LDRB     r0,[r4,#6]
000c60  f8c90000          STR      r0,[r9,#0]
                  |L1.3172|
;;;1643       }
;;;1644   
;;;1645       // Receiver is disable
;;;1646       if (RS485ConfigStruct->Rx_State == DISABLE)
000c64  7860              LDRB     r0,[r4,#1]
000c66  b908              CBNZ     r0,|L1.3180|
;;;1647       {
;;;1648           tmp |= UART_RS485CTRL_RX_DIS;
000c68  f0450502          ORR      r5,r5,#2
                  |L1.3180|
;;;1649       }
;;;1650        
;;;1651       // write back to RS485 control register
;;;1652       *RS485CTRL = tmp & UART_RS485CTRL_BITMASK;
000c6c  f005003f          AND      r0,r5,#0x3f
000c70  f8ca0000          STR      r0,[r10,#0]
;;;1653   
;;;1654       // Enable Parity function and leave parity in stick '0' parity as default
;;;1655       *LCR |= (UART_LCR_PARITY_F_0 | UART_LCR_PARITY_EN);
000c74  6830              LDR      r0,[r6,#0]
000c76  f0400038          ORR      r0,r0,#0x38
000c7a  6030              STR      r0,[r6,#0]
;;;1656   }
000c7c  e8bd9ff0          POP      {r4-r12,pc}
;;;1657   
                          ENDP

                  UART_RS485ReceiverCmd PROC
;;;1665    **********************************************************************/
;;;1666   void UART_RS485ReceiverCmd(UART_ID_Type UartID, FunctionalState NewState)
000c80  e92d41f0          PUSH     {r4-r8,lr}
;;;1667   {
000c84  4605              MOV      r5,r0
000c86  460e              MOV      r6,r1
;;;1668       __IO uint32_t *RS485CTRL;
;;;1669       if (UartID == UART_1)
000c88  2d01              CMP      r5,#1
000c8a  d101              BNE      |L1.3216|
;;;1670       {
;;;1671           RS485CTRL = (__IO uint32_t *)&LPC_UART1->RS485DLY;
000c8c  4c3a              LDR      r4,|L1.3448|
000c8e  e00a              B        |L1.3238|
                  |L1.3216|
;;;1672       }
;;;1673       else if (UartID == UART_4)
000c90  2d04              CMP      r5,#4
000c92  d101              BNE      |L1.3224|
;;;1674       {
;;;1675           RS485CTRL = (__IO uint32_t *)&LPC_UART4->RS485DLY;
000c94  4c39              LDR      r4,|L1.3452|
000c96  e006              B        |L1.3238|
                  |L1.3224|
;;;1676       }
;;;1677       else
;;;1678       {
;;;1679           LPC_UART_TypeDef *UARTx = uart_get_pointer(UartID);
000c98  4628              MOV      r0,r5
000c9a  f7fffffe          BL       uart_get_pointer
000c9e  4607              MOV      r7,r0
;;;1680           RS485CTRL = (__IO uint32_t *)&UARTx->RS485DLY;
000ca0  f1070454          ADD      r4,r7,#0x54
;;;1681       }
000ca4  bf00              NOP      
                  |L1.3238|
;;;1682       if (NewState == ENABLE)
000ca6  2e01              CMP      r6,#1
000ca8  d104              BNE      |L1.3252|
;;;1683       {
;;;1684           *RS485CTRL &= ~UART_RS485CTRL_RX_DIS;
000caa  6820              LDR      r0,[r4,#0]
000cac  f0200002          BIC      r0,r0,#2
000cb0  6020              STR      r0,[r4,#0]
000cb2  e003              B        |L1.3260|
                  |L1.3252|
;;;1685       }
;;;1686       else
;;;1687       {
;;;1688           *RS485CTRL |= UART_RS485CTRL_RX_DIS;
000cb4  6820              LDR      r0,[r4,#0]
000cb6  f0400002          ORR      r0,r0,#2
000cba  6020              STR      r0,[r4,#0]
                  |L1.3260|
;;;1689       }
;;;1690   }
000cbc  e8bd81f0          POP      {r4-r8,pc}
;;;1691   
                          ENDP

                  UART_RS485Send PROC
;;;1699    **********************************************************************/
;;;1700   uint32_t UART_RS485Send(UART_ID_Type UartID, uint8_t *pDatFrm,
000cc0  e92d4fff          PUSH     {r0-r11,lr}
;;;1701                                               uint32_t size, uint8_t ParityStick)
;;;1702   {
000cc4  b081              SUB      sp,sp,#4
000cc6  4606              MOV      r6,r0
000cc8  468b              MOV      r11,r1
000cca  4698              MOV      r8,r3
;;;1703       uint8_t tmp, save;
;;;1704       uint32_t cnt;
;;;1705       __IO uint32_t *LCR, *LSR;
;;;1706       if (UartID == UART_1)
000ccc  2e01              CMP      r6,#1
000cce  d104              BNE      |L1.3290|
;;;1707       {
;;;1708           LCR = (__IO uint32_t *)&LPC_UART1->LCR;
000cd0  4c29              LDR      r4,|L1.3448|
000cd2  3c48              SUBS     r4,r4,#0x48
;;;1709           LSR = (__IO uint32_t *)&LPC_UART1->LSR;
000cd4  4d28              LDR      r5,|L1.3448|
000cd6  3d40              SUBS     r5,r5,#0x40
000cd8  e00f              B        |L1.3322|
                  |L1.3290|
;;;1710       }
;;;1711       else if (UartID == UART_4)
000cda  2e04              CMP      r6,#4
000cdc  d104              BNE      |L1.3304|
;;;1712       {
;;;1713           LCR = (__IO uint32_t *)&LPC_UART4->LCR;
000cde  4c27              LDR      r4,|L1.3452|
000ce0  3c48              SUBS     r4,r4,#0x48
;;;1714           LSR = (__IO uint32_t *)&LPC_UART4->LSR;
000ce2  4d26              LDR      r5,|L1.3452|
000ce4  3d40              SUBS     r5,r5,#0x40
000ce6  e008              B        |L1.3322|
                  |L1.3304|
;;;1715       }
;;;1716       else
;;;1717       {
;;;1718           LPC_UART_TypeDef *UARTx = uart_get_pointer(UartID);
000ce8  4630              MOV      r0,r6
000cea  f7fffffe          BL       uart_get_pointer
000cee  4682              MOV      r10,r0
;;;1719           LCR = (__IO uint32_t *)&UARTx->LCR;
000cf0  f10a040c          ADD      r4,r10,#0xc
;;;1720           LSR = (__IO uint32_t *)&UARTx->LSR;
000cf4  f10a0514          ADD      r5,r10,#0x14
;;;1721       }
000cf8  bf00              NOP      
                  |L1.3322|
;;;1722   
;;;1723       if (ParityStick)
000cfa  f1b80f00          CMP      r8,#0
000cfe  d015              BEQ      |L1.3372|
;;;1724       {
;;;1725           save = tmp = *LCR & UART_LCR_BITMASK;
000d00  6820              LDR      r0,[r4,#0]
000d02  b2c7              UXTB     r7,r0
000d04  46b9              MOV      r9,r7
;;;1726   
;;;1727           tmp &= ~(UART_LCR_PARITY_EVEN);
000d06  f0290910          BIC      r9,r9,#0x10
;;;1728   
;;;1729           *LCR = tmp;
000d0a  f8c49000          STR      r9,[r4,#0]
;;;1730   
;;;1731           cnt = UART_Send(UartID, pDatFrm, size, BLOCKING);
000d0e  2301              MOVS     r3,#1
000d10  4659              MOV      r1,r11
000d12  4630              MOV      r0,r6
000d14  9a03              LDR      r2,[sp,#0xc]
000d16  f7fffffe          BL       UART_Send
000d1a  9000              STR      r0,[sp,#0]
;;;1732   
;;;1733           while (!(*LSR & UART_LSR_TEMT));
000d1c  bf00              NOP      
                  |L1.3358|
000d1e  6828              LDR      r0,[r5,#0]
000d20  f0000040          AND      r0,r0,#0x40
000d24  2800              CMP      r0,#0
000d26  d0fa              BEQ      |L1.3358|
;;;1734   
;;;1735           *LCR = save;
000d28  6027              STR      r7,[r4,#0]
000d2a  e00c              B        |L1.3398|
                  |L1.3372|
;;;1736       }
;;;1737       else
;;;1738       {
;;;1739           cnt = UART_Send(UartID, pDatFrm, size, BLOCKING);
000d2c  2301              MOVS     r3,#1
000d2e  4659              MOV      r1,r11
000d30  4630              MOV      r0,r6
000d32  9a03              LDR      r2,[sp,#0xc]
000d34  f7fffffe          BL       UART_Send
000d38  9000              STR      r0,[sp,#0]
;;;1740   
;;;1741           while (!(*LSR & UART_LSR_TEMT));
000d3a  bf00              NOP      
                  |L1.3388|
000d3c  6828              LDR      r0,[r5,#0]
000d3e  f0000040          AND      r0,r0,#0x40
000d42  2800              CMP      r0,#0
000d44  d0fa              BEQ      |L1.3388|
                  |L1.3398|
;;;1742       }
;;;1743   
;;;1744       return cnt;
000d46  9800              LDR      r0,[sp,#0]
;;;1745   }
000d48  b005              ADD      sp,sp,#0x14
000d4a  e8bd8ff0          POP      {r4-r11,pc}
;;;1746   
                          ENDP

                  UART_RS485SendSlvAddr PROC
;;;1752    **********************************************************************/
;;;1753   void UART_RS485SendSlvAddr(UART_ID_Type UartID, uint8_t SlvAddr)
000d4e  b513              PUSH     {r0,r1,r4,lr}
;;;1754   {
000d50  4604              MOV      r4,r0
;;;1755       UART_RS485Send(UartID, &SlvAddr, 1, 1);
000d52  2301              MOVS     r3,#1
000d54  461a              MOV      r2,r3
000d56  a901              ADD      r1,sp,#4
000d58  4620              MOV      r0,r4
000d5a  f7fffffe          BL       UART_RS485Send
;;;1756   }
000d5e  bd1c              POP      {r2-r4,pc}
;;;1757   
                          ENDP

                  UART_RS485SendData PROC
;;;1764    **********************************************************************/
;;;1765   uint32_t UART_RS485SendData(UART_ID_Type UartID, uint8_t *pData, uint32_t size)
000d60  b570              PUSH     {r4-r6,lr}
;;;1766   {
000d62  4604              MOV      r4,r0
000d64  460d              MOV      r5,r1
000d66  4616              MOV      r6,r2
;;;1767       return (UART_RS485Send(UartID, pData, size, 0));
000d68  2300              MOVS     r3,#0
000d6a  4632              MOV      r2,r6
000d6c  4629              MOV      r1,r5
000d6e  4620              MOV      r0,r4
000d70  f7fffffe          BL       UART_RS485Send
;;;1768   }
000d74  bd70              POP      {r4-r6,pc}
;;;1769   
                          ENDP

000d76  0000              DCW      0x0000
                  |L1.3448|
                          DCD      0x40010054
                  |L1.3452|
                          DCD      0x400a4054

;*** Start embedded assembler ***

#line 1 "Drivers\\source\\lpc_uart.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___10_lpc_uart_c_e5efacd7____REV16|
#line 115 ".\\Core\\CMSIS\\Include\\core_cmInstr.h"
|__asm___10_lpc_uart_c_e5efacd7____REV16| PROC
#line 116

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___10_lpc_uart_c_e5efacd7____REVSH|
#line 129
|__asm___10_lpc_uart_c_e5efacd7____REVSH| PROC
#line 130

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
