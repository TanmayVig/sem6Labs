; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\bootloader.o --asm_dir=.\obj\ --list_dir=.\obj\ --depend=.\obj\bootloader.d --cpu=Cortex-M4.fp --apcs=interwork -O0 -I.\Core\CMSIS\Include -I.\Core\Device\NXP\LPC407x_8x_177x_8x\Include -I.\Drivers\include -I..\..\Core -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\NXP\LPC407x_8x_177x_8x -D__MICROLIB -D__RAM_MODE__ -DUSE_SPIFI_LIB -DCORE_M4 --omf_browse=.\obj\bootloader.crf ..\..\Core\bootloader.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  Bootloader_Init PROC
;;;62     // returns 1 for success, 0 for error
;;;63     int Bootloader_Init
000000  b510              PUSH     {r4,lr}
;;;64       (
;;;65       uint32_t clock                                           // CPU clock frequency in MHz
;;;66       )
;;;67     {
000002  4604              MOV      r4,r0
;;;68       // init host
;;;69       Host_Initialize(Descriptor.baudrate);
000004  49c1              LDR      r1,|L1.780|
000006  6ac8              LDR      r0,[r1,#0x2c]  ; Descriptor
000008  f7fffffe          BL       Host_Initialize
;;;70     
;;;71       // init command state machine
;;;72       state = STATE_HEADER;
00000c  2000              MOVS     r0,#0
00000e  49c0              LDR      r1,|L1.784|
000010  6008              STR      r0,[r1,#0]  ; state
;;;73       headerbytes = 0;
000012  49c0              LDR      r1,|L1.788|
000014  6008              STR      r0,[r1,#0]  ; headerbytes
;;;74     
;;;75       if (Memory_Init(Descriptor.startaddress, clock))
000016  49bd              LDR      r1,|L1.780|
000018  6908              LDR      r0,[r1,#0x10]  ; Descriptor
00001a  4621              MOV      r1,r4
00001c  f7fffffe          BL       Memory_Init
000020  b128              CBZ      r0,|L1.46|
;;;76       {
;;;77         // failed to init
;;;78         Host_SendData("INITERR\r\n", 9);
000022  2109              MOVS     r1,#9
000024  a0bc              ADR      r0,|L1.792|
000026  f7fffffe          BL       Host_SendData
;;;79         return 0;
00002a  2000              MOVS     r0,#0
                  |L1.44|
;;;80       }
;;;81     
;;;82       // send boot message
;;;83       Host_SendData("ESAFLASHOS\r\n", 12);
;;;84     
;;;85       return 1;
;;;86     }
00002c  bd10              POP      {r4,pc}
                  |L1.46|
00002e  210c              MOVS     r1,#0xc               ;83
000030  a0bc              ADR      r0,|L1.804|
000032  f7fffffe          BL       Host_SendData
000036  2001              MOVS     r0,#1                 ;85
000038  e7f8              B        |L1.44|
;;;87     
                          ENDP

                  IsTimeExpired PROC
;;;285    // note that the maximum time measurable is 0x8000 (about 32 seconds)
;;;286    static uint8_t IsTimeExpired(uint16_t timestamp)
00003a  4601              MOV      r1,r0
;;;287    {
;;;288      uint16_t time_now;
;;;289    
;;;290      time_now = gBootloaderTick;
00003c  48bd              LDR      r0,|L1.820|
00003e  8802              LDRH     r2,[r0,#0]  ; gBootloaderTick
;;;291      if (time_now >= timestamp)
000040  428a              CMP      r2,r1
000042  db07              BLT      |L1.84|
;;;292      {
;;;293        if ((time_now - timestamp) < 0x8000)
000044  1a50              SUBS     r0,r2,r1
000046  f5b04f00          CMP      r0,#0x8000
00004a  da01              BGE      |L1.80|
;;;294          return 1;
00004c  2001              MOVS     r0,#1
                  |L1.78|
;;;295        else
;;;296          return 0;
;;;297      }
;;;298      else
;;;299      {
;;;300        if ((timestamp - time_now) >= 0x8000)
;;;301          return 1;
;;;302        else
;;;303          return 0;
;;;304      }
;;;305    }
00004e  4770              BX       lr
                  |L1.80|
000050  2000              MOVS     r0,#0                 ;296
000052  e7fc              B        |L1.78|
                  |L1.84|
000054  1a88              SUBS     r0,r1,r2              ;300
000056  f5b04f00          CMP      r0,#0x8000            ;300
00005a  db01              BLT      |L1.96|
00005c  2001              MOVS     r0,#1                 ;301
00005e  e7f6              B        |L1.78|
                  |L1.96|
000060  2000              MOVS     r0,#0                 ;303
000062  e7f4              B        |L1.78|
                          ENDP

                  VerifyChecksum PROC
;;;252    // returns 1 if matches, 0 if does not match
;;;253    static int VerifyChecksum(uint32_t startaddress, uint32_t endaddress, uint32_t checksum)
000064  e92d41f0          PUSH     {r4-r8,lr}
;;;254    {
000068  4606              MOV      r6,r0
00006a  460f              MOV      r7,r1
00006c  4690              MOV      r8,r2
;;;255      uint32_t address;
;;;256      uint32_t chk = 0x00000000;
00006e  2500              MOVS     r5,#0
;;;257    
;;;258      // calculate checksum
;;;259      for (address = startaddress; address <= endaddress; address++)
000070  4634              MOV      r4,r6
000072  e004              B        |L1.126|
                  |L1.116|
;;;260      {
;;;261        chk += Memory_ReadByte(address); 
000074  4620              MOV      r0,r4
000076  f7fffffe          BL       Memory_ReadByte
00007a  4405              ADD      r5,r5,r0
00007c  1c64              ADDS     r4,r4,#1              ;259
                  |L1.126|
00007e  42bc              CMP      r4,r7                 ;259
000080  d9f8              BLS      |L1.116|
;;;262      }
;;;263    
;;;264      // 2's complement
;;;265      chk = 0xFFFFFFFF - chk + 1;
000082  426d              RSBS     r5,r5,#0
;;;266    
;;;267      // compare
;;;268      if (chk != checksum) return 0;
000084  4545              CMP      r5,r8
000086  d002              BEQ      |L1.142|
000088  2000              MOVS     r0,#0
                  |L1.138|
;;;269    
;;;270      return 1;
;;;271    }
00008a  e8bd81f0          POP      {r4-r8,pc}
                  |L1.142|
00008e  2001              MOVS     r0,#1                 ;270
000090  e7fb              B        |L1.138|
;;;272    
                          ENDP

                  GetTime PROC
;;;275    // returns the current timer count
;;;276    static uint16_t GetTime(void)
000092  48a8              LDR      r0,|L1.820|
;;;277    {
;;;278      return gBootloaderTick;
000094  8800              LDRH     r0,[r0,#0]  ; gBootloaderTick
;;;279    }
000096  4770              BX       lr
;;;280    
                          ENDP

                  Bootloader_Process PROC
;;;89     // call continually in a background loop or an RTOS task
;;;90     void Bootloader_Process(void)
000098  b5f0              PUSH     {r4-r7,lr}
;;;91     {
00009a  b0c1              SUB      sp,sp,#0x104
;;;92       uint32_t length, b;
;;;93       uint32_t sectoraddr;
;;;94     
;;;95       // fixme - remove
;;;96       int HLen;
;;;97       uint8_t HBuffer[256];
;;;98       HLen = Host_ReceiveData(HBuffer, 256);
00009c  f44f7180          MOV      r1,#0x100
0000a0  a801              ADD      r0,sp,#4
0000a2  f7fffffe          BL       Host_ReceiveData
0000a6  4607              MOV      r7,r0
;;;99       if (HLen > 0)
0000a8  2f00              CMP      r7,#0
0000aa  dd03              BLE      |L1.180|
;;;100      {
;;;101        Host_SendData(HBuffer, HLen);
0000ac  4639              MOV      r1,r7
0000ae  a801              ADD      r0,sp,#4
0000b0  f7fffffe          BL       Host_SendData
                  |L1.180|
;;;102      }
;;;103      
;;;104      length = Host_ReceiveData(rxbuffer, RXBUFFERSIZE);     
0000b4  2164              MOVS     r1,#0x64
0000b6  48a0              LDR      r0,|L1.824|
0000b8  f7fffffe          BL       Host_ReceiveData
0000bc  4605              MOV      r5,r0
;;;105      if (length)
0000be  2d00              CMP      r5,#0
0000c0  d072              BEQ      |L1.424|
;;;106      {
;;;107        // remember when data was received
;;;108        lastbytetimestamp = GetTime();
0000c2  f7fffffe          BL       GetTime
0000c6  499d              LDR      r1,|L1.828|
0000c8  8008              STRH     r0,[r1,#0]
;;;109    
;;;110        for (b = 0; b < length; b++)
0000ca  2400              MOVS     r4,#0
0000cc  e10a              B        |L1.740|
                  |L1.206|
;;;111        {
;;;112          switch (state)
0000ce  4890              LDR      r0,|L1.784|
0000d0  6800              LDR      r0,[r0,#0]  ; state
0000d2  b110              CBZ      r0,|L1.218|
0000d4  2801              CMP      r0,#1
0000d6  d10b              BNE      |L1.240|
0000d8  e097              B        |L1.522|
                  |L1.218|
;;;113          {
;;;114            case STATE_HEADER:
;;;115              // autobaud character - tell the client that we are executing
;;;116              if ((rxbuffer[b] == '?') && !headerbytes)
0000da  4897              LDR      r0,|L1.824|
0000dc  5d00              LDRB     r0,[r0,r4]
0000de  283f              CMP      r0,#0x3f
0000e0  d107              BNE      |L1.242|
0000e2  488c              LDR      r0,|L1.788|
0000e4  6800              LDR      r0,[r0,#0]  ; headerbytes
0000e6  b920              CBNZ     r0,|L1.242|
;;;117              {
;;;118                Host_SendData("ESAFLASHOS\r\n", 12);
0000e8  210c              MOVS     r1,#0xc
0000ea  a08e              ADR      r0,|L1.804|
0000ec  f7fffffe          BL       Host_SendData
                  |L1.240|
;;;119                break;
0000f0  e0f6              B        |L1.736|
                  |L1.242|
;;;120              }
;;;121    
;;;122              header[headerbytes++] = rxbuffer[b];
0000f2  4891              LDR      r0,|L1.824|
0000f4  5d01              LDRB     r1,[r0,r4]
0000f6  4887              LDR      r0,|L1.788|
0000f8  6802              LDR      r2,[r0,#0]  ; headerbytes
0000fa  6800              LDR      r0,[r0,#0]  ; headerbytes
0000fc  1c40              ADDS     r0,r0,#1
0000fe  4b85              LDR      r3,|L1.788|
000100  6018              STR      r0,[r3,#0]  ; headerbytes
000102  488f              LDR      r0,|L1.832|
000104  5481              STRB     r1,[r0,r2]
;;;123              // if received complete header then parse it...
;;;124              if (headerbytes == 16)
000106  4618              MOV      r0,r3
000108  6800              LDR      r0,[r0,#0]  ; headerbytes
00010a  2810              CMP      r0,#0x10
00010c  d17c              BNE      |L1.520|
;;;125              {
;;;126                // first byte is the command
;;;127                switch (header[0])
00010e  488c              LDR      r0,|L1.832|
000110  7800              LDRB     r0,[r0,#0]  ; header
000112  b120              CBZ      r0,|L1.286|
000114  2801              CMP      r0,#1
000116  d03f              BEQ      |L1.408|
000118  2802              CMP      r0,#2
00011a  d170              BNE      |L1.510|
00011c  e04d              B        |L1.442|
                  |L1.286|
;;;128                {
;;;129                  case COMMAND_PROGRAM:
;;;130                    // get size of data that is going to be sent
;;;131                    datasize = ((uint32_t)header[2] << 8) | header[1];
00011e  4888              LDR      r0,|L1.832|
000120  7840              LDRB     r0,[r0,#1]  ; header
000122  4987              LDR      r1,|L1.832|
000124  7889              LDRB     r1,[r1,#2]  ; header
000126  ea402001          ORR      r0,r0,r1,LSL #8
00012a  4986              LDR      r1,|L1.836|
00012c  6008              STR      r0,[r1,#0]  ; datasize
;;;132                    datasize *= Descriptor.programsize;
00012e  4877              LDR      r0,|L1.780|
000130  6a80              LDR      r0,[r0,#0x28]  ; Descriptor
000132  6809              LDR      r1,[r1,#0]  ; datasize
000134  4348              MULS     r0,r1,r0
000136  4983              LDR      r1,|L1.836|
000138  6008              STR      r0,[r1,#0]  ; datasize
;;;133                
;;;134                    // get checksum
;;;135                    remotechecksum = ((uint32_t)header[6] << 24) | ((uint32_t)header[5] << 16) | ((uint32_t)header[4] << 8) | header[3];
00013a  4881              LDR      r0,|L1.832|
00013c  7980              LDRB     r0,[r0,#6]  ; header
00013e  0600              LSLS     r0,r0,#24
000140  497f              LDR      r1,|L1.832|
000142  7949              LDRB     r1,[r1,#5]  ; header
000144  ea404001          ORR      r0,r0,r1,LSL #16
000148  497d              LDR      r1,|L1.832|
00014a  7909              LDRB     r1,[r1,#4]  ; header
00014c  ea402001          ORR      r0,r0,r1,LSL #8
000150  497b              LDR      r1,|L1.832|
000152  78c9              LDRB     r1,[r1,#3]  ; header
000154  4308              ORRS     r0,r0,r1
000156  497c              LDR      r1,|L1.840|
000158  6008              STR      r0,[r1,#0]  ; remotechecksum
;;;136                
;;;137                    // get programming start address
;;;138                    programstartaddr = ((uint32_t)header[10] << 24) | ((uint32_t)header[9] << 16) | ((uint32_t)header[8] << 8) | header[7];
00015a  4879              LDR      r0,|L1.832|
00015c  7a80              LDRB     r0,[r0,#0xa]  ; header
00015e  0600              LSLS     r0,r0,#24
000160  4977              LDR      r1,|L1.832|
000162  7a49              LDRB     r1,[r1,#9]  ; header
000164  ea404001          ORR      r0,r0,r1,LSL #16
000168  4975              LDR      r1,|L1.832|
00016a  7a09              LDRB     r1,[r1,#8]  ; header
00016c  ea402001          ORR      r0,r0,r1,LSL #8
000170  4973              LDR      r1,|L1.832|
000172  79c9              LDRB     r1,[r1,#7]  ; header
000174  4308              ORRS     r0,r0,r1
000176  4975              LDR      r1,|L1.844|
000178  6008              STR      r0,[r1,#0]  ; programstartaddr
;;;139    
;;;140                    // now get data 
;;;141                    state = STATE_DATA;
00017a  2001              MOVS     r0,#1
00017c  4964              LDR      r1,|L1.784|
00017e  6008              STR      r0,[r1,#0]  ; state
;;;142                    databytes = 0;
000180  2000              MOVS     r0,#0
000182  4973              LDR      r1,|L1.848|
000184  6008              STR      r0,[r1,#0]  ; databytes
;;;143                    chunkbytes = 0;
000186  4973              LDR      r1,|L1.852|
000188  6008              STR      r0,[r1,#0]  ; chunkbytes
;;;144                    localchecksum = 0;
00018a  4973              LDR      r1,|L1.856|
00018c  6008              STR      r0,[r1,#0]  ; localchecksum
;;;145                    chunkaddress = programstartaddr;
00018e  486f              LDR      r0,|L1.844|
000190  6800              LDR      r0,[r0,#0]  ; programstartaddr
000192  4972              LDR      r1,|L1.860|
000194  6008              STR      r0,[r1,#0]  ; chunkaddress
;;;146                    break;
000196  e036              B        |L1.518|
                  |L1.408|
;;;147    
;;;148                  case COMMAND_ERASEALL:
;;;149                    // erase the flash memory
;;;150                    if (Memory_EraseChip())
000198  f7fffffe          BL       Memory_EraseChip
00019c  b128              CBZ      r0,|L1.426|
;;;151                    {
;;;152                      Host_SendData("ERROR\r\n", 7);
00019e  2107              MOVS     r1,#7
0001a0  a06f              ADR      r0,|L1.864|
0001a2  f7fffffe          BL       Host_SendData
0001a6  e004              B        |L1.434|
                  |L1.424|
0001a8  e0a0              B        |L1.748|
                  |L1.426|
;;;153                    }
;;;154                    else
;;;155                    {
;;;156                      Host_SendData("OK\r\n", 4);
0001aa  2104              MOVS     r1,#4
0001ac  a06e              ADR      r0,|L1.872|
0001ae  f7fffffe          BL       Host_SendData
                  |L1.434|
;;;157                    }
;;;158    
;;;159                    // wait for next header
;;;160                    headerbytes = 0;
0001b2  2000              MOVS     r0,#0
0001b4  4957              LDR      r1,|L1.788|
0001b6  6008              STR      r0,[r1,#0]  ; headerbytes
;;;161                    break;
0001b8  e025              B        |L1.518|
                  |L1.442|
;;;162    
;;;163                  case COMMAND_ERASESECTOR:
;;;164                    // get sector address
;;;165                    sectoraddr = ((uint32_t)header[4] << 24) | ((uint32_t)header[3] << 16) | ((uint32_t)header[2] << 8) | header[1];
0001ba  4861              LDR      r0,|L1.832|
0001bc  7900              LDRB     r0,[r0,#4]  ; header
0001be  0600              LSLS     r0,r0,#24
0001c0  495f              LDR      r1,|L1.832|
0001c2  78c9              LDRB     r1,[r1,#3]  ; header
0001c4  ea404001          ORR      r0,r0,r1,LSL #16
0001c8  495d              LDR      r1,|L1.832|
0001ca  7889              LDRB     r1,[r1,#2]  ; header
0001cc  ea402001          ORR      r0,r0,r1,LSL #8
0001d0  495b              LDR      r1,|L1.832|
0001d2  7849              LDRB     r1,[r1,#1]  ; header
0001d4  ea400601          ORR      r6,r0,r1
;;;166                    // erase sector
;;;167                    if (Memory_EraseSector(sectoraddr))
0001d8  4630              MOV      r0,r6
0001da  f7fffffe          BL       Memory_EraseSector
0001de  b120              CBZ      r0,|L1.490|
;;;168                    {
;;;169                      Host_SendData("ERROR\r\n", 7);
0001e0  2107              MOVS     r1,#7
0001e2  a05f              ADR      r0,|L1.864|
0001e4  f7fffffe          BL       Host_SendData
0001e8  e003              B        |L1.498|
                  |L1.490|
;;;170                    }
;;;171                    else
;;;172                    {
;;;173                      Host_SendData("OK\r\n", 4);
0001ea  2104              MOVS     r1,#4
0001ec  a05e              ADR      r0,|L1.872|
0001ee  f7fffffe          BL       Host_SendData
                  |L1.498|
;;;174                    }
;;;175    
;;;176                    // wait for next header
;;;177                    headerbytes = 0;
0001f2  2000              MOVS     r0,#0
0001f4  4947              LDR      r1,|L1.788|
0001f6  6008              STR      r0,[r1,#0]  ; headerbytes
;;;178                    break;
0001f8  e005              B        |L1.518|
0001fa  e005              B        |L1.520|
0001fc  e7ff              B        |L1.510|
                  |L1.510|
;;;179                    
;;;180                  // unknown command
;;;181                  default:
;;;182                    // wait for next header
;;;183                    headerbytes = 0;
0001fe  2000              MOVS     r0,#0
000200  4944              LDR      r1,|L1.788|
000202  6008              STR      r0,[r1,#0]  ; headerbytes
;;;184                    break;
000204  bf00              NOP      
                  |L1.518|
000206  bf00              NOP                            ;146
                  |L1.520|
;;;185                }
;;;186              }
;;;187              break;
000208  e06a              B        |L1.736|
                  |L1.522|
;;;188    
;;;189            case STATE_DATA:
;;;190              // update checksum calculation
;;;191              localchecksum += rxbuffer[b];
00020a  484b              LDR      r0,|L1.824|
00020c  5d00              LDRB     r0,[r0,r4]
00020e  4952              LDR      r1,|L1.856|
000210  6809              LDR      r1,[r1,#0]  ; localchecksum
000212  4408              ADD      r0,r0,r1
000214  4950              LDR      r1,|L1.856|
000216  6008              STR      r0,[r1,#0]  ; localchecksum
;;;192    
;;;193              chunk[chunkbytes++] = rxbuffer[b];
000218  4847              LDR      r0,|L1.824|
00021a  5d01              LDRB     r1,[r0,r4]
00021c  484d              LDR      r0,|L1.852|
00021e  6802              LDR      r2,[r0,#0]  ; chunkbytes
000220  6800              LDR      r0,[r0,#0]  ; chunkbytes
000222  1c40              ADDS     r0,r0,#1
000224  4b4b              LDR      r3,|L1.852|
000226  6018              STR      r0,[r3,#0]  ; chunkbytes
000228  4851              LDR      r0,|L1.880|
00022a  5481              STRB     r1,[r0,r2]
;;;194              if (chunkbytes == Descriptor.programsize)
00022c  4837              LDR      r0,|L1.780|
00022e  6a80              LDR      r0,[r0,#0x28]  ; Descriptor
000230  4619              MOV      r1,r3
000232  6809              LDR      r1,[r1,#0]  ; chunkbytes
000234  4288              CMP      r0,r1
000236  d11f              BNE      |L1.632|
;;;195              {
;;;196                // program page
;;;197                if (!Memory_ProgramPage(chunkaddress, chunkbytes, chunk))
000238  4a4d              LDR      r2,|L1.880|
00023a  4618              MOV      r0,r3
00023c  6801              LDR      r1,[r0,#0]  ; chunkbytes
00023e  4847              LDR      r0,|L1.860|
000240  6800              LDR      r0,[r0,#0]  ; chunkaddress
000242  f7fffffe          BL       Memory_ProgramPage
000246  b970              CBNZ     r0,|L1.614|
;;;198                {
;;;199                  Host_SendData("PROGOK\r\n", 8);
000248  2108              MOVS     r1,#8
00024a  a04a              ADR      r0,|L1.884|
00024c  f7fffffe          BL       Host_SendData
;;;200                  chunkaddress += chunkbytes;
000250  4842              LDR      r0,|L1.860|
000252  6800              LDR      r0,[r0,#0]  ; chunkaddress
000254  493f              LDR      r1,|L1.852|
000256  6809              LDR      r1,[r1,#0]  ; chunkbytes
000258  4408              ADD      r0,r0,r1
00025a  4940              LDR      r1,|L1.860|
00025c  6008              STR      r0,[r1,#0]  ; chunkaddress
;;;201                  chunkbytes = 0;
00025e  2000              MOVS     r0,#0
000260  493c              LDR      r1,|L1.852|
000262  6008              STR      r0,[r1,#0]  ; chunkbytes
000264  e008              B        |L1.632|
                  |L1.614|
;;;202                }
;;;203                else
;;;204                {
;;;205                  Host_SendData("PROGERR\r\n", 9);
000266  2109              MOVS     r1,#9
000268  a045              ADR      r0,|L1.896|
00026a  f7fffffe          BL       Host_SendData
;;;206                  // wait for next header
;;;207                  state = STATE_HEADER;
00026e  2000              MOVS     r0,#0
000270  4927              LDR      r1,|L1.784|
000272  6008              STR      r0,[r1,#0]  ; state
;;;208                  headerbytes = 0;
000274  4927              LDR      r1,|L1.788|
000276  6008              STR      r0,[r1,#0]  ; headerbytes
                  |L1.632|
;;;209                }
;;;210              }
;;;211    
;;;212              databytes++;
000278  4835              LDR      r0,|L1.848|
00027a  6800              LDR      r0,[r0,#0]  ; databytes
00027c  1c40              ADDS     r0,r0,#1
00027e  4934              LDR      r1,|L1.848|
000280  6008              STR      r0,[r1,#0]  ; databytes
;;;213              if (databytes == datasize)
000282  4608              MOV      r0,r1
000284  6800              LDR      r0,[r0,#0]  ; databytes
000286  492f              LDR      r1,|L1.836|
000288  6809              LDR      r1,[r1,#0]  ; datasize
00028a  4288              CMP      r0,r1
00028c  d127              BNE      |L1.734|
;;;214              {
;;;215                // end of data transfer
;;;216                // check checksum
;;;217                localchecksum = 0xFFFFFFFF - localchecksum + 1;
00028e  4832              LDR      r0,|L1.856|
000290  6800              LDR      r0,[r0,#0]  ; localchecksum
000292  4240              RSBS     r0,r0,#0
000294  4930              LDR      r1,|L1.856|
000296  6008              STR      r0,[r1,#0]  ; localchecksum
;;;218                if (localchecksum != remotechecksum)
000298  4608              MOV      r0,r1
00029a  6800              LDR      r0,[r0,#0]  ; localchecksum
00029c  492a              LDR      r1,|L1.840|
00029e  6809              LDR      r1,[r1,#0]  ; remotechecksum
0002a0  4288              CMP      r0,r1
0002a2  d004              BEQ      |L1.686|
;;;219                {
;;;220                  Host_SendData("CHECKSUM\r\n", 10);
0002a4  210a              MOVS     r1,#0xa
0002a6  a039              ADR      r0,|L1.908|
0002a8  f7fffffe          BL       Host_SendData
0002ac  e012              B        |L1.724|
                  |L1.686|
;;;221                }
;;;222                // verify flash
;;;223                else if (!VerifyChecksum(programstartaddr, chunkaddress - 1, localchecksum))
0002ae  482b              LDR      r0,|L1.860|
0002b0  6800              LDR      r0,[r0,#0]  ; chunkaddress
0002b2  1e41              SUBS     r1,r0,#1
0002b4  4828              LDR      r0,|L1.856|
0002b6  6802              LDR      r2,[r0,#0]  ; localchecksum
0002b8  4824              LDR      r0,|L1.844|
0002ba  6800              LDR      r0,[r0,#0]  ; programstartaddr
0002bc  f7fffffe          BL       VerifyChecksum
0002c0  b920              CBNZ     r0,|L1.716|
;;;224                {
;;;225                  Host_SendData("VERIFY\r\n", 8);
0002c2  2108              MOVS     r1,#8
0002c4  a034              ADR      r0,|L1.920|
0002c6  f7fffffe          BL       Host_SendData
0002ca  e003              B        |L1.724|
                  |L1.716|
;;;226                }
;;;227                else
;;;228                {
;;;229                  Host_SendData("OK\r\n", 4);
0002cc  2104              MOVS     r1,#4
0002ce  a026              ADR      r0,|L1.872|
0002d0  f7fffffe          BL       Host_SendData
                  |L1.724|
;;;230                }
;;;231                // wait for next header
;;;232                state = STATE_HEADER;
0002d4  2000              MOVS     r0,#0
0002d6  490e              LDR      r1,|L1.784|
0002d8  6008              STR      r0,[r1,#0]  ; state
;;;233                headerbytes = 0;
0002da  490e              LDR      r1,|L1.788|
0002dc  6008              STR      r0,[r1,#0]  ; headerbytes
                  |L1.734|
;;;234              }
;;;235              break;
0002de  bf00              NOP      
                  |L1.736|
0002e0  bf00              NOP                            ;119
0002e2  1c64              ADDS     r4,r4,#1              ;110
                  |L1.740|
0002e4  42ac              CMP      r4,r5                 ;110
0002e6  f4ffaef2          BCC      |L1.206|
0002ea  e00c              B        |L1.774|
                  |L1.748|
;;;236          }
;;;237        }
;;;238      }
;;;239      else
;;;240      {
;;;241        // haven't received data in a while so reset state machine
;;;242        if (IsTimeExpired(lastbytetimestamp + RECEIVETIMEOUT))
0002ec  4913              LDR      r1,|L1.828|
0002ee  8809              LDRH     r1,[r1,#0]  ; lastbytetimestamp
0002f0  f501717a          ADD      r1,r1,#0x3e8
0002f4  b288              UXTH     r0,r1
0002f6  f7fffffe          BL       IsTimeExpired
0002fa  b120              CBZ      r0,|L1.774|
;;;243        {
;;;244          // wait for next header
;;;245          state = STATE_HEADER;
0002fc  2000              MOVS     r0,#0
0002fe  4904              LDR      r1,|L1.784|
000300  6008              STR      r0,[r1,#0]  ; state
;;;246          headerbytes = 0;
000302  4904              LDR      r1,|L1.788|
000304  6008              STR      r0,[r1,#0]  ; headerbytes
                  |L1.774|
;;;247        }
;;;248      }
;;;249    }
000306  b041              ADD      sp,sp,#0x104
000308  bdf0              POP      {r4-r7,pc}
;;;250    
                          ENDP

00030a  0000              DCW      0x0000
                  |L1.780|
                          DCD      Descriptor
                  |L1.784|
                          DCD      state
                  |L1.788|
                          DCD      headerbytes
                  |L1.792|
000318  494e4954          DCB      "INITERR\r\n",0
00031c  4552520d
000320  0a00    
000322  00                DCB      0
000323  00                DCB      0
                  |L1.804|
000324  45534146          DCB      "ESAFLASHOS\r\n",0
000328  4c415348
00032c  4f530d0a
000330  00      
000331  00                DCB      0
000332  00                DCB      0
000333  00                DCB      0
                  |L1.820|
                          DCD      gBootloaderTick
                  |L1.824|
                          DCD      rxbuffer
                  |L1.828|
                          DCD      lastbytetimestamp
                  |L1.832|
                          DCD      header
                  |L1.836|
                          DCD      datasize
                  |L1.840|
                          DCD      remotechecksum
                  |L1.844|
                          DCD      programstartaddr
                  |L1.848|
                          DCD      databytes
                  |L1.852|
                          DCD      chunkbytes
                  |L1.856|
                          DCD      localchecksum
                  |L1.860|
                          DCD      chunkaddress
                  |L1.864|
000360  4552524f          DCB      "ERROR\r\n",0
000364  520d0a00
                  |L1.872|
000368  4f4b0d0a          DCB      "OK\r\n",0
00036c  00      
00036d  00                DCB      0
00036e  00                DCB      0
00036f  00                DCB      0
                  |L1.880|
                          DCD      chunk
                  |L1.884|
000374  50524f47          DCB      "PROGOK\r\n",0
000378  4f4b0d0a
00037c  00      
00037d  00                DCB      0
00037e  00                DCB      0
00037f  00                DCB      0
                  |L1.896|
000380  50524f47          DCB      "PROGERR\r\n",0
000384  4552520d
000388  0a00    
00038a  00                DCB      0
00038b  00                DCB      0
                  |L1.908|
00038c  43484543          DCB      "CHECKSUM\r\n",0
000390  4b53554d
000394  0d0a00  
000397  00                DCB      0
                  |L1.920|
000398  56455249          DCB      "VERIFY\r\n",0
00039c  46590d0a
0003a0  00      
0003a1  00                DCB      0
0003a2  00                DCB      0
0003a3  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  rxbuffer
                          %        100
                  chunk
                          %        1024
                  header
                          %        16

                          AREA ||.data||, DATA, ALIGN=2

                  gBootloaderTick
000000  0000              DCW      0x0000
000002  0000              DCB      0x00,0x00
                  state
                          DCD      0x00000000
                  headerbytes
                          DCD      0x00000000
                  lastbytetimestamp
00000c  0000              DCW      0x0000
00000e  0000              DCB      0x00,0x00
                  databytes
                          DCD      0x00000000
                  chunkbytes
                          DCD      0x00000000
                  chunkaddress
                          DCD      0x00000000
                  localchecksum
                          DCD      0x00000000
                  programstartaddr
                          DCD      0x00000000
                  datasize
                          DCD      0x00000000
                  remotechecksum
                          DCD      0x00000000
