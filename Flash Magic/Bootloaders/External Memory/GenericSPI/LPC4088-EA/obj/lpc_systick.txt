; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\lpc_systick.o --asm_dir=.\obj\ --list_dir=.\obj\ --depend=.\obj\lpc_systick.d --cpu=Cortex-M4.fp --apcs=interwork -O0 -I.\Core\CMSIS\Include -I.\Core\Device\NXP\LPC407x_8x_177x_8x\Include -I.\Drivers\include -I..\..\Core -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\NXP\LPC407x_8x_177x_8x -D__MICROLIB -D__RAM_MODE__ -DUSE_SPIFI_LIB -DCORE_M4 --omf_browse=.\obj\lpc_systick.crf Drivers\source\lpc_systick.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=1

                  SYSTICK_InternalInit PROC
;;;60      **********************************************************************/
;;;61     void SYSTICK_InternalInit(uint32_t time)
000000  b570              PUSH     {r4-r6,lr}
;;;62     {
000002  ed2d8b02          VPUSH    {d8}
000006  4604              MOV      r4,r0
;;;63         uint32_t cclk;
;;;64         float maxtime;
;;;65     
;;;66         cclk = CLKPWR_GetCLK(CLKPWR_CLKTYPE_CPU);
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       CLKPWR_GetCLK
00000e  4605              MOV      r5,r0
;;;67     
;;;68         /* With internal CPU clock frequency for LPC178X is 'SystemCoreClock'
;;;69          * And limit 24 bit for RELOAD value
;;;70          * So the maximum time can be set:
;;;71          * 1/SystemCoreClock * (2^24) * 1000 (ms)
;;;72          */
;;;73         //check time value is available or not
;;;74         maxtime = (1<<24)/(cclk / 1000) ;
000010  f44f707a          MOV      r0,#0x3e8
000014  fbb5f0f0          UDIV     r0,r5,r0
000018  f04f7180          MOV      r1,#0x1000000
00001c  fbb1f0f0          UDIV     r0,r1,r0
000020  ee000a10          VMOV     s0,r0
000024  eeb80a40          VCVT.F32.U32 s0,s0
000028  eeb08a40          VMOV.F32 s16,s0
;;;75     
;;;76         if(time > maxtime)
00002c  ee004a10          VMOV     s0,r4
000030  eeb80a40          VCVT.F32.U32 s0,s0
000034  eeb40ac8          VCMPE.F32 s0,s16
000038  eef1fa10          VMRS     APSR_nzcv,FPSCR
00003c  dd01              BLE      |L1.66|
;;;77         {
;;;78             //Error loop
;;;79             while(1);
00003e  bf00              NOP      
                  |L1.64|
000040  e7fe              B        |L1.64|
                  |L1.66|
;;;80         }
;;;81         else
;;;82         {
;;;83             //Select CPU clock is System Tick clock source
;;;84             SysTick->CTRL |= ST_CTRL_CLKSOURCE;
000042  f04f20e0          MOV      r0,#0xe000e000
000046  6900              LDR      r0,[r0,#0x10]
000048  f0400004          ORR      r0,r0,#4
00004c  f04f21e0          MOV      r1,#0xe000e000
000050  6108              STR      r0,[r1,#0x10]
;;;85     
;;;86             /* Set RELOAD value
;;;87              * RELOAD = (SystemCoreClock/1000) * time - 1
;;;88              * with time base is millisecond
;;;89              */
;;;90             SysTick->LOAD = (cclk/1000)*time - 1;
000052  f44f707a          MOV      r0,#0x3e8
000056  fbb5f0f0          UDIV     r0,r5,r0
00005a  4360              MULS     r0,r4,r0
00005c  1e40              SUBS     r0,r0,#1
00005e  6148              STR      r0,[r1,#0x14]
;;;91         }
;;;92     }
000060  ecbd8b02          VPOP     {d8}
000064  bd70              POP      {r4-r6,pc}
;;;93     
                          ENDP

                  SYSTICK_ExternalInit PROC
;;;99      **********************************************************************/
;;;100    void SYSTICK_ExternalInit(uint32_t freq, uint32_t time)
000066  f44f727a          MOV      r2,#0x3e8
;;;101    {
;;;102        float maxtime;
;;;103    
;;;104        /* With external clock frequency for LPC178X is 'freq'
;;;105         * And limit 24 bit for RELOAD value
;;;106         * So the maximum time can be set:
;;;107         * 1/freq * (2^24) * 1000 (ms)
;;;108         */
;;;109        //check time value is available or not
;;;110        maxtime = (1<<24)/(freq / 1000) ;
00006a  fbb0f2f2          UDIV     r2,r0,r2
00006e  f04f7380          MOV      r3,#0x1000000
000072  fbb3f2f2          UDIV     r2,r3,r2
000076  ee002a90          VMOV     s1,r2
00007a  eef80a60          VCVT.F32.U32 s1,s1
00007e  eeb00a60          VMOV.F32 s0,s1
;;;111        if (time>maxtime)
000082  ee001a90          VMOV     s1,r1
000086  eef80a60          VCVT.F32.U32 s1,s1
00008a  eef40ac0          VCMPE.F32 s1,s0
00008e  eef1fa10          VMRS     APSR_nzcv,FPSCR
000092  dd01              BLE      |L1.152|
;;;112        {
;;;113            //Error Loop
;;;114            while(1);
000094  bf00              NOP      
                  |L1.150|
000096  e7fe              B        |L1.150|
                  |L1.152|
;;;115        }
;;;116        else
;;;117        {
;;;118            //Select external clock is System Tick clock source
;;;119            SysTick->CTRL &= ~ ST_CTRL_CLKSOURCE;
000098  f04f22e0          MOV      r2,#0xe000e000
00009c  6912              LDR      r2,[r2,#0x10]
00009e  f0220204          BIC      r2,r2,#4
0000a2  f04f23e0          MOV      r3,#0xe000e000
0000a6  611a              STR      r2,[r3,#0x10]
;;;120    
;;;121            /* Set RELOAD value
;;;122             * RELOAD = (freq/1000) * time - 1
;;;123             * with time base is millisecond
;;;124             */
;;;125            maxtime = (freq/1000)*time - 1;
0000a8  f44f727a          MOV      r2,#0x3e8
0000ac  fbb0f2f2          UDIV     r2,r0,r2
0000b0  434a              MULS     r2,r1,r2
0000b2  1e52              SUBS     r2,r2,#1
0000b4  ee002a90          VMOV     s1,r2
0000b8  eef80a60          VCVT.F32.U32 s1,s1
0000bc  eeb00a60          VMOV.F32 s0,s1
;;;126            SysTick->LOAD = (freq/1000)*time - 1;
0000c0  f44f727a          MOV      r2,#0x3e8
0000c4  fbb0f2f2          UDIV     r2,r0,r2
0000c8  434a              MULS     r2,r1,r2
0000ca  1e52              SUBS     r2,r2,#1
0000cc  615a              STR      r2,[r3,#0x14]
;;;127        }
;;;128    }
0000ce  4770              BX       lr
;;;129    
                          ENDP

                  SYSTICK_Cmd PROC
;;;136     **********************************************************************/
;;;137    void SYSTICK_Cmd(FunctionalState NewState)
0000d0  2801              CMP      r0,#1
;;;138    {
;;;139        if(NewState == ENABLE)
0000d2  d108              BNE      |L1.230|
;;;140            //Enable System Tick counter
;;;141            SysTick->CTRL |= ST_CTRL_ENABLE;
0000d4  f04f21e0          MOV      r1,#0xe000e000
0000d8  6909              LDR      r1,[r1,#0x10]
0000da  f0410101          ORR      r1,r1,#1
0000de  f04f22e0          MOV      r2,#0xe000e000
0000e2  6111              STR      r1,[r2,#0x10]
0000e4  e007              B        |L1.246|
                  |L1.230|
;;;142        else
;;;143            //Disable System Tick counter
;;;144            SysTick->CTRL &= ~ST_CTRL_ENABLE;
0000e6  f04f21e0          MOV      r1,#0xe000e000
0000ea  6909              LDR      r1,[r1,#0x10]
0000ec  f0210101          BIC      r1,r1,#1
0000f0  f04f22e0          MOV      r2,#0xe000e000
0000f4  6111              STR      r1,[r2,#0x10]
                  |L1.246|
;;;145    }
0000f6  4770              BX       lr
;;;146    
                          ENDP

                  SYSTICK_IntCmd PROC
;;;153     **********************************************************************/
;;;154    void SYSTICK_IntCmd(FunctionalState NewState)
0000f8  2801              CMP      r0,#1
;;;155    {
;;;156        if(NewState == ENABLE)
0000fa  d108              BNE      |L1.270|
;;;157            //Enable System Tick counter
;;;158            SysTick->CTRL |= ST_CTRL_TICKINT;
0000fc  f04f21e0          MOV      r1,#0xe000e000
000100  6909              LDR      r1,[r1,#0x10]
000102  f0410102          ORR      r1,r1,#2
000106  f04f22e0          MOV      r2,#0xe000e000
00010a  6111              STR      r1,[r2,#0x10]
00010c  e007              B        |L1.286|
                  |L1.270|
;;;159        else
;;;160            //Disable System Tick counter
;;;161            SysTick->CTRL &= ~ST_CTRL_TICKINT;
00010e  f04f21e0          MOV      r1,#0xe000e000
000112  6909              LDR      r1,[r1,#0x10]
000114  f0210102          BIC      r1,r1,#2
000118  f04f22e0          MOV      r2,#0xe000e000
00011c  6111              STR      r1,[r2,#0x10]
                  |L1.286|
;;;162    }
00011e  4770              BX       lr
;;;163    
                          ENDP

                  SYSTICK_GetCurrentValue PROC
;;;168     **********************************************************************/
;;;169    uint32_t SYSTICK_GetCurrentValue(void)
000120  f04f20e0          MOV      r0,#0xe000e000
;;;170    {
;;;171        return (SysTick->VAL);
000124  6980              LDR      r0,[r0,#0x18]
;;;172    }
000126  4770              BX       lr
;;;173    
                          ENDP

                  SYSTICK_ClearCounterFlag PROC
;;;178     **********************************************************************/
;;;179    void SYSTICK_ClearCounterFlag(void)
000128  f04f20e0          MOV      r0,#0xe000e000
;;;180    {
;;;181        SysTick->CTRL &= ~ST_CTRL_COUNTFLAG;
00012c  6900              LDR      r0,[r0,#0x10]
00012e  f4203080          BIC      r0,r0,#0x10000
000132  f04f21e0          MOV      r1,#0xe000e000
000136  6108              STR      r0,[r1,#0x10]
;;;182    }
000138  4770              BX       lr
;;;183    /**
                          ENDP


;*** Start embedded assembler ***

#line 1 "Drivers\\source\\lpc_systick.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___13_lpc_systick_c_11aed849____REV16|
#line 115 ".\\Core\\CMSIS\\Include\\core_cmInstr.h"
|__asm___13_lpc_systick_c_11aed849____REV16| PROC
#line 116

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___13_lpc_systick_c_11aed849____REVSH|
#line 129
|__asm___13_lpc_systick_c_11aed849____REVSH| PROC
#line 130

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
