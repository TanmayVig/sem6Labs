L 1 "Drivers\source\lpc_pinsel.c"
N/**********************************************************************
N* $Id: lpc_pinsel.c 3001 2013-01-23 21:47:55Z andy $      lpc_pinsel.c            2011-06-02
N*//**
N* @file     lpc_pinsel.c
N* @brief    Contains all functions support for Pin-connection block
N*           firmware library on LPC
N* @version  1.0
N* @date     02. June. 2011
N* @author   NXP MCU SW Application Team
N* 
N* Copyright(C) 2011, NXP Semiconductor
N* All rights reserved.
N*
N***********************************************************************
N* Software that is described herein is for illustrative purposes only
N* which provides customers with programming information regarding the
N* products. This software is supplied "AS IS" without any warranties.
N* NXP Semiconductors assumes no responsibility or liability for the
N* use of the software, conveys no license or title under any patent,
N* copyright, or mask work right to the product. NXP Semiconductors
N* reserves the right to make changes in the software without
N* notification. NXP Semiconductors also make no representation or
N* warranty that such application will be suitable for the specified
N* use without further testing or modification.
N* Permission to use, copy, modify, and distribute this software and its
N* documentation is hereby granted, under NXP Semiconductors'
N* relevant copyright in the software, without fee, provided that it
N* is used in conjunction with NXP Semiconductors microcontrollers.  This
N* copyright, permission, and disclaimer notice must appear in all copies of
N* this code.
N**********************************************************************/
N
N/* Peripheral group ----------------------------------------------------------- */
N/** @addtogroup PINSEL
N * @{
N */
N#ifdef __BUILD_WITH_EXAMPLE__
S#include "lpc_libcfg.h"
N#else
N#include "lpc_libcfg_default.h"
L 1 ".\Drivers\include\lpc_libcfg_default.h" 1
N/**********************************************************************
N* $Id: lpc_libcfg_default.h 3001 2013-01-23 21:47:55Z andy $      lpc_libcfg.h            2010-05-21
N***
N* @file     lpc_libcfg.h
N* @brief    Library configuration file
N* @version  3.0
N* @date     20. June. 2010
N* @author   NXP MCU SW Application Team
N*
N* Copyright(C) 2010, NXP Semiconductor
N* All rights reserved.
N*
N***********************************************************************
N* Software that is described herein is for illustrative purposes only
N* which provides customers with programming information regarding the
N* products. This software is supplied "AS IS" without any warranties.
N* NXP Semiconductors assumes no responsibility or liability for the
N* use of the software, conveys no license or title under any patent,
N* copyright, or mask work right to the product. NXP Semiconductors
N* reserves the right to make changes in the software without
N* notification. NXP Semiconductors also make no representation or
N* warranty that such application will be suitable for the specified
N* use without further testing or modification.
N* Permission to use, copy, modify, and distribute this software and its
N* documentation is hereby granted, under NXP Semiconductors'
N* relevant copyright in the software, without fee, provided that it
N* is used in conjunction with NXP Semiconductors microcontrollers.  This
N* copyright, permission, and disclaimer notice must appear in all copies of
N* this code.
N**********************************************************************/
N
N#ifndef _LPC_LIBCFG_DEFAULT_H_
N#define _LPC_LIBCFG_DEFAULT_H_
N
N#include "lpc_types.h"
L 1 ".\Drivers\include\lpc_types.h" 1
N/**********************************************************************
N* $Id: lpc_types.h 3001 2013-01-23 21:47:55Z andy $      lpc_types.h         2011-06-02
N*//**
N* @file     lpc_types.h
N* @brief    Contains the NXP ABL typedefs for C standard types.
N*           It is intended to be used in ISO C conforming development
N*           environments and checks for this insofar as it is possible
N*           to do so.
N* @version  1.0
N* @date     02. June. 2011
N* @author   NXP MCU SW Application Team
N* 
N* Copyright(C) 2011, NXP Semiconductor
N* All rights reserved.
N*
N***********************************************************************
N* Software that is described herein is for illustrative purposes only
N* which provides customers with programming information regarding the
N* products. This software is supplied "AS IS" without any warranties.
N* NXP Semiconductors assumes no responsibility or liability for the
N* use of the software, conveys no license or title under any patent,
N* copyright, or mask work right to the product. NXP Semiconductors
N* reserves the right to make changes in the software without
N* notification. NXP Semiconductors also make no representation or
N* warranty that such application will be suitable for the specified
N* use without further testing or modification.
N* Permission to use, copy, modify, and distribute this software and its
N* documentation is hereby granted, under NXP Semiconductors'
N* relevant copyright in the software, without fee, provided that it
N* is used in conjunction with NXP Semiconductors microcontrollers.  This
N* copyright, permission, and disclaimer notice must appear in all copies of
N* this code.
N**********************************************************************/
N
N/* Type group ----------------------------------------------------------- */
N#ifndef __LPC_TYPES_H
N#define __LPC_TYPES_H
N
N/* Includes ------------------------------------------------------------------- */
N#include <stdint.h>
L 1 "C:\Keil\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision: 185525 $
N * Checkin $Date: 2014-05-29 12:44:48 +0100 (Thu, 29 May 2014) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5050041
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX INT64_MAX
N#else
N#define UINTPTR_MAX INT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 41 ".\Drivers\include\lpc_types.h" 2
N
N/** @defgroup LPC_Type_Def Data Types Definitions
N * @ingroup LPC_CMSIS_FwLib_Drivers
N * @{
N */
N 
N/* Public Types --------------------------------------------------------------- */
N/** @defgroup LPC_Types_Public_Types Basic Public Data Types
N * @{
N */
N
N/**
N * @brief Boolean Type definition
N */
Ntypedef enum {FALSE = 0, TRUE = !FALSE} Bool;
N
N/**
N * @brief Flag Status and Interrupt Flag Status type definition
N */
Ntypedef enum {RESET = 0, SET = !RESET} FlagStatus, IntStatus, SetState;
N#define PARAM_SETSTATE(State) ((State==RESET) || (State==SET))
N
N/**
N * @brief Functional State Definition
N */
Ntypedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;
N#define PARAM_FUNCTIONALSTATE(State) ((State==DISABLE) || (State==ENABLE))
N
N/**
N * @ Status type definition
N */
Ntypedef enum {ERROR = 0, SUCCESS = !ERROR} Status;
N
N
N/**
N * Read/Write transfer type mode (Block or non-block)
N */
Ntypedef enum
N{
N    NONE_BLOCKING = 0,      /**< None Blocking type */
N    BLOCKING,               /**< Blocking type */
N} TRANSFER_BLOCK_Type;
N
N
N/** Pointer to Function returning Void (any number of parameters) */
Ntypedef void (*PFV)();
N
N/** Pointer to Function returning int32_t (any number of parameters) */
Ntypedef int32_t(*PFI)();
N
N/**
N * @}
N */
N
N
N/* Public Macros -------------------------------------------------------------- */
N/** @defgroup LPC_Types_Public_Macros  Basic Public Macros
N * @{
N */
N
N/** _BIT(n) sets the bit at position "n"
N * _BIT(n) is intended to be used in "OR" and "AND" expressions:
N * e.g., "(_BIT(3) | _BIT(7))".
N */
N#undef _BIT
N/** Set bit macro */
N#define _BIT(n) (1<<n)
N
N/** _SBF(f,v) sets the bit field starting at position "f" to value "v".
N * _SBF(f,v) is intended to be used in "OR" and "AND" expressions:
N * e.g., "((_SBF(5,7) | _SBF(12,0xF)) & 0xFFFF)"
N */
N#undef _SBF
N/* Set bit field macro */
N#define _SBF(f,v) (v<<f)
N
N/* _BITMASK constructs a symbol with 'field_width' least significant
N * bits set.
N * e.g., _BITMASK(5) constructs '0x1F', _BITMASK(16) == 0xFFFF
N * The symbol is intended to be used to limit the bit field width
N * thusly:
N * <a_register> = (any_expression) & _BITMASK(x), where 0 < x <= 32.
N * If "any_expression" results in a value that is larger than can be
N * contained in 'x' bits, the bits above 'x - 1' are masked off.  When
N * used with the _SBF example above, the example would be written:
N * a_reg = ((_SBF(5,7) | _SBF(12,0xF)) & _BITMASK(16))
N * This ensures that the value written to a_reg is no wider than
N * 16 bits, and makes the code easier to read and understand.
N */
N#undef _BITMASK
N/* Bitmask creation macro */
N#define _BITMASK(field_width) ( _BIT(field_width) - 1)
N
N/* NULL pointer */
N#ifndef NULL
N#define NULL ((void*) 0)
N#endif
N
N/* Number of elements in an array */
N#define NELEMENTS(array)  (sizeof (array) / sizeof (array[0]))
N
N/* Static data/function define */
N#define STATIC static
N/* External data/function define */
N#define EXTERN extern
N
N#if !defined(MAX)
X#if !0L
N#define MAX(a, b) (((a) > (b)) ? (a) : (b))
N#endif
N#if !defined(MIN)
X#if !0L
N#define MIN(a, b) (((a) < (b)) ? (a) : (b))
N#endif
N
N/**
N * @}
N */
N
N
N/* Old Type Definition compatibility ------------------------------------------ */
N/** @addtogroup LPC_Types_Public_Types LPC_Types Public Types
N * @{
N */
N
N/** SMA type for character type */
Ntypedef char CHAR;
N
N/** SMA type for 8 bit unsigned value */
Ntypedef uint8_t UNS_8;
N
N/** SMA type for 8 bit signed value */
Ntypedef int8_t INT_8;
N
N/** SMA type for 16 bit unsigned value */
Ntypedef uint16_t UNS_16;
N
N/** SMA type for 16 bit signed value */
Ntypedef int16_t INT_16;
N
N/** SMA type for 32 bit unsigned value */
Ntypedef uint32_t UNS_32;
N
N/** SMA type for 32 bit signed value */
Ntypedef int32_t INT_32;
N
N/** SMA type for 64 bit signed value */
Ntypedef int64_t INT_64;
N
N/** SMA type for 64 bit unsigned value */
Ntypedef uint64_t UNS_64;
N
N/** 32 bit boolean type */
Ntypedef Bool BOOL_32;
N
N/** 16 bit boolean type */
Ntypedef Bool BOOL_16;
N
N/** 8 bit boolean type */
Ntypedef Bool BOOL_8;
N
N/**
N * @}
N */
N
N
N#endif /* __LPC_TYPES_H */
N
N/**
N * @}
N */
N
N/* --------------------------------- End Of File ------------------------------ */
L 36 ".\Drivers\include\lpc_libcfg_default.h" 2
N
N
N/************************** DEBUG MODE DEFINITIONS *********************************/
N/* Un-comment the line below to compile the library in DEBUG mode, this will expanse
N   the "CHECK_PARAM" macro in the FW library code */
N
N#ifndef __CODE_RED
N#define DEBUG
N#endif
N
N
N/******************* PERIPHERAL FW LIBRARY CONFIGURATION DEFINITIONS ***********************/
N
N/* Comment the line below to disable the specific peripheral inclusion */
N
N/* DEBUG_FRAMWORK -------------------- */
N#define _DBGFWK
N
N/* Clock & Power -------------------- */
N#define _CLKPWR
N
N/* CRC -------------------- */
N#define _CRC
N
N/* GPIO ------------------------------- */
N#define _GPIO
N
N/* NVIC ------------------------------- */
N#define _NVIC
N
N/* PINSEL ------------------------------- */
N#define _PINSEL
N
N/* EXTI ------------------------------- */
N#define _EXTI
N
N/* EMC ------------------------------- */
N#define _EMC
N
N/* UART ------------------------------- */
N#define _UART
N
N/* SPI ------------------------------- */
N#define _SPI
N
N/* SYSTICK --------------------------- */
N#define _SYSTICK
N
N/* SSP ------------------------------- */
N#define _SSP
N
N
N/* I2C ------------------------------- */
N#define _I2C
N
N/* TIMER ------------------------------- */
N#define _TIM
N
N/* WDT ------------------------------- */
N#define _WDT
N
N
N/* GPDMA ------------------------------- */
N#define _GPDMA
N
N
N/* DAC ------------------------------- */
N#define _DAC
N
N/* ADC ------------------------------- */
N#define _ADC
N
N/* EEPROM ------------------------------- */
N#define _EEPROM
N
N/* PWM ------------------------------- */
N#define _PWM
N
N/* RTC ------------------------------- */
N#define _RTC
N
N/* I2S ------------------------------- */
N#define _I2S
N
N/* USB device ------------------------------- */
N#define _USBDEV
N#ifdef _USBDEV
N#define _USB_DEV_AUDIO
N#define _USB_DEV_MASS_STORAGE
N#define _USB_DEV_HID
N#define _USB_DEV_VIRTUAL_COM
N#endif /*_USBDEV*/
N
N/* USB Host ------------------------------- */
N#define _USBHost
N
N/* QEI ------------------------------- */
N#define _QEI
N
N/* MCPWM ------------------------------- */
N#define _MCPWM
N
N/* CAN--------------------------------*/
N#define _CAN
N
N/* EMAC ------------------------------ */
N#define _EMAC
N
N/* LCD ------------------------------ */
N#define _LCD
N
N/* MCI ------------------------------ */
N#define _MCI
N
N/* IAP------------------------------ */
N#define _IAP
N
N/* BOD------------------------------ */
N#define _BOD
N/************************** GLOBAL/PUBLIC MACRO DEFINITIONS *********************************/
N
N
N#endif /* _LPC_LIBCFG_DEFAULT_H_ */
L 41 "Drivers\source\lpc_pinsel.c" 2
N#endif /* __BUILD_WITH_EXAMPLE__ */
N#ifdef _PINSEL
N
N/* Includes ------------------------------------------------------------------- */
N#include "lpc_pinsel.h"
L 1 ".\Drivers\include\lpc_pinsel.h" 1
N/**********************************************************************
N* $Id: lpc_pinsel.h 3001 2013-01-23 21:47:55Z andy $      lpc_pinsel.h            2011-06-02
N*//**
N* @file     lpc_pinsel.h
N* @brief    Contains all macro definitions and function prototypes
N*           support for Pin-connection block firmware library on LPC
N* @version  1.0
N* @date     02. June. 2011
N* @author   NXP MCU SW Application Team
N* 
N* Copyright(C) 2011, NXP Semiconductor
N* All rights reserved.
N*
N***********************************************************************
N* Software that is described herein is for illustrative purposes only
N* which provides customers with programming information regarding the
N* products. This software is supplied "AS IS" without any warranties.
N* NXP Semiconductors assumes no responsibility or liability for the
N* use of the software, conveys no license or title under any patent,
N* copyright, or mask work right to the product. NXP Semiconductors
N* reserves the right to make changes in the software without
N* notification. NXP Semiconductors also make no representation or
N* warranty that such application will be suitable for the specified
N* use without further testing or modification.
N* Permission to use, copy, modify, and distribute this software and its
N* documentation is hereby granted, under NXP Semiconductors'
N* relevant copyright in the software, without fee, provided that it
N* is used in conjunction with NXP Semiconductors microcontrollers.  This
N* copyright, permission, and disclaimer notice must appear in all copies of
N* this code.
N**********************************************************************/
N
N/* Peripheral group ----------------------------------------------------------- */
N/** @defgroup PINSEL    PINSEL (Pin Selection)
N * @ingroup LPC_CMSIS_FwLib_Drivers
N * @{
N */
N
N#ifndef __LPC_PINSEL_H
N#define __LPC_PINSEL_H
N
N/* Includes ------------------------------------------------------------------- */
N#include "LPC407x_8x_177x_8x.h"
L 1 ".\Core\Device\NXP\LPC407x_8x_177x_8x\Include\LPC407x_8x_177x_8x.h" 1
N/****************************************************************************************************//**
N* $Id: LPC407x_8x_177x_8x.h 3001 2013-01-23 21:47:55Z andy $		LPC407x_8x_177x_8x.h			2012-04-25
N*//**
N * @file     LPC407x_8x_177x_8x.h
N *
N * @brief    CMSIS Cortex-M4 Cortex-M3 Peripheral Access Layer Header File for
N *           NXP LPC407x_8x_177x_8x.
N * @version  V0.7
N * @date     20. June 2012
N * @author	NXP MCU SW Application Team
N* 
N* Copyright(C) 2012, NXP Semiconductor
N* All rights reserved.
N*
N***********************************************************************
N* Software that is described herein is for illustrative purposes only
N* which provides customers with programming information regarding the
N* products. This software is supplied "AS IS" without any warranties.
N* NXP Semiconductors assumes no responsibility or liability for the
N* use of the software, conveys no license or title under any patent,
N* copyright, or mask work right to the product. NXP Semiconductors
N* reserves the right to make changes in the software without
N* notification. NXP Semiconductors also make no representation or
N* warranty that such application will be suitable for the specified
N* use without further testing or modification.
N* Permission to use, copy, modify, and distribute this software and its
N* documentation is hereby granted, under NXP Semiconductors'
N* relevant copyright in the software, without fee, provided that it
N* is used in conjunction with NXP Semiconductors microcontrollers.  This
N* copyright, permission, and disclaimer notice must appear in all copies of
N* this code.
N**********************************************************************/
N
N#ifndef __LPC407x_8x_177x_8x_H__
N#define __LPC407x_8x_177x_8x_H__
N
N
N
N/* -------------------------  Interrupt Number Definition  ------------------------ */
N
Ntypedef enum IRQn
N{
N/******  Cortex-M4 Processor Exceptions Numbers ***************************************************/
N  Reset_IRQn                    = -15,              /*!<   1  Reset Vector, invoked on Power up and warm reset                 */
N  NonMaskableInt_IRQn           = -14,      /*!< 2 Non Maskable Interrupt                         */
N  HardFault_IRQn                = -13,              /*!<   3  Hard Fault, all classes of Fault                                 */
N  MemoryManagement_IRQn         = -12,      /*!< 4 Cortex-M3 Memory Management Interrupt          */
N  BusFault_IRQn                 = -11,      /*!< 5 Cortex-M3 Bus Fault Interrupt                  */
N  UsageFault_IRQn               = -10,      /*!< 6 Cortex-M3 Usage Fault Interrupt                */
N  SVCall_IRQn                   = -5,       /*!< 11 Cortex-M3 SV Call Interrupt                   */
N  DebugMonitor_IRQn             = -4,       /*!< 12 Cortex-M3 Debug Monitor Interrupt             */
N  PendSV_IRQn                   = -2,       /*!< 14 Cortex-M3 Pend SV Interrupt                   */
N  SysTick_IRQn                  = -1,       /*!< 15 Cortex-M3 System Tick Interrupt               */
N
N/******  LPC407x_8x_177x_8x Specific Interrupt Numbers *******************************************************/
N  WDT_IRQn                      = 0,        /*!< Watchdog Timer Interrupt                         */
N  TIMER0_IRQn                   = 1,        /*!< Timer0 Interrupt                                 */
N  TIMER1_IRQn                   = 2,        /*!< Timer1 Interrupt                                 */
N  TIMER2_IRQn                   = 3,        /*!< Timer2 Interrupt                                 */
N  TIMER3_IRQn                   = 4,        /*!< Timer3 Interrupt                                 */
N  UART0_IRQn                    = 5,        /*!< UART0 Interrupt                                  */
N  UART1_IRQn                    = 6,        /*!< UART1 Interrupt                                  */
N  UART2_IRQn                    = 7,        /*!< UART2 Interrupt                                  */
N  UART3_IRQn                    = 8,        /*!< UART3 Interrupt                                  */
N  PWM1_IRQn                     = 9,        /*!< PWM1 Interrupt                                   */
N  I2C0_IRQn                     = 10,       /*!< I2C0 Interrupt                                   */
N  I2C1_IRQn                     = 11,       /*!< I2C1 Interrupt                                   */
N  I2C2_IRQn                     = 12,       /*!< I2C2 Interrupt                                   */
N  Reserved0_IRQn                = 13,       /*!< Reserved                                         */
N  SSP0_IRQn                     = 14,       /*!< SSP0 Interrupt                                   */
N  SSP1_IRQn                     = 15,       /*!< SSP1 Interrupt                                   */
N  PLL0_IRQn                     = 16,       /*!< PLL0 Lock (Main PLL) Interrupt                   */
N  RTC_IRQn                      = 17,       /*!< Real Time Clock Interrupt                        */
N  EINT0_IRQn                    = 18,       /*!< External Interrupt 0 Interrupt                   */
N  EINT1_IRQn                    = 19,       /*!< External Interrupt 1 Interrupt                   */
N  EINT2_IRQn                    = 20,       /*!< External Interrupt 2 Interrupt                   */
N  EINT3_IRQn                    = 21,       /*!< External Interrupt 3 Interrupt                   */
N  ADC_IRQn                      = 22,       /*!< A/D Converter Interrupt                          */
N  BOD_IRQn                      = 23,       /*!< Brown-Out Detect Interrupt                       */
N  USB_IRQn                      = 24,       /*!< USB Interrupt                                    */
N  CAN_IRQn                      = 25,       /*!< CAN Interrupt                                    */
N  DMA_IRQn                      = 26,       /*!< General Purpose DMA Interrupt                    */
N  I2S_IRQn                      = 27,       /*!< I2S Interrupt                                    */
N  ENET_IRQn                     = 28,       /*!< Ethernet Interrupt                               */
N  MCI_IRQn                      = 29,       /*!< SD/MMC card I/F Interrupt                        */
N  MCPWM_IRQn                    = 30,       /*!< Motor Control PWM Interrupt                      */
N  QEI_IRQn                      = 31,       /*!< Quadrature Encoder Interface Interrupt           */
N  PLL1_IRQn                     = 32,       /*!< PLL1 Lock (USB PLL) Interrupt                    */
N  USBActivity_IRQn              = 33,       /*!< USB Activity interrupt                           */
N  CANActivity_IRQn              = 34,       /*!< CAN Activity interrupt                           */
N  UART4_IRQn                    = 35,       /*!< UART4 Interrupt                                  */
N  SSP2_IRQn                     = 36,       /*!< SSP2 Interrupt                                   */
N  LCD_IRQn                      = 37,       /*!< LCD Interrupt                                    */
N  GPIO_IRQn                     = 38,       /*!< GPIO Interrupt                                   */
N  PWM0_IRQn                     =  39,              /*!<  39  PWM0                                                             */
N  EEPROM_IRQn                   =  40,              /*!<  40  EEPROM                                                           */
N  CMP0_IRQn                     =  41,              /*!<  41  CMP0                                                             */
N  CMP1_IRQn                     =  42               /*!<  42  CMP1                                                             */
N} IRQn_Type;
N
N/* ================================================================================ */
N/* ================      Processor and Core Peripheral Section     ================ */
N/* ================================================================================ */
N#ifdef CORE_M4
N/* ----------------Configuration of the cm4 Processor and Core Peripherals---------------- */
N#define __CM4_REV                 0x0000            /*!< Cortex-M4 Core Revision                                               */
N#define __MPU_PRESENT                  1            /*!< MPU present or not                                                    */
N#define __NVIC_PRIO_BITS               5            /*!< Number of Bits used for Priority Levels                               */
N#define __Vendor_SysTickConfig         0            /*!< Set to 1 if different SysTick Config is used                          */
N#define __FPU_PRESENT                  1            /*!< FPU present or not                                                    */
N
N
N#include "core_cm4.h"                               /*!< Cortex-M4 processor and core peripherals                              */
L 1 ".\Core\CMSIS\Include\core_cm4.h" 1
N/**************************************************************************//**
N * @file     core_cm4.h
N * @brief    CMSIS Cortex-M4 Core Peripheral Access Layer Header File
N * @version  V2.10
N * @date     19. July 2011
N *
N * @note
N * Copyright (C) 2009-2011 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N#if defined ( __ICCARM__ )
X#if 0L
S #pragma system_include  /* treat file as system include file for MISRA check */
N#endif
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N#ifndef __CORE_CM4_H_GENERIC
N#define __CORE_CM4_H_GENERIC
N
N
N/** \mainpage CMSIS Cortex-M4
N
N  This documentation describes the CMSIS Cortex-M Core Peripheral Access Layer.
N  It consists of:
N
N     - Cortex-M Core Register Definitions
N     - Cortex-M functions
N     - Cortex-M instructions
N     - Cortex-M SIMD instructions
N
N  The CMSIS Cortex-M4 Core Peripheral Access Layer contains C and assembly functions that ease
N  access to the Cortex-M Core
N */
N
N/** \defgroup CMSIS_MISRA_Exceptions  CMSIS MISRA-C:2004 Compliance Exceptions
N  CMSIS violates following MISRA-C2004 Rules:
N  
N   - Violates MISRA 2004 Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'. 
N
N   - Violates MISRA 2004 Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N   
N   - Violates MISRA 2004 Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code. 
N
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/** \defgroup CMSIS_core_definitions CMSIS Core Definitions
N  This file defines all structures and symbols for CMSIS core:
N   - CMSIS version number
N   - Cortex-M core
N   - Cortex-M core Revision Number
N  @{
N */
N
N/*  CMSIS CM4 definitions */
N#define __CM4_CMSIS_VERSION_MAIN  (0x02)                                                       /*!< [31:16] CMSIS HAL main version */
N#define __CM4_CMSIS_VERSION_SUB   (0x10)                                                       /*!< [15:0]  CMSIS HAL sub version  */
N#define __CM4_CMSIS_VERSION       ((__CM4_CMSIS_VERSION_MAIN << 16) | __CM4_CMSIS_VERSION_SUB) /*!< CMSIS HAL version number       */
N
N#define __CORTEX_M                (0x04)                                                       /*!< Cortex core                    */
N
N
N#if   defined ( __CC_ARM )
X#if   1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
N
N#elif defined ( __ICCARM__ )
S  #define __ASM           __asm                                       /*!< asm keyword for IAR Compiler          */
S  #define __INLINE        inline                                      /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S
S#elif defined ( __GNUC__ )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
S
N#endif
N
N/*!< __FPU_USED to be checked prior to making use of FPU specific registers and functions */
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 1L
N    #if (__FPU_PRESENT == 1)
X    #if (1 == 1)
N      #define __FPU_USED       1
N    #else
S      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0
N    #endif
N  #else
S    #define __FPU_USED         0
N  #endif
N
N#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #if (__FPU_PRESENT == 1)
S      #define __FPU_USED       1
S    #else
S      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0
S    #endif
S  #else
S    #define __FPU_USED         0
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #if (__FPU_PRESENT == 1)
S      #define __FPU_USED       1
S    #else
S      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0
S    #endif
S  #else
S    #define __FPU_USED         0
S  #endif
S
S#elif defined ( __TASKING__ )
S    /* add preprocessor checks to define __FPU_USED */
S    #define __FPU_USED         0
N#endif
N
N#include <stdint.h>                      /*!< standard types definitions                      */
N#include <core_cmInstr.h>                /*!< Core Instruction Access                         */
L 1 ".\Core\CMSIS\Include\core_cmInstr.h" 1
N/**************************************************************************//**
N * @file     core_cmInstr.h
N * @brief    CMSIS Cortex-M Core Instruction Access Header File
N * @version  V2.10
N * @date     19. July 2011
N *
N * @note
N * Copyright (C) 2009-2011 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M 
N * processor based microcontrollers.  This file can be freely distributed 
N * within development tools that are supporting such ARM based processors. 
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifndef __CORE_CMINSTR_H
N#define __CORE_CMINSTR_H
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  * @ingroup CMSIS_Core
N  Access to dedicated instructions
N  @{
N*/
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5050041 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N
N/** \brief  No Operation
N
N    No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/** \brief  Wait For Interrupt
N
N    Wait For Interrupt is a hint instruction that suspends execution
N    until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/** \brief  Wait For Event
N
N    Wait For Event is a hint instruction that permits the processor to enter
N    a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/** \brief  Send Event
N
N    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/** \brief  Instruction Synchronization Barrier
N
N    Instruction Synchronization Barrier flushes the pipeline in the processor, 
N    so that all instructions following the ISB are fetched from cache or 
N    memory, after the instruction has been completed.
N */
N#define __ISB()                           __isb(0xF)
N
N
N/** \brief  Data Synchronization Barrier
N
N    This function acts as a special kind of Data Memory Barrier. 
N    It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB()                           __dsb(0xF)
N
N
N/** \brief  Data Memory Barrier
N
N    This function ensures the apparent order of the explicit memory operations before 
N    and after the instruction, without ensuring their completion.
N */
N#define __DMB()                           __dmb(0xF)
N
N
N/** \brief  Reverse byte order (32 bit)
N
N    This function reverses the byte order in integer value.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/** \brief  Reverse byte order (16 bit)
N
N    This function reverses the byte order in two unsigned short values.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
Nstatic __INLINE __ASM uint32_t __REV16(uint32_t value)
Xstatic __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N
N
N/** \brief  Reverse byte order in signed short value
N
N    This function reverses the byte order in a signed short value with sign extension to integer.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
Nstatic __INLINE __ASM int32_t __REVSH(int32_t value)
Xstatic __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N
N
N#if       (__CORTEX_M >= 0x03)
X#if       ((0x04) >= 0x03)
N
N/** \brief  Reverse bit order of value
N
N    This function reverses the bit order of the given value.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#define __RBIT                            __rbit
N
N
N/** \brief  LDR Exclusive (8 bit)
N
N    This function performs a exclusive LDR command for 8 bit value.
N
N    \param [in]    ptr  Pointer to data
N    \return             value of type uint8_t at (*ptr)
N */
N#define __LDREXB(ptr)                     ((uint8_t ) __ldrex(ptr))
N
N
N/** \brief  LDR Exclusive (16 bit)
N
N    This function performs a exclusive LDR command for 16 bit values.
N
N    \param [in]    ptr  Pointer to data
N    \return        value of type uint16_t at (*ptr)
N */
N#define __LDREXH(ptr)                     ((uint16_t) __ldrex(ptr))
N
N
N/** \brief  LDR Exclusive (32 bit)
N
N    This function performs a exclusive LDR command for 32 bit values.
N
N    \param [in]    ptr  Pointer to data
N    \return        value of type uint32_t at (*ptr)
N */
N#define __LDREXW(ptr)                     ((uint32_t ) __ldrex(ptr))
N
N
N/** \brief  STR Exclusive (8 bit)
N
N    This function performs a exclusive STR command for 8 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N    \return          0  Function succeeded
N    \return          1  Function failed
N */
N#define __STREXB(value, ptr)              __strex(value, ptr)
N
N
N/** \brief  STR Exclusive (16 bit)
N
N    This function performs a exclusive STR command for 16 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N    \return          0  Function succeeded
N    \return          1  Function failed
N */
N#define __STREXH(value, ptr)              __strex(value, ptr)
N
N
N/** \brief  STR Exclusive (32 bit)
N
N    This function performs a exclusive STR command for 32 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N    \return          0  Function succeeded
N    \return          1  Function failed
N */
N#define __STREXW(value, ptr)              __strex(value, ptr)
N
N
N/** \brief  Remove the exclusive lock
N
N    This function removes the exclusive lock which is created by LDREX.
N
N */
N#define __CLREX                           __clrex
N
N
N/** \brief  Signed Saturate
N
N    This function saturates a signed value.
N
N    \param [in]  value  Value to be saturated
N    \param [in]    sat  Bit position to saturate to (1..32)
N    \return             Saturated value
N */
N#define __SSAT                            __ssat
N
N
N/** \brief  Unsigned Saturate
N
N    This function saturates an unsigned value.
N
N    \param [in]  value  Value to be saturated
N    \param [in]    sat  Bit position to saturate to (0..31)
N    \return             Saturated value
N */
N#define __USAT                            __usat
N
N
N/** \brief  Count leading zeros
N
N    This function counts the number of leading zeros of a data value.
N
N    \param [in]  value  Value to count the leading zeros
N    \return             number of leading zeros in value
N */
N#define __CLZ                             __clz 
N
N#endif /* (__CORTEX_M >= 0x03) */
N
N
N
N#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#include <cmsis_iar.h>
S
S
S#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/** \brief  No Operation
S
S    No Operation does nothing. This instruction can be used for code alignment purposes.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __NOP(void)
S{
S  __ASM volatile ("nop");
S}
S
S
S/** \brief  Wait For Interrupt
S
S    Wait For Interrupt is a hint instruction that suspends execution
S    until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __WFI(void)
S{
S  __ASM volatile ("wfi");
S}
S
S
S/** \brief  Wait For Event
S
S    Wait For Event is a hint instruction that permits the processor to enter
S    a low-power state until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __WFE(void)
S{
S  __ASM volatile ("wfe");
S}
S
S
S/** \brief  Send Event
S
S    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __SEV(void)
S{
S  __ASM volatile ("sev");
S}
S
S
S/** \brief  Instruction Synchronization Barrier
S
S    Instruction Synchronization Barrier flushes the pipeline in the processor, 
S    so that all instructions following the ISB are fetched from cache or 
S    memory, after the instruction has been completed.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __ISB(void)
S{
S  __ASM volatile ("isb");
S}
S
S
S/** \brief  Data Synchronization Barrier
S
S    This function acts as a special kind of Data Memory Barrier. 
S    It completes when all explicit memory accesses before this instruction complete.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __DSB(void)
S{
S  __ASM volatile ("dsb");
S}
S
S
S/** \brief  Data Memory Barrier
S
S    This function ensures the apparent order of the explicit memory operations before 
S    and after the instruction, without ensuring their completion.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __DMB(void)
S{
S  __ASM volatile ("dmb");
S}
S
S
S/** \brief  Reverse byte order (32 bit)
S
S    This function reverses the byte order in integer value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __REV(uint32_t value)
S{
S  uint32_t result;
S  
S  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S/** \brief  Reverse byte order (16 bit)
S
S    This function reverses the byte order in two unsigned short values.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __REV16(uint32_t value)
S{
S  uint32_t result;
S  
S  __ASM volatile ("rev16 %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S/** \brief  Reverse byte order in signed short value
S
S    This function reverses the byte order in a signed short value with sign extension to integer.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) static __INLINE int32_t __REVSH(int32_t value)
S{
S  uint32_t result;
S  
S  __ASM volatile ("revsh %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S  
S   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function performs a exclusive LDR command for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) static __INLINE uint8_t __LDREXB(volatile uint8_t *addr)
S{
S    uint8_t result;
S  
S   __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function performs a exclusive LDR command for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) static __INLINE uint16_t __LDREXH(volatile uint16_t *addr)
S{
S    uint16_t result;
S  
S   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function performs a exclusive LDR command for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __LDREXW(volatile uint32_t *addr)
S{
S    uint32_t result;
S  
S   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function performs a exclusive STR command for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
S{
S   uint32_t result;
S  
S   __ASM volatile ("strexb %0, %2, [%1]" : "=r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function performs a exclusive STR command for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)
S{
S   uint32_t result;
S  
S   __ASM volatile ("strexh %0, %2, [%1]" : "=r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function performs a exclusive STR command for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
S{
S   uint32_t result;
S  
S   __ASM volatile ("strex %0, %2, [%1]" : "=r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S__attribute__( ( always_inline ) ) static __INLINE void __CLREX(void)
S{
S  __ASM volatile ("clrex");
S}
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __SSAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __USAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint8_t __CLZ(uint32_t value)
S{
S  uint8_t result;
S  
S  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all intrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N#endif /* __CORE_CMINSTR_H */
L 145 ".\Core\CMSIS\Include\core_cm4.h" 2
N#include <core_cmFunc.h>                 /*!< Core Function Access                            */
L 1 ".\Core\CMSIS\Include\core_cmFunc.h" 1
N/**************************************************************************//**
N * @file     core_cmFunc.h
N * @brief    CMSIS Cortex-M Core Function Access Header File
N * @version  V2.10
N * @date     26. July 2011
N *
N * @note
N * Copyright (C) 2009-2011 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M 
N * processor based microcontrollers.  This file can be freely distributed 
N * within development tools that are supporting such ARM based processors. 
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifndef __CORE_CMFUNC_H
N#define __CORE_CMFUNC_H
N
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface   
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5050041 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N/** \brief  Get Control Register
N
N    This function returns the content of the Control Register.
N
N    \return               Control Register value
N */
Nstatic __INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/** \brief  Set Control Register
N
N    This function writes the given value to the Control Register.
N
N    \param [in]    control  Control Register value to set
N */
Nstatic __INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/** \brief  Get ISPR Register
N
N    This function returns the content of the ISPR Register.
N
N    \return               ISPR Register value
N */
Nstatic __INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/** \brief  Get APSR Register
N
N    This function returns the content of the APSR Register.
N
N    \return               APSR Register value
N */
Nstatic __INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/** \brief  Get xPSR Register
N
N    This function returns the content of the xPSR Register.
N
N    \return               xPSR Register value
N */
Nstatic __INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/** \brief  Get Process Stack Pointer
N
N    This function returns the current value of the Process Stack Pointer (PSP).
N
N    \return               PSP Register value
N */
Nstatic __INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/** \brief  Set Process Stack Pointer
N
N    This function assigns the given value to the Process Stack Pointer (PSP).
N
N    \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
Nstatic __INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/** \brief  Get Main Stack Pointer
N
N    This function returns the current value of the Main Stack Pointer (MSP).
N
N    \return               MSP Register value
N */
Nstatic __INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/** \brief  Set Main Stack Pointer
N
N    This function assigns the given value to the Main Stack Pointer (MSP).
N
N    \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
Nstatic __INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/** \brief  Get Priority Mask
N
N    This function returns the current state of the priority mask bit from the Priority Mask Register.
N
N    \return               Priority Mask value
N */
Nstatic __INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/** \brief  Set Priority Mask
N
N    This function assigns the given value to the Priority Mask Register.
N
N    \param [in]    priMask  Priority Mask
N */
Nstatic __INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N 
N
N#if       (__CORTEX_M >= 0x03)
X#if       ((0x04) >= 0x03)
N
N/** \brief  Enable FIQ
N
N    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
N    Can only be executed in Privileged modes.
N */
N#define __enable_fault_irq                __enable_fiq
N
N
N/** \brief  Disable FIQ
N
N    This function disables FIQ interrupts by setting the F-bit in the CPSR.
N    Can only be executed in Privileged modes.
N */
N#define __disable_fault_irq               __disable_fiq
N
N
N/** \brief  Get Base Priority
N
N    This function returns the current value of the Base Priority register.
N
N    \return               Base Priority register value
N */
Nstatic __INLINE uint32_t  __get_BASEPRI(void)
Xstatic __inline uint32_t  __get_BASEPRI(void)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  return(__regBasePri);
N}
N
N
N/** \brief  Set Base Priority
N
N    This function assigns the given value to the Base Priority register.
N
N    \param [in]    basePri  Base Priority value to set
N */
Nstatic __INLINE void __set_BASEPRI(uint32_t basePri)
Xstatic __inline void __set_BASEPRI(uint32_t basePri)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  __regBasePri = (basePri & 0xff);
N}
N 
N
N/** \brief  Get Fault Mask
N
N    This function returns the current value of the Fault Mask register.
N
N    \return               Fault Mask register value
N */
Nstatic __INLINE uint32_t __get_FAULTMASK(void)
Xstatic __inline uint32_t __get_FAULTMASK(void)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  return(__regFaultMask);
N}
N
N
N/** \brief  Set Fault Mask
N
N    This function assigns the given value to the Fault Mask register.
N
N    \param [in]    faultMask  Fault Mask value to set
N */
Nstatic __INLINE void __set_FAULTMASK(uint32_t faultMask)
Xstatic __inline void __set_FAULTMASK(uint32_t faultMask)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  __regFaultMask = (faultMask & (uint32_t)1);
N}
N
N#endif /* (__CORTEX_M >= 0x03) */
N
N
N#if       (__CORTEX_M == 0x04)
X#if       ((0x04) == 0x04)
N
N/** \brief  Get FPSCR
N
N    This function returns the current value of the Floating Point Status/Control register.
N
N    \return               Floating Point Status/Control register value
N */
Nstatic __INLINE uint32_t __get_FPSCR(void)
Xstatic __inline uint32_t __get_FPSCR(void)
N{
N#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
X#if (1 == 1) && (1 == 1)
N  register uint32_t __regfpscr         __ASM("fpscr");
X  register uint32_t __regfpscr         __asm("fpscr");
N  return(__regfpscr);
N#else
S   return(0);
N#endif
N}
N
N
N/** \brief  Set FPSCR
N
N    This function assigns the given value to the Floating Point Status/Control register.
N
N    \param [in]    fpscr  Floating Point Status/Control value to set
N */
Nstatic __INLINE void __set_FPSCR(uint32_t fpscr)
Xstatic __inline void __set_FPSCR(uint32_t fpscr)
N{
N#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
X#if (1 == 1) && (1 == 1)
N  register uint32_t __regfpscr         __ASM("fpscr");
X  register uint32_t __regfpscr         __asm("fpscr");
N  __regfpscr = (fpscr);
N#endif
N}
N
N#endif /* (__CORTEX_M == 0x04) */
N
N
N#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#include <cmsis_iar.h>
S
S#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/** \brief  Enable IRQ Interrupts
S
S  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __enable_irq(void)
S{
S  __ASM volatile ("cpsie i");
S}
S
S
S/** \brief  Disable IRQ Interrupts
S
S  This function disables IRQ interrupts by setting the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __disable_irq(void)
S{
S  __ASM volatile ("cpsid i");
S}
S
S
S/** \brief  Get Control Register
S
S    This function returns the content of the Control Register.
S
S    \return               Control Register value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_CONTROL(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, control" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Control Register
S
S    This function writes the given value to the Control Register.
S
S    \param [in]    control  Control Register value to set
S */
S__attribute__( ( always_inline ) ) static __INLINE void __set_CONTROL(uint32_t control)
S{
S  __ASM volatile ("MSR control, %0" : : "r" (control) );
S}
S
S
S/** \brief  Get ISPR Register
S
S    This function returns the content of the ISPR Register.
S
S    \return               ISPR Register value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_IPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get APSR Register
S
S    This function returns the content of the APSR Register.
S
S    \return               APSR Register value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_APSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, apsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get xPSR Register
S
S    This function returns the content of the xPSR Register.
S
S    \return               xPSR Register value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_xPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get Process Stack Pointer
S
S    This function returns the current value of the Process Stack Pointer (PSP).
S
S    \return               PSP Register value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_PSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
S  return(result);
S}
S 
S
S/** \brief  Set Process Stack Pointer
S
S    This function assigns the given value to the Process Stack Pointer (PSP).
S
S    \param [in]    topOfProcStack  Process Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) static __INLINE void __set_PSP(uint32_t topOfProcStack)
S{
S  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) );
S}
S
S
S/** \brief  Get Main Stack Pointer
S
S    This function returns the current value of the Main Stack Pointer (MSP).
S
S    \return               MSP Register value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_MSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
S  return(result);
S}
S 
S
S/** \brief  Set Main Stack Pointer
S
S    This function assigns the given value to the Main Stack Pointer (MSP).
S
S    \param [in]    topOfMainStack  Main Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) static __INLINE void __set_MSP(uint32_t topOfMainStack)
S{
S  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) );
S}
S
S
S/** \brief  Get Priority Mask
S
S    This function returns the current state of the priority mask bit from the Priority Mask Register.
S
S    \return               Priority Mask value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_PRIMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, primask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Priority Mask
S
S    This function assigns the given value to the Priority Mask Register.
S
S    \param [in]    priMask  Priority Mask
S */
S__attribute__( ( always_inline ) ) static __INLINE void __set_PRIMASK(uint32_t priMask)
S{
S  __ASM volatile ("MSR primask, %0" : : "r" (priMask) );
S}
S 
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __enable_fault_irq(void)
S{
S  __ASM volatile ("cpsie f");
S}
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __disable_fault_irq(void)
S{
S  __ASM volatile ("cpsid f");
S}
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_BASEPRI(void)
S{
S  uint32_t result;
S  
S  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__attribute__( ( always_inline ) ) static __INLINE void __set_BASEPRI(uint32_t value)
S{
S  __ASM volatile ("MSR basepri, %0" : : "r" (value) );
S}
S
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_FAULTMASK(void)
S{
S  uint32_t result;
S  
S  __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S__attribute__( ( always_inline ) ) static __INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) );
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S#if       (__CORTEX_M == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  uint32_t result;
S
S  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
S  return(result);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__attribute__( ( always_inline ) ) static __INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) );
S#endif
S}
S
S#endif /* (__CORTEX_M == 0x04) */
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all instrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N#endif /* __CORE_CMFUNC_H */
L 146 ".\Core\CMSIS\Include\core_cm4.h" 2
N#include <core_cm4_simd.h>               /*!< Compiler specific SIMD Intrinsics               */
L 1 ".\Core\CMSIS\Include\core_cm4_simd.h" 1
N/**************************************************************************//**
N * @file     core_cm4_simd.h
N * @brief    CMSIS Cortex-M4 SIMD Header File
N * @version  V2.10
N * @date     19. July 2011
N *
N * @note
N * Copyright (C) 2010-2011 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M 
N * processor based microcontrollers.  This file can be freely distributed 
N * within development tools that are supporting such ARM based processors. 
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifdef __cplusplus
S extern "C" {
N#endif 
N
N#ifndef __CORE_CM4_SIMD_H
N#define __CORE_CM4_SIMD_H
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N ******************************************************************************/
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N  Access to dedicated SIMD instructions
N  @{
N*/
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N/*------ CM4 SOMD Intrinsics -----------------------------------------------------*/
N#define __SADD8                           __sadd8
N#define __QADD8                           __qadd8
N#define __SHADD8                          __shadd8
N#define __UADD8                           __uadd8
N#define __UQADD8                          __uqadd8
N#define __UHADD8                          __uhadd8
N#define __SSUB8                           __ssub8
N#define __QSUB8                           __qsub8
N#define __SHSUB8                          __shsub8
N#define __USUB8                           __usub8
N#define __UQSUB8                          __uqsub8
N#define __UHSUB8                          __uhsub8
N#define __SADD16                          __sadd16
N#define __QADD16                          __qadd16
N#define __SHADD16                         __shadd16
N#define __UADD16                          __uadd16
N#define __UQADD16                         __uqadd16
N#define __UHADD16                         __uhadd16
N#define __SSUB16                          __ssub16
N#define __QSUB16                          __qsub16
N#define __SHSUB16                         __shsub16
N#define __USUB16                          __usub16
N#define __UQSUB16                         __uqsub16
N#define __UHSUB16                         __uhsub16
N#define __SASX                            __sasx
N#define __QASX                            __qasx
N#define __SHASX                           __shasx
N#define __UASX                            __uasx
N#define __UQASX                           __uqasx
N#define __UHASX                           __uhasx
N#define __SSAX                            __ssax
N#define __QSAX                            __qsax
N#define __SHSAX                           __shsax
N#define __USAX                            __usax
N#define __UQSAX                           __uqsax
N#define __UHSAX                           __uhsax
N#define __USAD8                           __usad8
N#define __USADA8                          __usada8
N#define __SSAT16                          __ssat16
N#define __USAT16                          __usat16
N#define __UXTB16                          __uxtb16
N#define __UXTAB16                         __uxtab16
N#define __SXTB16                          __sxtb16
N#define __SXTAB16                         __sxtab16
N#define __SMUAD                           __smuad
N#define __SMUADX                          __smuadx
N#define __SMLAD                           __smlad
N#define __SMLADX                          __smladx
N#define __SMLALD                          __smlald
N#define __SMLALDX                         __smlaldx
N#define __SMUSD                           __smusd
N#define __SMUSDX                          __smusdx
N#define __SMLSD                           __smlsd
N#define __SMLSDX                          __smlsdx
N#define __SMLSLD                          __smlsld
N#define __SMLSLDX                         __smlsldx
N#define __SEL                             __sel
N#define __QADD                            __qadd
N#define __QSUB                            __qsub
N
N#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \
N                                           ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
X#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |                                             ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
N
N#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \
N                                           ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
X#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |                                             ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
N
N
N/*-- End CM4 SIMD Intrinsics -----------------------------------------------------*/
N
N
N
N#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#include <cmsis_iar.h>
S
S/*------ CM4 SIMDDSP Intrinsics -----------------------------------------------------*/
S/* intrinsic __SADD8      see intrinsics.h */
S/* intrinsic __QADD8      see intrinsics.h */
S/* intrinsic __SHADD8     see intrinsics.h */
S/* intrinsic __UADD8      see intrinsics.h */
S/* intrinsic __UQADD8     see intrinsics.h */
S/* intrinsic __UHADD8     see intrinsics.h */
S/* intrinsic __SSUB8      see intrinsics.h */
S/* intrinsic __QSUB8      see intrinsics.h */
S/* intrinsic __SHSUB8     see intrinsics.h */
S/* intrinsic __USUB8      see intrinsics.h */
S/* intrinsic __UQSUB8     see intrinsics.h */
S/* intrinsic __UHSUB8     see intrinsics.h */
S/* intrinsic __SADD16     see intrinsics.h */
S/* intrinsic __QADD16     see intrinsics.h */
S/* intrinsic __SHADD16    see intrinsics.h */
S/* intrinsic __UADD16     see intrinsics.h */
S/* intrinsic __UQADD16    see intrinsics.h */
S/* intrinsic __UHADD16    see intrinsics.h */
S/* intrinsic __SSUB16     see intrinsics.h */
S/* intrinsic __QSUB16     see intrinsics.h */
S/* intrinsic __SHSUB16    see intrinsics.h */
S/* intrinsic __USUB16     see intrinsics.h */
S/* intrinsic __UQSUB16    see intrinsics.h */
S/* intrinsic __UHSUB16    see intrinsics.h */
S/* intrinsic __SASX       see intrinsics.h */
S/* intrinsic __QASX       see intrinsics.h */
S/* intrinsic __SHASX      see intrinsics.h */
S/* intrinsic __UASX       see intrinsics.h */
S/* intrinsic __UQASX      see intrinsics.h */
S/* intrinsic __UHASX      see intrinsics.h */
S/* intrinsic __SSAX       see intrinsics.h */
S/* intrinsic __QSAX       see intrinsics.h */
S/* intrinsic __SHSAX      see intrinsics.h */
S/* intrinsic __USAX       see intrinsics.h */
S/* intrinsic __UQSAX      see intrinsics.h */
S/* intrinsic __UHSAX      see intrinsics.h */
S/* intrinsic __USAD8      see intrinsics.h */
S/* intrinsic __USADA8     see intrinsics.h */
S/* intrinsic __SSAT16     see intrinsics.h */
S/* intrinsic __USAT16     see intrinsics.h */
S/* intrinsic __UXTB16     see intrinsics.h */
S/* intrinsic __SXTB16     see intrinsics.h */
S/* intrinsic __UXTAB16    see intrinsics.h */
S/* intrinsic __SXTAB16    see intrinsics.h */
S/* intrinsic __SMUAD      see intrinsics.h */
S/* intrinsic __SMUADX     see intrinsics.h */
S/* intrinsic __SMLAD      see intrinsics.h */
S/* intrinsic __SMLADX     see intrinsics.h */
S/* intrinsic __SMLALD     see intrinsics.h */
S/* intrinsic __SMLALDX    see intrinsics.h */
S/* intrinsic __SMUSD      see intrinsics.h */
S/* intrinsic __SMUSDX     see intrinsics.h */
S/* intrinsic __SMLSD      see intrinsics.h */
S/* intrinsic __SMLSDX     see intrinsics.h */
S/* intrinsic __SMLSLD     see intrinsics.h */
S/* intrinsic __SMLSLDX    see intrinsics.h */
S/* intrinsic __SEL        see intrinsics.h */
S/* intrinsic __QADD       see intrinsics.h */
S/* intrinsic __QSUB       see intrinsics.h */
S/* intrinsic __PKHBT      see intrinsics.h */
S/* intrinsic __PKHTB      see intrinsics.h */
S
S/*-- End CM4 SIMD Intrinsics -----------------------------------------------------*/
S
S
S
S#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/*------ CM4 SIMD Intrinsics -----------------------------------------------------*/
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __SADD8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S  
S  __ASM volatile ("sadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __QADD8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S  
S  __ASM volatile ("qadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __SHADD8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S  
S  __ASM volatile ("shadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __UADD8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S  
S  __ASM volatile ("uadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __UQADD8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S  
S  __ASM volatile ("uqadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __UHADD8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S  
S  __ASM volatile ("uhadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __SSUB8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S  
S  __ASM volatile ("ssub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __QSUB8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S  
S  __ASM volatile ("qsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __SHSUB8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S  
S  __ASM volatile ("shsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __USUB8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S  
S  __ASM volatile ("usub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __UQSUB8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S  
S  __ASM volatile ("uqsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __UHSUB8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S  
S  __ASM volatile ("uhsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __SADD16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S  
S  __ASM volatile ("sadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __QADD16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S  
S  __ASM volatile ("qadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __SHADD16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S  
S  __ASM volatile ("shadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __UADD16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S  
S  __ASM volatile ("uadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __UQADD16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S  
S  __ASM volatile ("uqadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __UHADD16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S  
S  __ASM volatile ("uhadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __SSUB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S  
S  __ASM volatile ("ssub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __QSUB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S  
S  __ASM volatile ("qsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __SHSUB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S  
S  __ASM volatile ("shsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __USUB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S  
S  __ASM volatile ("usub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __UQSUB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S  
S  __ASM volatile ("uqsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __UHSUB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S  
S  __ASM volatile ("uhsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __SASX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S  
S  __ASM volatile ("sasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __QASX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S  
S  __ASM volatile ("qasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __SHASX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S  
S  __ASM volatile ("shasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __UASX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S  
S  __ASM volatile ("uasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __UQASX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S  
S  __ASM volatile ("uqasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __UHASX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S  
S  __ASM volatile ("uhasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __SSAX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S  
S  __ASM volatile ("ssax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __QSAX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S  
S  __ASM volatile ("qsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __SHSAX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S  
S  __ASM volatile ("shsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __USAX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S  
S  __ASM volatile ("usax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __UQSAX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S  
S  __ASM volatile ("uqsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __UHSAX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S  
S  __ASM volatile ("uhsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __USAD8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S  
S  __ASM volatile ("usad8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __USADA8(uint32_t op1, uint32_t op2, uint32_t op3)
S{
S  uint32_t result;
S  
S  __ASM volatile ("usada8 %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
S  return(result);
S}
S
S#define __SSAT16(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("ssat16 %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __SSAT16(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("ssat16 %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S  
S#define __USAT16(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("usat16 %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __USAT16(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("usat16 %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __UXTB16(uint32_t op1)
S{
S  uint32_t result;
S  
S  __ASM volatile ("uxtb16 %0, %1" : "=r" (result) : "r" (op1));
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __UXTAB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S  
S  __ASM volatile ("uxtab16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __SXTB16(uint32_t op1)
S{
S  uint32_t result;
S  
S  __ASM volatile ("sxtb16 %0, %1" : "=r" (result) : "r" (op1));
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __SXTAB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S  
S  __ASM volatile ("sxtab16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __SMUAD  (uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S  
S  __ASM volatile ("smuad %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __SMUADX (uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S  
S  __ASM volatile ("smuadx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __SMLAD (uint32_t op1, uint32_t op2, uint32_t op3)
S{
S  uint32_t result;
S  
S  __ASM volatile ("smlad %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __SMLADX (uint32_t op1, uint32_t op2, uint32_t op3)
S{
S  uint32_t result;
S  
S  __ASM volatile ("smladx %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
S  return(result);
S}
S
S#define __SMLALD(ARG1,ARG2,ARG3) \
S({ \
S  uint32_t __ARG1 = (ARG1), __ARG2 = (ARG2), __ARG3_H = (uint32_t)((uint64_t)(ARG3) >> 32), __ARG3_L = (uint32_t)((uint64_t)(ARG3) & 0xFFFFFFFFUL); \
S  __ASM volatile ("smlald %0, %1, %2, %3" : "=r" (__ARG3_L), "=r" (__ARG3_H) : "r" (__ARG1), "r" (__ARG2), "0" (__ARG3_L), "1" (__ARG3_H) ); \
S  (uint64_t)(((uint64_t)__ARG3_H << 32) | __ARG3_L); \
S })
X#define __SMLALD(ARG1,ARG2,ARG3) ({   uint32_t __ARG1 = (ARG1), __ARG2 = (ARG2), __ARG3_H = (uint32_t)((uint64_t)(ARG3) >> 32), __ARG3_L = (uint32_t)((uint64_t)(ARG3) & 0xFFFFFFFFUL);   __ASM volatile ("smlald %0, %1, %2, %3" : "=r" (__ARG3_L), "=r" (__ARG3_H) : "r" (__ARG1), "r" (__ARG2), "0" (__ARG3_L), "1" (__ARG3_H) );   (uint64_t)(((uint64_t)__ARG3_H << 32) | __ARG3_L);  })
S
S#define __SMLALDX(ARG1,ARG2,ARG3) \
S({ \
S  uint32_t __ARG1 = (ARG1), __ARG2 = (ARG2), __ARG3_H = (uint32_t)((uint64_t)(ARG3) >> 32), __ARG3_L = (uint32_t)((uint64_t)(ARG3) & 0xFFFFFFFFUL); \
S  __ASM volatile ("smlaldx %0, %1, %2, %3" : "=r" (__ARG3_L), "=r" (__ARG3_H) : "r" (__ARG1), "r" (__ARG2), "0" (__ARG3_L), "1" (__ARG3_H) ); \
S  (uint64_t)(((uint64_t)__ARG3_H << 32) | __ARG3_L); \
S })
X#define __SMLALDX(ARG1,ARG2,ARG3) ({   uint32_t __ARG1 = (ARG1), __ARG2 = (ARG2), __ARG3_H = (uint32_t)((uint64_t)(ARG3) >> 32), __ARG3_L = (uint32_t)((uint64_t)(ARG3) & 0xFFFFFFFFUL);   __ASM volatile ("smlaldx %0, %1, %2, %3" : "=r" (__ARG3_L), "=r" (__ARG3_H) : "r" (__ARG1), "r" (__ARG2), "0" (__ARG3_L), "1" (__ARG3_H) );   (uint64_t)(((uint64_t)__ARG3_H << 32) | __ARG3_L);  })
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __SMUSD  (uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S  
S  __ASM volatile ("smusd %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __SMUSDX (uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S  
S  __ASM volatile ("smusdx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __SMLSD (uint32_t op1, uint32_t op2, uint32_t op3)
S{
S  uint32_t result;
S  
S  __ASM volatile ("smlsd %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __SMLSDX (uint32_t op1, uint32_t op2, uint32_t op3)
S{
S  uint32_t result;
S  
S  __ASM volatile ("smlsdx %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
S  return(result);
S}
S
S#define __SMLSLD(ARG1,ARG2,ARG3) \
S({ \
S  uint32_t __ARG1 = (ARG1), __ARG2 = (ARG2), __ARG3_H = (uint32_t)((ARG3) >> 32), __ARG3_L = (uint32_t)((ARG3) & 0xFFFFFFFFUL); \
S  __ASM volatile ("smlsld %0, %1, %2, %3" : "=r" (__ARG3_L), "=r" (__ARG3_H) : "r" (__ARG1), "r" (__ARG2), "0" (__ARG3_L), "1" (__ARG3_H) ); \
S  (uint64_t)(((uint64_t)__ARG3_H << 32) | __ARG3_L); \
S })
X#define __SMLSLD(ARG1,ARG2,ARG3) ({   uint32_t __ARG1 = (ARG1), __ARG2 = (ARG2), __ARG3_H = (uint32_t)((ARG3) >> 32), __ARG3_L = (uint32_t)((ARG3) & 0xFFFFFFFFUL);   __ASM volatile ("smlsld %0, %1, %2, %3" : "=r" (__ARG3_L), "=r" (__ARG3_H) : "r" (__ARG1), "r" (__ARG2), "0" (__ARG3_L), "1" (__ARG3_H) );   (uint64_t)(((uint64_t)__ARG3_H << 32) | __ARG3_L);  })
S
S#define __SMLSLDX(ARG1,ARG2,ARG3) \
S({ \
S  uint32_t __ARG1 = (ARG1), __ARG2 = (ARG2), __ARG3_H = (uint32_t)((ARG3) >> 32), __ARG3_L = (uint32_t)((ARG3) & 0xFFFFFFFFUL); \
S  __ASM volatile ("smlsldx %0, %1, %2, %3" : "=r" (__ARG3_L), "=r" (__ARG3_H) : "r" (__ARG1), "r" (__ARG2), "0" (__ARG3_L), "1" (__ARG3_H) ); \
S  (uint64_t)(((uint64_t)__ARG3_H << 32) | __ARG3_L); \
S })
X#define __SMLSLDX(ARG1,ARG2,ARG3) ({   uint32_t __ARG1 = (ARG1), __ARG2 = (ARG2), __ARG3_H = (uint32_t)((ARG3) >> 32), __ARG3_L = (uint32_t)((ARG3) & 0xFFFFFFFFUL);   __ASM volatile ("smlsldx %0, %1, %2, %3" : "=r" (__ARG3_L), "=r" (__ARG3_H) : "r" (__ARG1), "r" (__ARG2), "0" (__ARG3_L), "1" (__ARG3_H) );   (uint64_t)(((uint64_t)__ARG3_H << 32) | __ARG3_L);  })
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __SEL  (uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S  
S  __ASM volatile ("sel %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __QADD(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("qadd %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __QSUB(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S  
S  __ASM volatile ("qsub %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S#define __PKHBT(ARG1,ARG2,ARG3) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1), __ARG2 = (ARG2); \
S  __ASM ("pkhbt %0, %1, %2, lsl %3" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2), "I" (ARG3)  ); \
S  __RES; \
S })
X#define __PKHBT(ARG1,ARG2,ARG3) ({                            uint32_t __RES, __ARG1 = (ARG1), __ARG2 = (ARG2);   __ASM ("pkhbt %0, %1, %2, lsl %3" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2), "I" (ARG3)  );   __RES;  })
S
S#define __PKHTB(ARG1,ARG2,ARG3) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1), __ARG2 = (ARG2); \
S  if (ARG3 == 0) \
S    __ASM ("pkhtb %0, %1, %2" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2)  ); \
S  else	\
S    __ASM ("pkhtb %0, %1, %2, asr %3" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2), "I" (ARG3)  ); \
S  __RES; \
S })
X#define __PKHTB(ARG1,ARG2,ARG3) ({                            uint32_t __RES, __ARG1 = (ARG1), __ARG2 = (ARG2);   if (ARG3 == 0)     __ASM ("pkhtb %0, %1, %2" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2)  );   else	    __ASM ("pkhtb %0, %1, %2, asr %3" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2), "I" (ARG3)  );   __RES;  })
S
S/*-- End CM4 SIMD Intrinsics -----------------------------------------------------*/
S
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S
S
S/*------ CM4 SIMD Intrinsics -----------------------------------------------------*/
S/* not yet supported */
S/*-- End CM4 SIMD Intrinsics -----------------------------------------------------*/
S
S
N#endif
N
N/*@} end of group CMSIS_SIMD_intrinsics */
N
N
N#endif /* __CORE_CM4_SIMD_H */
N
N#ifdef __cplusplus
S}
N#endif
L 147 ".\Core\CMSIS\Include\core_cm4.h" 2
N
N#endif /* __CORE_CM4_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM4_H_DEPENDANT
N#define __CORE_CM4_H_DEPENDANT
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM4_REV
S    #define __CM4_REV               0x0000
S    #warning "__CM4_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __FPU_PRESENT
S    #define __FPU_PRESENT             0
S    #warning "__FPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __MPU_PRESENT
S    #define __MPU_PRESENT             0
S    #warning "__MPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          4
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< defines 'read only' permissions                 */
N#else
N  #define   __I     volatile const       /*!< defines 'read only' permissions                 */
N#endif
N#define     __O     volatile             /*!< defines 'write only' permissions                */
N#define     __IO    volatile             /*!< defines 'read / write' permissions              */
N
N/*@} end of group CMSIS_core_definitions */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N ******************************************************************************/
N/** \defgroup CMSIS_core_register CMSIS Core Register
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N  - Core Debug Register
N  - Core MPU Register
N  - Core FPU Register
N*/
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_CORE CMSIS Core
N  Type definitions for the Cortex-M Core Registers
N  @{
N */
N
N/** \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N#if (__CORTEX_M != 0x04)
X#if ((0x04) != 0x04)
S    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved                           */
N#else
N    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved                           */
N    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
N    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved                           */
N#endif
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} APSR_Type;
N
N
N/** \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} IPSR_Type;
N
N
N/** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N#if (__CORTEX_M != 0x04)
X#if ((0x04) != 0x04)
S    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
N#else
N    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved                           */
N    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
N    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved                           */
N#endif
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
N    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} xPSR_Type;
N
N
N/** \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
N    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag           */
N    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} CONTROL_Type;
N
N/*@} end of group CMSIS_CORE */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_NVIC CMSIS NVIC
N  Type definitions for the Cortex-M NVIC Registers
N  @{
N */
N
N/** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IO uint32_t ISER[8];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register           */
X  volatile uint32_t ISER[8];                  
N       uint32_t RESERVED0[24];
N  __IO uint32_t ICER[8];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register         */
X  volatile uint32_t ICER[8];                  
N       uint32_t RSERVED1[24];
N  __IO uint32_t ISPR[8];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register          */
X  volatile uint32_t ISPR[8];                  
N       uint32_t RESERVED2[24];
N  __IO uint32_t ICPR[8];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register        */
X  volatile uint32_t ICPR[8];                  
N       uint32_t RESERVED3[24];
N  __IO uint32_t IABR[8];                 /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register           */
X  volatile uint32_t IABR[8];                  
N       uint32_t RESERVED4[56];
N  __IO uint8_t  IP[240];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
X  volatile uint8_t  IP[240];                  
N       uint32_t RESERVED5[644];
N  __O  uint32_t STIR;                    /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register     */
X  volatile  uint32_t STIR;                     
N}  NVIC_Type;
N
N/* Software Triggered Interrupt Register Definitions */
N#define NVIC_STIR_INTID_Pos                 0                                          /*!< STIR: INTLINESNUM Position */
N#define NVIC_STIR_INTID_Msk                (0x1FFUL << NVIC_STIR_INTID_Pos)            /*!< STIR: INTLINESNUM Mask */
N
N/*@} end of group CMSIS_NVIC */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SCB CMSIS SCB
N  Type definitions for the Cortex-M System Control Block Registers
N  @{
N */
N
N/** \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPUID Base Register                                   */
X  volatile const  uint32_t CPUID;                    
N  __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register                  */
X  volatile uint32_t ICSR;                     
N  __IO uint32_t VTOR;                    /*!< Offset: 0x008 (R/W)  Vector Table Offset Register                          */
X  volatile uint32_t VTOR;                     
N  __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register      */
X  volatile uint32_t AIRCR;                    
N  __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register                               */
X  volatile uint32_t SCR;                      
N  __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register                        */
X  volatile uint32_t CCR;                      
N  __IO uint8_t  SHP[12];                 /*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) */
X  volatile uint8_t  SHP[12];                  
N  __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State Register             */
X  volatile uint32_t SHCSR;                    
N  __IO uint32_t CFSR;                    /*!< Offset: 0x028 (R/W)  Configurable Fault Status Register                    */
X  volatile uint32_t CFSR;                     
N  __IO uint32_t HFSR;                    /*!< Offset: 0x02C (R/W)  HardFault Status Register                             */
X  volatile uint32_t HFSR;                     
N  __IO uint32_t DFSR;                    /*!< Offset: 0x030 (R/W)  Debug Fault Status Register                           */
X  volatile uint32_t DFSR;                     
N  __IO uint32_t MMFAR;                   /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register                      */
X  volatile uint32_t MMFAR;                    
N  __IO uint32_t BFAR;                    /*!< Offset: 0x038 (R/W)  BusFault Address Register                             */
X  volatile uint32_t BFAR;                     
N  __IO uint32_t AFSR;                    /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register                       */
X  volatile uint32_t AFSR;                     
N  __I  uint32_t PFR[2];                  /*!< Offset: 0x040 (R/ )  Processor Feature Register                            */
X  volatile const  uint32_t PFR[2];                   
N  __I  uint32_t DFR;                     /*!< Offset: 0x048 (R/ )  Debug Feature Register                                */
X  volatile const  uint32_t DFR;                      
N  __I  uint32_t ADR;                     /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register                            */
X  volatile const  uint32_t ADR;                      
N  __I  uint32_t MMFR[4];                 /*!< Offset: 0x050 (R/ )  Memory Model Feature Register                         */
X  volatile const  uint32_t MMFR[4];                  
N  __I  uint32_t ISAR[5];                 /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register                   */
X  volatile const  uint32_t ISAR[5];                  
N       uint32_t RESERVED0[5];
N  __IO uint32_t CPACR;                   /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register                   */
X  volatile uint32_t CPACR;                    
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_RETTOBASE_Pos             11                                             /*!< SCB ICSR: RETTOBASE Position */
N#define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Vector Table Offset Register Definitions */
N#define SCB_VTOR_TBLOFF_Pos                 7                                             /*!< SCB VTOR: TBLOFF Position */
N#define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB VTOR: TBLOFF Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_PRIGROUP_Pos              8                                             /*!< SCB AIRCR: PRIGROUP Position */
N#define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N#define SCB_AIRCR_VECTRESET_Pos             0                                             /*!< SCB AIRCR: VECTRESET Position */
N#define SCB_AIRCR_VECTRESET_Msk            (1UL << SCB_AIRCR_VECTRESET_Pos)               /*!< SCB AIRCR: VECTRESET Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_BFHFNMIGN_Pos               8                                             /*!< SCB CCR: BFHFNMIGN Position */
N#define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
N
N#define SCB_CCR_DIV_0_TRP_Pos               4                                             /*!< SCB CCR: DIV_0_TRP Position */
N#define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N#define SCB_CCR_USERSETMPEND_Pos            1                                             /*!< SCB CCR: USERSETMPEND Position */
N#define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
N
N#define SCB_CCR_NONBASETHRDENA_Pos          0                                             /*!< SCB CCR: NONBASETHRDENA Position */
N#define SCB_CCR_NONBASETHRDENA_Msk         (1UL << SCB_CCR_NONBASETHRDENA_Pos)            /*!< SCB CCR: NONBASETHRDENA Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_USGFAULTENA_Pos          18                                             /*!< SCB SHCSR: USGFAULTENA Position */
N#define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
N
N#define SCB_SHCSR_BUSFAULTENA_Pos          17                                             /*!< SCB SHCSR: BUSFAULTENA Position */
N#define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
N
N#define SCB_SHCSR_MEMFAULTENA_Pos          16                                             /*!< SCB SHCSR: MEMFAULTENA Position */
N#define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
N
N#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N#define SCB_SHCSR_BUSFAULTPENDED_Pos       14                                             /*!< SCB SHCSR: BUSFAULTPENDED Position */
N#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
N
N#define SCB_SHCSR_MEMFAULTPENDED_Pos       13                                             /*!< SCB SHCSR: MEMFAULTPENDED Position */
N#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
N
N#define SCB_SHCSR_USGFAULTPENDED_Pos       12                                             /*!< SCB SHCSR: USGFAULTPENDED Position */
N#define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
N
N#define SCB_SHCSR_SYSTICKACT_Pos           11                                             /*!< SCB SHCSR: SYSTICKACT Position */
N#define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
N
N#define SCB_SHCSR_PENDSVACT_Pos            10                                             /*!< SCB SHCSR: PENDSVACT Position */
N#define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
N
N#define SCB_SHCSR_MONITORACT_Pos            8                                             /*!< SCB SHCSR: MONITORACT Position */
N#define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
N
N#define SCB_SHCSR_SVCALLACT_Pos             7                                             /*!< SCB SHCSR: SVCALLACT Position */
N#define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
N
N#define SCB_SHCSR_USGFAULTACT_Pos           3                                             /*!< SCB SHCSR: USGFAULTACT Position */
N#define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
N
N#define SCB_SHCSR_BUSFAULTACT_Pos           1                                             /*!< SCB SHCSR: BUSFAULTACT Position */
N#define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
N
N#define SCB_SHCSR_MEMFAULTACT_Pos           0                                             /*!< SCB SHCSR: MEMFAULTACT Position */
N#define SCB_SHCSR_MEMFAULTACT_Msk          (1UL << SCB_SHCSR_MEMFAULTACT_Pos)             /*!< SCB SHCSR: MEMFAULTACT Mask */
N
N/* SCB Configurable Fault Status Registers Definitions */
N#define SCB_CFSR_USGFAULTSR_Pos            16                                             /*!< SCB CFSR: Usage Fault Status Register Position */
N#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
N
N#define SCB_CFSR_BUSFAULTSR_Pos             8                                             /*!< SCB CFSR: Bus Fault Status Register Position */
N#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
N
N#define SCB_CFSR_MEMFAULTSR_Pos             0                                             /*!< SCB CFSR: Memory Manage Fault Status Register Position */
N#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL << SCB_CFSR_MEMFAULTSR_Pos)            /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
N
N/* SCB Hard Fault Status Registers Definitions */
N#define SCB_HFSR_DEBUGEVT_Pos              31                                             /*!< SCB HFSR: DEBUGEVT Position */
N#define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
N
N#define SCB_HFSR_FORCED_Pos                30                                             /*!< SCB HFSR: FORCED Position */
N#define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
N
N#define SCB_HFSR_VECTTBL_Pos                1                                             /*!< SCB HFSR: VECTTBL Position */
N#define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
N
N/* SCB Debug Fault Status Register Definitions */
N#define SCB_DFSR_EXTERNAL_Pos               4                                             /*!< SCB DFSR: EXTERNAL Position */
N#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
N
N#define SCB_DFSR_VCATCH_Pos                 3                                             /*!< SCB DFSR: VCATCH Position */
N#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
N
N#define SCB_DFSR_DWTTRAP_Pos                2                                             /*!< SCB DFSR: DWTTRAP Position */
N#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
N
N#define SCB_DFSR_BKPT_Pos                   1                                             /*!< SCB DFSR: BKPT Position */
N#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
N
N#define SCB_DFSR_HALTED_Pos                 0                                             /*!< SCB DFSR: HALTED Position */
N#define SCB_DFSR_HALTED_Msk                (1UL << SCB_DFSR_HALTED_Pos)                   /*!< SCB DFSR: HALTED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SCnSCB CMSIS System Control and ID Register not in the SCB
N  Type definitions for the Cortex-M System Control and ID Register not in the SCB
N  @{
N */
N
N/** \brief  Structure type to access the System Control and ID Register not in the SCB.
N */
Ntypedef struct
N{
N       uint32_t RESERVED0[1];
N  __I  uint32_t ICTR;                    /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Register      */
X  volatile const  uint32_t ICTR;                     
N  __IO uint32_t ACTLR;                   /*!< Offset: 0x008 (R/W)  Auxiliary Control Register              */
X  volatile uint32_t ACTLR;                    
N} SCnSCB_Type;
N
N/* Interrupt Controller Type Register Definitions */
N#define SCnSCB_ICTR_INTLINESNUM_Pos         0                                          /*!< ICTR: INTLINESNUM Position */
N#define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL << SCnSCB_ICTR_INTLINESNUM_Pos)      /*!< ICTR: INTLINESNUM Mask */
N
N/* Auxiliary Control Register Definitions */
N#define SCnSCB_ACTLR_DISOOFP_Pos            9                                          /*!< ACTLR: DISOOFP Position */
N#define SCnSCB_ACTLR_DISOOFP_Msk           (1UL << SCnSCB_ACTLR_DISOOFP_Pos)           /*!< ACTLR: DISOOFP Mask */
N
N#define SCnSCB_ACTLR_DISFPCA_Pos            8                                          /*!< ACTLR: DISFPCA Position */
N#define SCnSCB_ACTLR_DISFPCA_Msk           (1UL << SCnSCB_ACTLR_DISFPCA_Pos)           /*!< ACTLR: DISFPCA Mask */
N
N#define SCnSCB_ACTLR_DISFOLD_Pos            2                                          /*!< ACTLR: DISFOLD Position */
N#define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: DISFOLD Mask */
N
N#define SCnSCB_ACTLR_DISDEFWBUF_Pos         1                                          /*!< ACTLR: DISDEFWBUF Position */
N#define SCnSCB_ACTLR_DISDEFWBUF_Msk        (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)        /*!< ACTLR: DISDEFWBUF Mask */
N
N#define SCnSCB_ACTLR_DISMCYCINT_Pos         0                                          /*!< ACTLR: DISMCYCINT Position */
N#define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL << SCnSCB_ACTLR_DISMCYCINT_Pos)        /*!< ACTLR: DISMCYCINT Mask */
N
N/*@} end of group CMSIS_SCnotSCB */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SysTick CMSIS SysTick
N  Type definitions for the Cortex-M System Timer Registers
N  @{
N */
N
N/** \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
X  volatile uint32_t LOAD;                     
N  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
X  volatile uint32_t VAL;                      
N  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
X  volatile const  uint32_t CALIB;                    
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_ITM CMSIS ITM
N  Type definitions for the Cortex-M Instrumentation Trace Macrocell (ITM)
N  @{
N */
N
N/** \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
N */
Ntypedef struct
N{
N  __O  union
X  volatile  union
N  {
N    __O  uint8_t    u8;                  /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit                   */
X    volatile  uint8_t    u8;                   
N    __O  uint16_t   u16;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit                  */
X    volatile  uint16_t   u16;                  
N    __O  uint32_t   u32;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit                  */
X    volatile  uint32_t   u32;                  
N  }  PORT [32];                          /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers               */
N       uint32_t RESERVED0[864];
N  __IO uint32_t TER;                     /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register                 */
X  volatile uint32_t TER;                      
N       uint32_t RESERVED1[15];
N  __IO uint32_t TPR;                     /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register              */
X  volatile uint32_t TPR;                      
N       uint32_t RESERVED2[15];
N  __IO uint32_t TCR;                     /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register                */
X  volatile uint32_t TCR;                      
N} ITM_Type;
N
N/* ITM Trace Privilege Register Definitions */
N#define ITM_TPR_PRIVMASK_Pos                0                                          /*!< ITM TPR: PRIVMASK Position */
N#define ITM_TPR_PRIVMASK_Msk               (0xFUL << ITM_TPR_PRIVMASK_Pos)             /*!< ITM TPR: PRIVMASK Mask */
N
N/* ITM Trace Control Register Definitions */
N#define ITM_TCR_BUSY_Pos                   23                                          /*!< ITM TCR: BUSY Position */
N#define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                   /*!< ITM TCR: BUSY Mask */
N
N#define ITM_TCR_TraceBusID_Pos             16                                          /*!< ITM TCR: ATBID Position */
N#define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)          /*!< ITM TCR: ATBID Mask */
N
N#define ITM_TCR_GTSFREQ_Pos                10                                          /*!< ITM TCR: Global timestamp frequency Position */
N#define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                /*!< ITM TCR: Global timestamp frequency Mask */
N
N#define ITM_TCR_TSPrescale_Pos              8                                          /*!< ITM TCR: TSPrescale Position */
N#define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)             /*!< ITM TCR: TSPrescale Mask */
N
N#define ITM_TCR_SWOENA_Pos                  4                                          /*!< ITM TCR: SWOENA Position */
N#define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                 /*!< ITM TCR: SWOENA Mask */
N
N#define ITM_TCR_TXENA_Pos                   3                                          /*!< ITM TCR: TXENA Position */
N#define ITM_TCR_TXENA_Msk                  (1UL << ITM_TCR_TXENA_Pos)                  /*!< ITM TCR: TXENA Mask */
N
N#define ITM_TCR_SYNCENA_Pos                 2                                          /*!< ITM TCR: SYNCENA Position */
N#define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                /*!< ITM TCR: SYNCENA Mask */
N
N#define ITM_TCR_TSENA_Pos                   1                                          /*!< ITM TCR: TSENA Position */
N#define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                  /*!< ITM TCR: TSENA Mask */
N
N#define ITM_TCR_ITMENA_Pos                  0                                          /*!< ITM TCR: ITM Enable bit Position */
N#define ITM_TCR_ITMENA_Msk                 (1UL << ITM_TCR_ITMENA_Pos)                 /*!< ITM TCR: ITM Enable bit Mask */
N
N/*@}*/ /* end of group CMSIS_ITM */
N
N
N#if (__MPU_PRESENT == 1)
X#if (1 == 1)
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_MPU CMSIS MPU
N  Type definitions for the Cortex-M Memory Protection Unit (MPU)
N  @{
N */
N
N/** \brief  Structure type to access the Memory Protection Unit (MPU).
N */
Ntypedef struct
N{
N  __I  uint32_t TYPE;                    /*!< Offset: 0x000 (R/ )  MPU Type Register                              */
X  volatile const  uint32_t TYPE;                     
N  __IO uint32_t CTRL;                    /*!< Offset: 0x004 (R/W)  MPU Control Register                           */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t RNR;                     /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register                     */
X  volatile uint32_t RNR;                      
N  __IO uint32_t RBAR;                    /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register               */
X  volatile uint32_t RBAR;                     
N  __IO uint32_t RASR;                    /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register         */
X  volatile uint32_t RASR;                     
N  __IO uint32_t RBAR_A1;                 /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address Register       */
X  volatile uint32_t RBAR_A1;                  
N  __IO uint32_t RASR_A1;                 /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and Size Register */
X  volatile uint32_t RASR_A1;                  
N  __IO uint32_t RBAR_A2;                 /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address Register       */
X  volatile uint32_t RBAR_A2;                  
N  __IO uint32_t RASR_A2;                 /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and Size Register */
X  volatile uint32_t RASR_A2;                  
N  __IO uint32_t RBAR_A3;                 /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address Register       */
X  volatile uint32_t RBAR_A3;                  
N  __IO uint32_t RASR_A3;                 /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and Size Register */
X  volatile uint32_t RASR_A3;                  
N} MPU_Type;
N
N/* MPU Type Register */
N#define MPU_TYPE_IREGION_Pos               16                                             /*!< MPU TYPE: IREGION Position */
N#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
N
N#define MPU_TYPE_DREGION_Pos                8                                             /*!< MPU TYPE: DREGION Position */
N#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
N
N#define MPU_TYPE_SEPARATE_Pos               0                                             /*!< MPU TYPE: SEPARATE Position */
N#define MPU_TYPE_SEPARATE_Msk              (1UL << MPU_TYPE_SEPARATE_Pos)                 /*!< MPU TYPE: SEPARATE Mask */
N
N/* MPU Control Register */
N#define MPU_CTRL_PRIVDEFENA_Pos             2                                             /*!< MPU CTRL: PRIVDEFENA Position */
N#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
N
N#define MPU_CTRL_HFNMIENA_Pos               1                                             /*!< MPU CTRL: HFNMIENA Position */
N#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
N
N#define MPU_CTRL_ENABLE_Pos                 0                                             /*!< MPU CTRL: ENABLE Position */
N#define MPU_CTRL_ENABLE_Msk                (1UL << MPU_CTRL_ENABLE_Pos)                   /*!< MPU CTRL: ENABLE Mask */
N
N/* MPU Region Number Register */
N#define MPU_RNR_REGION_Pos                  0                                             /*!< MPU RNR: REGION Position */
N#define MPU_RNR_REGION_Msk                 (0xFFUL << MPU_RNR_REGION_Pos)                 /*!< MPU RNR: REGION Mask */
N
N/* MPU Region Base Address Register */
N#define MPU_RBAR_ADDR_Pos                   5                                             /*!< MPU RBAR: ADDR Position */
N#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
N
N#define MPU_RBAR_VALID_Pos                  4                                             /*!< MPU RBAR: VALID Position */
N#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
N
N#define MPU_RBAR_REGION_Pos                 0                                             /*!< MPU RBAR: REGION Position */
N#define MPU_RBAR_REGION_Msk                (0xFUL << MPU_RBAR_REGION_Pos)                 /*!< MPU RBAR: REGION Mask */
N
N/* MPU Region Attribute and Size Register */
N#define MPU_RASR_ATTRS_Pos                 16                                             /*!< MPU RASR: MPU Region Attribute field Position */
N#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
N
N#define MPU_RASR_SRD_Pos                    8                                             /*!< MPU RASR: Sub-Region Disable Position */
N#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
N
N#define MPU_RASR_SIZE_Pos                   1                                             /*!< MPU RASR: Region Size Field Position */
N#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
N
N#define MPU_RASR_ENABLE_Pos                 0                                             /*!< MPU RASR: Region enable bit Position */
N#define MPU_RASR_ENABLE_Msk                (1UL << MPU_RASR_ENABLE_Pos)                   /*!< MPU RASR: Region enable bit Disable Mask */
N
N/*@} end of group CMSIS_MPU */
N#endif
N
N
N#if (__FPU_PRESENT == 1)
X#if (1 == 1)
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_FPU CMSIS FPU
N  Type definitions for the Cortex-M Floating Point Unit (FPU)
N  @{
N */
N
N/** \brief  Structure type to access the Floating Point Unit (FPU).
N */
Ntypedef struct
N{
N       uint32_t RESERVED0[1];
N  __IO uint32_t FPCCR;                   /*!< Offset: 0x004 (R/W)  Floating-Point Context Control Register               */
X  volatile uint32_t FPCCR;                    
N  __IO uint32_t FPCAR;                   /*!< Offset: 0x008 (R/W)  Floating-Point Context Address Register               */
X  volatile uint32_t FPCAR;                    
N  __IO uint32_t FPDSCR;                  /*!< Offset: 0x00C (R/W)  Floating-Point Default Status Control Register        */
X  volatile uint32_t FPDSCR;                   
N  __I  uint32_t MVFR0;                   /*!< Offset: 0x010 (R/ )  Media and FP Feature Register 0                       */
X  volatile const  uint32_t MVFR0;                    
N  __I  uint32_t MVFR1;                   /*!< Offset: 0x014 (R/ )  Media and FP Feature Register 1                       */
X  volatile const  uint32_t MVFR1;                    
N} FPU_Type;
N
N/* Floating-Point Context Control Register */
N#define FPU_FPCCR_ASPEN_Pos                31                                             /*!< FPCCR: ASPEN bit Position */
N#define FPU_FPCCR_ASPEN_Msk                (1UL << FPU_FPCCR_ASPEN_Pos)                   /*!< FPCCR: ASPEN bit Mask */
N
N#define FPU_FPCCR_LSPEN_Pos                30                                             /*!< FPCCR: LSPEN Position */
N#define FPU_FPCCR_LSPEN_Msk                (1UL << FPU_FPCCR_LSPEN_Pos)                   /*!< FPCCR: LSPEN bit Mask */
N
N#define FPU_FPCCR_MONRDY_Pos                8                                             /*!< FPCCR: MONRDY Position */
N#define FPU_FPCCR_MONRDY_Msk               (1UL << FPU_FPCCR_MONRDY_Pos)                  /*!< FPCCR: MONRDY bit Mask */
N
N#define FPU_FPCCR_BFRDY_Pos                 6                                             /*!< FPCCR: BFRDY Position */
N#define FPU_FPCCR_BFRDY_Msk                (1UL << FPU_FPCCR_BFRDY_Pos)                   /*!< FPCCR: BFRDY bit Mask */
N
N#define FPU_FPCCR_MMRDY_Pos                 5                                             /*!< FPCCR: MMRDY Position */
N#define FPU_FPCCR_MMRDY_Msk                (1UL << FPU_FPCCR_MMRDY_Pos)                   /*!< FPCCR: MMRDY bit Mask */
N
N#define FPU_FPCCR_HFRDY_Pos                 4                                             /*!< FPCCR: HFRDY Position */
N#define FPU_FPCCR_HFRDY_Msk                (1UL << FPU_FPCCR_HFRDY_Pos)                   /*!< FPCCR: HFRDY bit Mask */
N
N#define FPU_FPCCR_THREAD_Pos                3                                             /*!< FPCCR: processor mode bit Position */
N#define FPU_FPCCR_THREAD_Msk               (1UL << FPU_FPCCR_THREAD_Pos)                  /*!< FPCCR: processor mode active bit Mask */
N
N#define FPU_FPCCR_USER_Pos                  1                                             /*!< FPCCR: privilege level bit Position */
N#define FPU_FPCCR_USER_Msk                 (1UL << FPU_FPCCR_USER_Pos)                    /*!< FPCCR: privilege level bit Mask */
N
N#define FPU_FPCCR_LSPACT_Pos                0                                             /*!< FPCCR: Lazy state preservation active bit Position */
N#define FPU_FPCCR_LSPACT_Msk               (1UL << FPU_FPCCR_LSPACT_Pos)                  /*!< FPCCR: Lazy state preservation active bit Mask */
N
N/* Floating-Point Context Address Register */
N#define FPU_FPCAR_ADDRESS_Pos               3                                             /*!< FPCAR: ADDRESS bit Position */
N#define FPU_FPCAR_ADDRESS_Msk              (0x1FFFFFFFUL << FPU_FPCAR_ADDRESS_Pos)        /*!< FPCAR: ADDRESS bit Mask */
N
N/* Floating-Point Default Status Control Register */
N#define FPU_FPDSCR_AHP_Pos                 26                                             /*!< FPDSCR: AHP bit Position */
N#define FPU_FPDSCR_AHP_Msk                 (1UL << FPU_FPDSCR_AHP_Pos)                    /*!< FPDSCR: AHP bit Mask */
N
N#define FPU_FPDSCR_DN_Pos                  25                                             /*!< FPDSCR: DN bit Position */
N#define FPU_FPDSCR_DN_Msk                  (1UL << FPU_FPDSCR_DN_Pos)                     /*!< FPDSCR: DN bit Mask */
N
N#define FPU_FPDSCR_FZ_Pos                  24                                             /*!< FPDSCR: FZ bit Position */
N#define FPU_FPDSCR_FZ_Msk                  (1UL << FPU_FPDSCR_FZ_Pos)                     /*!< FPDSCR: FZ bit Mask */
N
N#define FPU_FPDSCR_RMode_Pos               22                                             /*!< FPDSCR: RMode bit Position */
N#define FPU_FPDSCR_RMode_Msk               (3UL << FPU_FPDSCR_RMode_Pos)                  /*!< FPDSCR: RMode bit Mask */
N
N/* Media and FP Feature Register 0 */
N#define FPU_MVFR0_FP_rounding_modes_Pos    28                                             /*!< MVFR0: FP rounding modes bits Position */
N#define FPU_MVFR0_FP_rounding_modes_Msk    (0xFUL << FPU_MVFR0_FP_rounding_modes_Pos)     /*!< MVFR0: FP rounding modes bits Mask */
N
N#define FPU_MVFR0_Short_vectors_Pos        24                                             /*!< MVFR0: Short vectors bits Position */
N#define FPU_MVFR0_Short_vectors_Msk        (0xFUL << FPU_MVFR0_Short_vectors_Pos)         /*!< MVFR0: Short vectors bits Mask */
N
N#define FPU_MVFR0_Square_root_Pos          20                                             /*!< MVFR0: Square root bits Position */
N#define FPU_MVFR0_Square_root_Msk          (0xFUL << FPU_MVFR0_Square_root_Pos)           /*!< MVFR0: Square root bits Mask */
N
N#define FPU_MVFR0_Divide_Pos               16                                             /*!< MVFR0: Divide bits Position */
N#define FPU_MVFR0_Divide_Msk               (0xFUL << FPU_MVFR0_Divide_Pos)                /*!< MVFR0: Divide bits Mask */
N
N#define FPU_MVFR0_FP_excep_trapping_Pos    12                                             /*!< MVFR0: FP exception trapping bits Position */
N#define FPU_MVFR0_FP_excep_trapping_Msk    (0xFUL << FPU_MVFR0_FP_excep_trapping_Pos)     /*!< MVFR0: FP exception trapping bits Mask */
N
N#define FPU_MVFR0_Double_precision_Pos      8                                             /*!< MVFR0: Double-precision bits Position */
N#define FPU_MVFR0_Double_precision_Msk     (0xFUL << FPU_MVFR0_Double_precision_Pos)      /*!< MVFR0: Double-precision bits Mask */
N
N#define FPU_MVFR0_Single_precision_Pos      4                                             /*!< MVFR0: Single-precision bits Position */
N#define FPU_MVFR0_Single_precision_Msk     (0xFUL << FPU_MVFR0_Single_precision_Pos)      /*!< MVFR0: Single-precision bits Mask */
N
N#define FPU_MVFR0_A_SIMD_registers_Pos      0                                             /*!< MVFR0: A_SIMD registers bits Position */
N#define FPU_MVFR0_A_SIMD_registers_Msk     (0xFUL << FPU_MVFR0_A_SIMD_registers_Pos)      /*!< MVFR0: A_SIMD registers bits Mask */
N
N/* Media and FP Feature Register 1 */
N#define FPU_MVFR1_FP_fused_MAC_Pos         28                                             /*!< MVFR1: FP fused MAC bits Position */
N#define FPU_MVFR1_FP_fused_MAC_Msk         (0xFUL << FPU_MVFR1_FP_fused_MAC_Pos)          /*!< MVFR1: FP fused MAC bits Mask */
N
N#define FPU_MVFR1_FP_HPFP_Pos              24                                             /*!< MVFR1: FP HPFP bits Position */
N#define FPU_MVFR1_FP_HPFP_Msk              (0xFUL << FPU_MVFR1_FP_HPFP_Pos)               /*!< MVFR1: FP HPFP bits Mask */
N
N#define FPU_MVFR1_D_NaN_mode_Pos            4                                             /*!< MVFR1: D_NaN mode bits Position */
N#define FPU_MVFR1_D_NaN_mode_Msk           (0xFUL << FPU_MVFR1_D_NaN_mode_Pos)            /*!< MVFR1: D_NaN mode bits Mask */
N
N#define FPU_MVFR1_FtZ_mode_Pos              0                                             /*!< MVFR1: FtZ mode bits Position */
N#define FPU_MVFR1_FtZ_mode_Msk             (0xFUL << FPU_MVFR1_FtZ_mode_Pos)              /*!< MVFR1: FtZ mode bits Mask */
N
N/*@} end of group CMSIS_FPU */
N#endif
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_CoreDebug CMSIS Core Debug
N  Type definitions for the Cortex-M Core Debug Registers
N  @{
N */
N
N/** \brief  Structure type to access the Core Debug Register (CoreDebug).
N */
Ntypedef struct
N{
N  __IO uint32_t DHCSR;                   /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register    */
X  volatile uint32_t DHCSR;                    
N  __O  uint32_t DCRSR;                   /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register        */
X  volatile  uint32_t DCRSR;                    
N  __IO uint32_t DCRDR;                   /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register            */
X  volatile uint32_t DCRDR;                    
N  __IO uint32_t DEMCR;                   /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
X  volatile uint32_t DEMCR;                    
N} CoreDebug_Type;
N
N/* Debug Halting Control and Status Register */
N#define CoreDebug_DHCSR_DBGKEY_Pos         16                                             /*!< CoreDebug DHCSR: DBGKEY Position */
N#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
N
N#define CoreDebug_DHCSR_S_RESET_ST_Pos     25                                             /*!< CoreDebug DHCSR: S_RESET_ST Position */
N#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
N
N#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24                                             /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
N#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
N
N#define CoreDebug_DHCSR_S_LOCKUP_Pos       19                                             /*!< CoreDebug DHCSR: S_LOCKUP Position */
N#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
N
N#define CoreDebug_DHCSR_S_SLEEP_Pos        18                                             /*!< CoreDebug DHCSR: S_SLEEP Position */
N#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
N
N#define CoreDebug_DHCSR_S_HALT_Pos         17                                             /*!< CoreDebug DHCSR: S_HALT Position */
N#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
N
N#define CoreDebug_DHCSR_S_REGRDY_Pos       16                                             /*!< CoreDebug DHCSR: S_REGRDY Position */
N#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
N
N#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5                                             /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
N#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
N
N#define CoreDebug_DHCSR_C_MASKINTS_Pos      3                                             /*!< CoreDebug DHCSR: C_MASKINTS Position */
N#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
N
N#define CoreDebug_DHCSR_C_STEP_Pos          2                                             /*!< CoreDebug DHCSR: C_STEP Position */
N#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
N
N#define CoreDebug_DHCSR_C_HALT_Pos          1                                             /*!< CoreDebug DHCSR: C_HALT Position */
N#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
N
N#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0                                             /*!< CoreDebug DHCSR: C_DEBUGEN Position */
N#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL << CoreDebug_DHCSR_C_DEBUGEN_Pos)         /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
N
N/* Debug Core Register Selector Register */
N#define CoreDebug_DCRSR_REGWnR_Pos         16                                             /*!< CoreDebug DCRSR: REGWnR Position */
N#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
N
N#define CoreDebug_DCRSR_REGSEL_Pos          0                                             /*!< CoreDebug DCRSR: REGSEL Position */
N#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL << CoreDebug_DCRSR_REGSEL_Pos)         /*!< CoreDebug DCRSR: REGSEL Mask */
N
N/* Debug Exception and Monitor Control Register */
N#define CoreDebug_DEMCR_TRCENA_Pos         24                                             /*!< CoreDebug DEMCR: TRCENA Position */
N#define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
N
N#define CoreDebug_DEMCR_MON_REQ_Pos        19                                             /*!< CoreDebug DEMCR: MON_REQ Position */
N#define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
N
N#define CoreDebug_DEMCR_MON_STEP_Pos       18                                             /*!< CoreDebug DEMCR: MON_STEP Position */
N#define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
N
N#define CoreDebug_DEMCR_MON_PEND_Pos       17                                             /*!< CoreDebug DEMCR: MON_PEND Position */
N#define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
N
N#define CoreDebug_DEMCR_MON_EN_Pos         16                                             /*!< CoreDebug DEMCR: MON_EN Position */
N#define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
N
N#define CoreDebug_DEMCR_VC_HARDERR_Pos     10                                             /*!< CoreDebug DEMCR: VC_HARDERR Position */
N#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
N
N#define CoreDebug_DEMCR_VC_INTERR_Pos       9                                             /*!< CoreDebug DEMCR: VC_INTERR Position */
N#define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
N
N#define CoreDebug_DEMCR_VC_BUSERR_Pos       8                                             /*!< CoreDebug DEMCR: VC_BUSERR Position */
N#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
N
N#define CoreDebug_DEMCR_VC_STATERR_Pos      7                                             /*!< CoreDebug DEMCR: VC_STATERR Position */
N#define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
N
N#define CoreDebug_DEMCR_VC_CHKERR_Pos       6                                             /*!< CoreDebug DEMCR: VC_CHKERR Position */
N#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
N
N#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5                                             /*!< CoreDebug DEMCR: VC_NOCPERR Position */
N#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
N
N#define CoreDebug_DEMCR_VC_MMERR_Pos        4                                             /*!< CoreDebug DEMCR: VC_MMERR Position */
N#define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
N
N#define CoreDebug_DEMCR_VC_CORERESET_Pos    0                                             /*!< CoreDebug DEMCR: VC_CORERESET Position */
N#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL << CoreDebug_DEMCR_VC_CORERESET_Pos)      /*!< CoreDebug DEMCR: VC_CORERESET Mask */
N
N/*@} end of group CMSIS_CoreDebug */
N
N
N/** \ingroup  CMSIS_core_register
N  @{
N */
N
N/* Memory mapping of Cortex-M4 Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address  */
N#define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address                   */
N#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address            */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address               */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address                  */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address  */
N
N#define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register not in SCB */
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct           */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct       */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct          */
N#define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct           */
N#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct    */
N
N#if (__MPU_PRESENT == 1)
X#if (1 == 1)
N  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit             */
N  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit             */
N#endif
N
N#if (__FPU_PRESENT == 1)
X#if (1 == 1)
N  #define FPU_BASE          (SCS_BASE +  0x0F30UL)                    /*!< Floating Point Unit                */
N  #define FPU               ((FPU_Type       *)     FPU_BASE      )   /*!< Floating Point Unit                */
N#endif
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N ******************************************************************************/
N/** \defgroup CMSIS_Core_FunctionInterface CMSIS Core Function Interface
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Debug Functions
N  - Core Register Access Functions
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_NVICFunctions CMSIS Core NVIC Functions
N  @{
N */
N
N/** \brief  Set Priority Grouping
N
N  This function sets the priority grouping field using the required unlock sequence.
N  The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
N  Only values from 0..7 are used.
N  In case of a conflict between priority grouping and available
N  priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
N
N    \param [in]      PriorityGroup  Priority grouping field
N */
Nstatic __INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
Xstatic __inline void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
N{
N  uint32_t reg_value;
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */
N
N  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
X  reg_value  =  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR;                                                    
N  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
X  reg_value &= ~((0xFFFFUL << 16) | (7UL << 8));              
N  reg_value  =  (reg_value                                 |
N                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
X                ((uint32_t)0x5FA << 16) |
N                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
N  SCB->AIRCR =  reg_value;
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR =  reg_value;
N}
N
N
N/** \brief  Get Priority Grouping
N
N  This function gets the priority grouping from NVIC Interrupt Controller.
N  Priority grouping is SCB->AIRCR [10:8] PRIGROUP field.
N
N    \return                Priority grouping field
N */
Nstatic __INLINE uint32_t NVIC_GetPriorityGrouping(void)
Xstatic __inline uint32_t NVIC_GetPriorityGrouping(void)
N{
N  return ((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos);   /* read priority grouping field */
X  return ((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8)) >> 8);    
N}
N
N
N/** \brief  Enable External Interrupt
N
N    This function enables a device specific interrupt in the NVIC interrupt controller.
N    The interrupt number cannot be a negative value.
N
N    \param [in]      IRQn  Number of the external interrupt to enable
N */
Nstatic __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
N  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F));  
N}
N
N
N/** \brief  Disable External Interrupt
N
N    This function disables a device specific interrupt in the NVIC interrupt controller.
N    The interrupt number cannot be a negative value.
N
N    \param [in]      IRQn  Number of the external interrupt to disable
N */
Nstatic __INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N
N/** \brief  Get Pending Interrupt
N
N    This function reads the pending register in the NVIC and returns the pending bit
N    for the specified interrupt.
N
N    \param [in]      IRQn  Number of the interrupt for get pending
N    \return             0  Interrupt status is not pending
N    \return             1  Interrupt status is pending
N */
Nstatic __INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t) ((NVIC->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if pending else 0 */
X  return((uint32_t) ((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));  
N}
N
N
N/** \brief  Set Pending Interrupt
N
N    This function sets the pending bit for the specified interrupt.
N    The interrupt number cannot be a negative value.
N
N    \param [in]      IRQn  Number of the interrupt for set pending
N */
Nstatic __INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* set interrupt pending */
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N
N/** \brief  Clear Pending Interrupt
N
N    This function clears the pending bit for the specified interrupt.
N    The interrupt number cannot be a negative value.
N
N    \param [in]      IRQn  Number of the interrupt for clear pending
N */
Nstatic __INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N
N/** \brief  Get Active Interrupt
N
N    This function reads the active register in NVIC and returns the active bit.
N    \param [in]      IRQn  Number of the interrupt for get active
N    \return             0  Interrupt status is not active
N    \return             1  Interrupt status is active
N */
Nstatic __INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetActive(IRQn_Type IRQn)
N{
N  return((uint32_t)((NVIC->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if active else 0 */
X  return((uint32_t)((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));  
N}
N
N
N/** \brief  Set Interrupt Priority
N
N    This function sets the priority for the specified interrupt. The interrupt
N    number can be positive to specify an external (device specific)
N    interrupt, or negative to specify an internal (core) interrupt.
N
N    Note: The priority cannot be set for every core interrupt.
N
N    \param [in]      IRQn  Number of the interrupt for set priority
N    \param [in]  priority  Priority to set
N */
Nstatic __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if(IRQn < 0) {
N    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - 5)) & 0xff); }  
N  else {
N    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[(uint32_t)(IRQn)] = ((priority << (8 - 5)) & 0xff);    }         
N}
N
N
N/** \brief  Get Interrupt Priority
N
N    This function reads the priority for the specified interrupt. The interrupt
N    number can be positive to specify an external (device specific)
N    interrupt, or negative to specify an internal (core) interrupt.
N
N    The returned priority value is automatically aligned to the implemented
N    priority bits of the microcontroller.
N
N    \param [in]   IRQn  Number of the interrupt for get priority
N    \return             Interrupt Priority
N */
Nstatic __INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if(IRQn < 0) {
N    return((uint32_t)(SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M  system interrupts */
X    return((uint32_t)(((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - 5)));  }  
N  else {
N    return((uint32_t)(NVIC->IP[(uint32_t)(IRQn)]           >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
X    return((uint32_t)(((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[(uint32_t)(IRQn)]           >> (8 - 5)));  }  
N}
N
N
N/** \brief  Encode Priority
N
N    This function encodes the priority for an interrupt with the given priority group,
N    preemptive priority value and sub priority value.
N    In case of a conflict between priority grouping and available
N    priority bits (__NVIC_PRIO_BITS) the samllest possible priority group is set.
N
N    The returned priority value can be used for NVIC_SetPriority(...) function
N
N    \param [in]     PriorityGroup  Used priority group
N    \param [in]   PreemptPriority  Preemptive priority value (starting from 0)
N    \param [in]       SubPriority  Sub priority value (starting from 0)
N    \return                        Encoded priority for the interrupt
N */
Nstatic __INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
Xstatic __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
X  PreemptPriorityBits = ((7 - PriorityGroupTmp) > 5) ? 5 : 7 - PriorityGroupTmp;
N  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
X  SubPriorityBits     = ((PriorityGroupTmp + 5) < 7) ? 0 : PriorityGroupTmp - 7 + 5;
N
N  return (
N           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
N           ((SubPriority     & ((1 << (SubPriorityBits    )) - 1)))
N         );
N}
N
N
N/** \brief  Decode Priority
N
N    This function decodes an interrupt priority value with the given priority group to
N    preemptive priority value and sub priority value.
N    In case of a conflict between priority grouping and available
N    priority bits (__NVIC_PRIO_BITS) the samllest possible priority group is set.
N
N    The priority value can be retrieved with NVIC_GetPriority(...) function
N
N    \param [in]         Priority   Priority value
N    \param [in]     PriorityGroup  Used priority group
N    \param [out] pPreemptPriority  Preemptive priority value (starting from 0)
N    \param [out]     pSubPriority  Sub priority value (starting from 0)
N */
Nstatic __INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
Xstatic __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
X  PreemptPriorityBits = ((7 - PriorityGroupTmp) > 5) ? 5 : 7 - PriorityGroupTmp;
N  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
X  SubPriorityBits     = ((PriorityGroupTmp + 5) < 7) ? 0 : PriorityGroupTmp - 7 + 5;
N
N  *pPreemptPriority = (Priority >> SubPriorityBits) & ((1 << (PreemptPriorityBits)) - 1);
N  *pSubPriority     = (Priority                   ) & ((1 << (SubPriorityBits    )) - 1);
N}
N
N
N/** \brief  System Reset
N
N    This function initiate a system reset request to reset the MCU.
N */
Nstatic __INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  __DSB();                                                     /* Ensure all outstanding memory accesses included
X  __dsb(0xF);                                                     
N                                                                  buffered write are completed before reset */
N  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = ((0x5FA << 16)      |
N                 (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
X                 (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8)) |
N                 SCB_AIRCR_SYSRESETREQ_Msk);                   /* Keep priority group unchanged */
X                 (1UL << 2));                    
N  __DSB();                                                     /* Ensure completion of memory access */
X  __dsb(0xF);                                                      
N  while(1);                                                    /* wait until reset */
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_SysTickFunctions CMSIS Core SysTick Functions
N  @{
N */
N
N#if (__Vendor_SysTickConfig == 0)
X#if (0 == 0)
N
N/** \brief  System Tick Configuration
N
N    This function initialises the system tick timer and its interrupt and start the system tick timer.
N    Counter is in free running mode to generate periodical interrupts.
N
N    \param [in]  ticks  Number of ticks between two interrupts
N    \return          0  Function succeeded
N    \return          1  Function failed
N */
Nstatic __INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */
X  if (ticks > (0xFFFFFFUL << 0))  return (1);             
N
N  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (ticks & (0xFFFFFFUL << 0)) - 1;       
N  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Cortex-M0 System Interrupts */
X  NVIC_SetPriority (SysTick_IRQn, (1<<5) - 1);   
N  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0;                                           
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1)   |
N                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL << 0);                     
N  return (0);                                                  /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N/* ##################################### Debug In/Output function ########################################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_core_DebugFunctions CMSIS Core Debug Functions
N  @{
N */
N
Nextern volatile int32_t ITM_RxBuffer;                    /*!< external variable to receive characters                    */
N#define                 ITM_RXBUFFER_EMPTY    0x5AA55AA5 /*!< value identifying ITM_RxBuffer is ready for next character */
N
N
N/** \brief  ITM Send Character
N
N    This function transmits a character via the ITM channel 0.
N    It just returns when no debugger is connected that has booked the output.
N    It is blocking when a debugger is connected, but the previous character send is not transmitted.
N
N    \param [in]     ch  Character to transmit
N    \return             Character to transmit
N */
Nstatic __INLINE uint32_t ITM_SendChar (uint32_t ch)
Xstatic __inline uint32_t ITM_SendChar (uint32_t ch)
N{
N  if ((CoreDebug->DEMCR & CoreDebug_DEMCR_TRCENA_Msk)  &&      /* Trace enabled */
X  if ((((CoreDebug_Type *) (0xE000EDF0UL))->DEMCR & (1UL << 24))  &&       
N      (ITM->TCR & ITM_TCR_ITMENA_Msk)                  &&      /* ITM enabled */
X      (((ITM_Type *) (0xE0000000UL) )->TCR & (1UL << 0))                  &&       
N      (ITM->TER & (1UL << 0)        )                    )     /* ITM Port #0 enabled */
X      (((ITM_Type *) (0xE0000000UL) )->TER & (1UL << 0)        )                    )      
N  {
N    while (ITM->PORT[0].u32 == 0);
X    while (((ITM_Type *) (0xE0000000UL) )->PORT[0].u32 == 0);
N    ITM->PORT[0].u8 = (uint8_t) ch;
X    ((ITM_Type *) (0xE0000000UL) )->PORT[0].u8 = (uint8_t) ch;
N  }
N  return (ch);
N}
N
N
N/** \brief  ITM Receive Character
N
N    This function inputs a character via external variable ITM_RxBuffer.
N    It just returns when no debugger is connected that has booked the output.
N    It is blocking when a debugger is connected, but the previous character send is not transmitted.
N
N    \return             Received character
N    \return         -1  No character received
N */
Nstatic __INLINE int32_t ITM_ReceiveChar (void) {
Xstatic __inline int32_t ITM_ReceiveChar (void) {
N  int32_t ch = -1;                           /* no character available */
N
N  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY) {
X  if (ITM_RxBuffer != 0x5AA55AA5) {
N    ch = ITM_RxBuffer;
N    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
X    ITM_RxBuffer = 0x5AA55AA5;        
N  }
N
N  return (ch);
N}
N
N
N/** \brief  ITM Check Character
N
N    This function checks external variable ITM_RxBuffer whether a character is available or not.
N    It returns '1' if a character is available and '0' if no character is available.
N
N    \return          0  No character available
N    \return          1  Character available
N */
Nstatic __INLINE int32_t ITM_CheckChar (void) {
Xstatic __inline int32_t ITM_CheckChar (void) {
N
N  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY) {
X  if (ITM_RxBuffer == 0x5AA55AA5) {
N    return (0);                                 /* no character available */
N  } else {
N    return (1);                                 /*    character available */
N  }
N}
N
N/*@} end of CMSIS_core_DebugFunctions */
N
N#endif /* __CORE_CM4_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
N
N#ifdef __cplusplus
S}
N#endif
L 114 ".\Core\Device\NXP\LPC407x_8x_177x_8x\Include\LPC407x_8x_177x_8x.h" 2
N#else
S/* Configuration of the Cortex-M3 Processor and Core Peripherals */
S#define __MPU_PRESENT             1         /*!< MPU present or not                               */
S#define __NVIC_PRIO_BITS          5         /*!< Number of Bits used for Priority Levels          */
S#define __Vendor_SysTickConfig    0         /*!< Set to 1 if different SysTick Config is used     */
S
S
S#include "core_cm3.h"                       /* Cortex-M3 processor and core peripherals           */
S
N#endif
N
N#include "system_LPC407x_8x_177x_8x.h"                      /*!< LPC408x_7x System                                                     */
L 1 ".\Core\Device\NXP\LPC407x_8x_177x_8x\Include\system_LPC407x_8x_177x_8x.h" 1
N/**********************************************************************
N* $Id: system_LPC407x_8x_177x_8x.h 3001 2013-01-23 21:47:55Z andy $		system_LPC407x_8x_177x_8x.h			2011-06-02
N*//**
N* @file		system_LPC407x_8x_177x_8x.h
N* @brief	CMSIS Cortex-M3 Device Peripheral Access Layer Source File
N*			for the NXP LPC Device Series
N* @version	1.0
N* @date		02. June. 2011
N* @author	NXP MCU SW Application Team
N* 
N* Copyright(C) 2011, NXP Semiconductor
N* All rights reserved.
N*
N***********************************************************************
N* Software that is described herein is for illustrative purposes only
N* which provides customers with programming information regarding the
N* products. This software is supplied "AS IS" without any warranties.
N* NXP Semiconductors assumes no responsibility or liability for the
N* use of the software, conveys no license or title under any patent,
N* copyright, or mask work right to the product. NXP Semiconductors
N* reserves the right to make changes in the software without
N* notification. NXP Semiconductors also make no representation or
N* warranty that such application will be suitable for the specified
N* use without further testing or modification.
N* Permission to use, copy, modify, and distribute this software and its
N* documentation is hereby granted, under NXP Semiconductors'
N* relevant copyright in the software, without fee, provided that it
N* is used in conjunction with NXP Semiconductors microcontrollers.  This
N* copyright, permission, and disclaimer notice must appear in all copies of
N* this code.
N**********************************************************************/
N
N#ifndef __SYSTEM_LPC407x_8x_177x_8x_H
N#define __SYSTEM_LPC407x_8x_177x_8x_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include <stdint.h>
N
Nextern uint32_t SystemCoreClock;      /*!< System Clock Frequency (Core Clock)  	*/
Nextern uint32_t PeripheralClock;	    /*!< Peripheral Clock Frequency (Pclk) 	    */
Nextern uint32_t EMCClock;			        /*!< EMC Clock                              */
Nextern uint32_t USBClock;			        /*!< USB Frequency 						              */
N
N
N/**
N * Initialize the system
N *
N * @param  none
N * @return none
N *
N * @brief  Setup the microcontroller system.
N *         Initialize the System and update the SystemCoreClock variable.
N */
Nextern void SystemInit (void);
N
N/**
N * Update SystemCoreClock variable
N *
N * @param  none
N * @return none
N *
N * @brief  Updates the SystemCoreClock with current core Clock
N *         retrieved from cpu registers.
N */
Nextern void SystemCoreClockUpdate (void);
N
N/*----------------------------------------------------------------------------
N  Define clocks
N *----------------------------------------------------------------------------*/
N#define XTAL        (12000000UL)        /* Oscillator frequency               */
N#define OSC_CLK     (      XTAL)        /* Main oscillator frequency          */
N#define RTC_CLK     (   32768UL)        /* RTC oscillator frequency           */
N#define IRC_OSC     (12000000UL)        /* Internal RC oscillator frequency   */
N#define WDT_OSC		  (  500000UL)		/* Internal WDT oscillator frequency  */
N
N
N
N/*
N//-------- <<< end of configuration section >>> ------------------------------
N*/
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __SYSTEM_LPC407x_8x_177x_8x_H */
L 126 ".\Core\Device\NXP\LPC407x_8x_177x_8x\Include\LPC407x_8x_177x_8x.h" 2
N
N
N
N
N/* ================================================================================ */
N/* ================       Device Specific Peripheral Section       ================ */
N/* ================================================================================ */
N
N#if defined ( __CC_ARM   )
X#if 1L
N#pragma anon_unions
N#elif defined ( __ICCARM__ )
S#pragma language=save
S#pragma language=extended
N#endif
N
N/*------------- General Purpose Direct Memory Access (GPDMA) -----------------*/
Ntypedef struct                          /* Common Registers                   */
N{
N  __I  uint32_t IntStat;
X  volatile const  uint32_t IntStat;
N  __I  uint32_t IntTCStat;
X  volatile const  uint32_t IntTCStat;
N  __O  uint32_t IntTCClear;
X  volatile  uint32_t IntTCClear;
N  __I  uint32_t IntErrStat;
X  volatile const  uint32_t IntErrStat;
N  __O  uint32_t IntErrClr;
X  volatile  uint32_t IntErrClr;
N  __I  uint32_t RawIntTCStat;
X  volatile const  uint32_t RawIntTCStat;
N  __I  uint32_t RawIntErrStat;
X  volatile const  uint32_t RawIntErrStat;
N  __I  uint32_t EnbldChns;
X  volatile const  uint32_t EnbldChns;
N  __IO uint32_t SoftBReq;
X  volatile uint32_t SoftBReq;
N  __IO uint32_t SoftSReq;
X  volatile uint32_t SoftSReq;
N  __IO uint32_t SoftLBReq;
X  volatile uint32_t SoftLBReq;
N  __IO uint32_t SoftLSReq;
X  volatile uint32_t SoftLSReq;
N  __IO uint32_t Config;
X  volatile uint32_t Config;
N  __IO uint32_t Sync;
X  volatile uint32_t Sync;
N} LPC_GPDMA_TypeDef;
N
Ntypedef struct                          /* Channel Registers                  */
N{
N  __IO uint32_t CSrcAddr;
X  volatile uint32_t CSrcAddr;
N  __IO uint32_t CDestAddr;
X  volatile uint32_t CDestAddr;
N  __IO uint32_t CLLI;
X  volatile uint32_t CLLI;
N  __IO uint32_t CControl;
X  volatile uint32_t CControl;
N  __IO uint32_t CConfig;
X  volatile uint32_t CConfig;
N} LPC_GPDMACH_TypeDef;
N
N/*------------- System Control (SC) ------------------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t FLASHCFG;                   /*!< Offset: 0x000 (R/W)  Flash Accelerator Configuration Register */
X  volatile uint32_t FLASHCFG;                    
N       uint32_t RESERVED0[31];
N  __IO uint32_t PLL0CON;                    /*!< Offset: 0x080 (R/W)  PLL0 Control Register */
X  volatile uint32_t PLL0CON;                     
N  __IO uint32_t PLL0CFG;                    /*!< Offset: 0x084 (R/W)  PLL0 Configuration Register */
X  volatile uint32_t PLL0CFG;                     
N  __I  uint32_t PLL0STAT;                   /*!< Offset: 0x088 (R/ )  PLL0 Status Register */
X  volatile const  uint32_t PLL0STAT;                    
N  __O  uint32_t PLL0FEED;                   /*!< Offset: 0x08C ( /W)  PLL0 Feed Register */
X  volatile  uint32_t PLL0FEED;                    
N       uint32_t RESERVED1[4];
N  __IO uint32_t PLL1CON;                    /*!< Offset: 0x0A0 (R/W)  PLL1 Control Register */
X  volatile uint32_t PLL1CON;                     
N  __IO uint32_t PLL1CFG;                    /*!< Offset: 0x0A4 (R/W)  PLL1 Configuration Register */
X  volatile uint32_t PLL1CFG;                     
N  __I  uint32_t PLL1STAT;                   /*!< Offset: 0x0A8 (R/ )  PLL1 Status Register */
X  volatile const  uint32_t PLL1STAT;                    
N  __O  uint32_t PLL1FEED;                   /*!< Offset: 0x0AC ( /W)  PLL1 Feed Register */
X  volatile  uint32_t PLL1FEED;                    
N       uint32_t RESERVED2[4];
N  __IO uint32_t PCON;                       /*!< Offset: 0x0C0 (R/W)  Power Control Register */
X  volatile uint32_t PCON;                        
N  __IO uint32_t PCONP;                      /*!< Offset: 0x0C4 (R/W)  Power Control for Peripherals Register */
X  volatile uint32_t PCONP;                       
N  __IO uint32_t PCONP1;                      /*!< Offset: 0x0C8 (R/W)  Power Control for Peripherals Register */
X  volatile uint32_t PCONP1;                       
N       uint32_t RESERVED3[13];
N  __IO uint32_t EMCCLKSEL;                  /*!< Offset: 0x100 (R/W)  External Memory Controller Clock Selection Register */
X  volatile uint32_t EMCCLKSEL;                   
N  __IO uint32_t CCLKSEL;                    /*!< Offset: 0x104 (R/W)  CPU Clock Selection Register */
X  volatile uint32_t CCLKSEL;                     
N  __IO uint32_t USBCLKSEL;                  /*!< Offset: 0x108 (R/W)  USB Clock Selection Register */
X  volatile uint32_t USBCLKSEL;                   
N  __IO uint32_t CLKSRCSEL;                  /*!< Offset: 0x10C (R/W)  Clock Source Select Register */
X  volatile uint32_t CLKSRCSEL;                   
N  __IO uint32_t	CANSLEEPCLR;                /*!< Offset: 0x110 (R/W)  CAN Sleep Clear Register */
X  volatile uint32_t	CANSLEEPCLR;                 
N  __IO uint32_t	CANWAKEFLAGS;               /*!< Offset: 0x114 (R/W)  CAN Wake-up Flags Register */
X  volatile uint32_t	CANWAKEFLAGS;                
N       uint32_t RESERVED4[10];
N  __IO uint32_t EXTINT;                     /*!< Offset: 0x140 (R/W)  External Interrupt Flag Register */
X  volatile uint32_t EXTINT;                      
N       uint32_t RESERVED5[1];
N  __IO uint32_t EXTMODE;                    /*!< Offset: 0x148 (R/W)  External Interrupt Mode Register */
X  volatile uint32_t EXTMODE;                     
N  __IO uint32_t EXTPOLAR;                   /*!< Offset: 0x14C (R/W)  External Interrupt Polarity Register */
X  volatile uint32_t EXTPOLAR;                    
N       uint32_t RESERVED6[12];
N  __IO uint32_t RSID;                       /*!< Offset: 0x180 (R/W)  Reset Source Identification Register */
X  volatile uint32_t RSID;                        
N       uint32_t RESERVED7[7];
N  __IO uint32_t SCS;                        /*!< Offset: 0x1A0 (R/W)  System Controls and Status Register */
X  volatile uint32_t SCS;                         
N  __IO uint32_t IRCTRIM;                    /*!< Offset: 0x1A4 (R/W) Clock Dividers                     */
X  volatile uint32_t IRCTRIM;                     
N  __IO uint32_t PCLKSEL;                    /*!< Offset: 0x1A8 (R/W)  Peripheral Clock Selection Register */
X  volatile uint32_t PCLKSEL;                     
N       uint32_t RESERVED8;					
N  __IO uint32_t PBOOST;						/*!< Offset: 0x1B0 (R/W)  Power Boost control register */	   
X  volatile uint32_t PBOOST;						 	   
N  __IO uint32_t SPIFICLKSEL;					
X  volatile uint32_t SPIFICLKSEL;					
N  __IO uint32_t LCD_CFG;                    /*!< Offset: 0x1B8 (R/W)  LCD Configuration and clocking control Register */
X  volatile uint32_t LCD_CFG;                     
N       uint32_t RESERVED10[1];
N  __IO uint32_t USBIntSt;                   /*!< Offset: 0x1C0 (R/W)  USB Interrupt Status Register */
X  volatile uint32_t USBIntSt;                    
N  __IO uint32_t DMAREQSEL;                  /*!< Offset: 0x1C4 (R/W)  DMA Request Select Register */
X  volatile uint32_t DMAREQSEL;                   
N  __IO uint32_t CLKOUTCFG;                  /*!< Offset: 0x1C8 (R/W)  Clock Output Configuration Register */
X  volatile uint32_t CLKOUTCFG;                   
N  __IO uint32_t RSTCON0;                    /*!< Offset: 0x1CC (R/W)  RESET Control0 Register */
X  volatile uint32_t RSTCON0;                     
N  __IO uint32_t RSTCON1;                    /*!< Offset: 0x1D0 (R/W)  RESET Control1 Register */
X  volatile uint32_t RSTCON1;                     
N       uint32_t RESERVED11[2];
N  __IO uint32_t EMCDLYCTL;                  /*!< Offset: 0x1DC (R/W) SDRAM programmable delays          */
X  volatile uint32_t EMCDLYCTL;                   
N  __IO uint32_t EMCCAL;                     /*!< Offset: 0x1E0 (R/W) Calibration of programmable delays */
X  volatile uint32_t EMCCAL;                      
N } LPC_SC_TypeDef;
N/*------------- Ethernet Media Access Controller (EMAC) ----------------------*/
Ntypedef struct
N{
N  __IO uint32_t MAC1;                   /* MAC Registers                      */
X  volatile uint32_t MAC1;                    
N  __IO uint32_t MAC2;
X  volatile uint32_t MAC2;
N  __IO uint32_t IPGT;
X  volatile uint32_t IPGT;
N  __IO uint32_t IPGR;
X  volatile uint32_t IPGR;
N  __IO uint32_t CLRT;
X  volatile uint32_t CLRT;
N  __IO uint32_t MAXF;
X  volatile uint32_t MAXF;
N  __IO uint32_t SUPP;
X  volatile uint32_t SUPP;
N  __IO uint32_t TEST;
X  volatile uint32_t TEST;
N  __IO uint32_t MCFG;
X  volatile uint32_t MCFG;
N  __IO uint32_t MCMD;
X  volatile uint32_t MCMD;
N  __IO uint32_t MADR;
X  volatile uint32_t MADR;
N  __O  uint32_t MWTD;
X  volatile  uint32_t MWTD;
N  __I  uint32_t MRDD;
X  volatile const  uint32_t MRDD;
N  __I  uint32_t MIND;
X  volatile const  uint32_t MIND;
N       uint32_t RESERVED0[2];
N  __IO uint32_t SA0;
X  volatile uint32_t SA0;
N  __IO uint32_t SA1;
X  volatile uint32_t SA1;
N  __IO uint32_t SA2;
X  volatile uint32_t SA2;
N       uint32_t RESERVED1[45];
N  __IO uint32_t Command;                /* Control Registers                  */
X  volatile uint32_t Command;                 
N  __I  uint32_t Status;
X  volatile const  uint32_t Status;
N  __IO uint32_t RxDescriptor;
X  volatile uint32_t RxDescriptor;
N  __IO uint32_t RxStatus;
X  volatile uint32_t RxStatus;
N  __IO uint32_t RxDescriptorNumber;
X  volatile uint32_t RxDescriptorNumber;
N  __I  uint32_t RxProduceIndex;
X  volatile const  uint32_t RxProduceIndex;
N  __IO uint32_t RxConsumeIndex;
X  volatile uint32_t RxConsumeIndex;
N  __IO uint32_t TxDescriptor;
X  volatile uint32_t TxDescriptor;
N  __IO uint32_t TxStatus;
X  volatile uint32_t TxStatus;
N  __IO uint32_t TxDescriptorNumber;
X  volatile uint32_t TxDescriptorNumber;
N  __IO uint32_t TxProduceIndex;
X  volatile uint32_t TxProduceIndex;
N  __I  uint32_t TxConsumeIndex;
X  volatile const  uint32_t TxConsumeIndex;
N       uint32_t RESERVED2[10];
N  __I  uint32_t TSV0;
X  volatile const  uint32_t TSV0;
N  __I  uint32_t TSV1;
X  volatile const  uint32_t TSV1;
N  __I  uint32_t RSV;
X  volatile const  uint32_t RSV;
N       uint32_t RESERVED3[3];
N  __IO uint32_t FlowControlCounter;
X  volatile uint32_t FlowControlCounter;
N  __I  uint32_t FlowControlStatus;
X  volatile const  uint32_t FlowControlStatus;
N       uint32_t RESERVED4[34];
N  __IO uint32_t RxFilterCtrl;           /* Rx Filter Registers                */
X  volatile uint32_t RxFilterCtrl;            
N  __I  uint32_t RxFilterWoLStatus;
X  volatile const  uint32_t RxFilterWoLStatus;
N  __O  uint32_t RxFilterWoLClear;
X  volatile  uint32_t RxFilterWoLClear;
N       uint32_t RESERVED5;
N  __IO uint32_t HashFilterL;
X  volatile uint32_t HashFilterL;
N  __IO uint32_t HashFilterH;
X  volatile uint32_t HashFilterH;
N       uint32_t RESERVED6[882];
N  __I  uint32_t IntStatus;              /* Module Control Registers           */
X  volatile const  uint32_t IntStatus;               
N  __IO uint32_t IntEnable;
X  volatile uint32_t IntEnable;
N  __O  uint32_t IntClear;
X  volatile  uint32_t IntClear;
N  __O  uint32_t IntSet;
X  volatile  uint32_t IntSet;
N       uint32_t RESERVED7;
N  __IO uint32_t PowerDown;
X  volatile uint32_t PowerDown;
N       uint32_t RESERVED8;
N  __IO uint32_t Module_ID;
X  volatile uint32_t Module_ID;
N} LPC_EMAC_TypeDef;
N
N/*------------- LCD controller (LCD) -----------------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t TIMH;                   /* LCD Registers                      */
X  volatile uint32_t TIMH;                    
N  __IO uint32_t TIMV;
X  volatile uint32_t TIMV;
N  __IO uint32_t POL;
X  volatile uint32_t POL;
N  __IO uint32_t LE;
X  volatile uint32_t LE;
N  __IO uint32_t UPBASE;
X  volatile uint32_t UPBASE;
N  __IO uint32_t LPBASE;
X  volatile uint32_t LPBASE;
N  __IO uint32_t CTRL;
X  volatile uint32_t CTRL;
N  __IO uint32_t INTMSK;
X  volatile uint32_t INTMSK;
N  __I  uint32_t INTRAW;
X  volatile const  uint32_t INTRAW;
N  __I  uint32_t INTSTAT;
X  volatile const  uint32_t INTSTAT;
N  __O  uint32_t INTCLR;
X  volatile  uint32_t INTCLR;
N  __I  uint32_t UPCURR;
X  volatile const  uint32_t UPCURR;
N  __I  uint32_t LPCURR;
X  volatile const  uint32_t LPCURR;
N       uint32_t RESERVED0[115];
N  __IO uint32_t PAL[128];
X  volatile uint32_t PAL[128];
N       uint32_t RESERVED1[256];
N  __IO uint32_t CRSR_IMG[256];
X  volatile uint32_t CRSR_IMG[256];
N  __IO uint32_t CRSR_CTRL;
X  volatile uint32_t CRSR_CTRL;
N  __IO uint32_t CRSR_CFG;
X  volatile uint32_t CRSR_CFG;
N  __IO uint32_t CRSR_PAL0;
X  volatile uint32_t CRSR_PAL0;
N  __IO uint32_t CRSR_PAL1;
X  volatile uint32_t CRSR_PAL1;
N  __IO uint32_t CRSR_XY;
X  volatile uint32_t CRSR_XY;
N  __IO uint32_t CRSR_CLIP;
X  volatile uint32_t CRSR_CLIP;
N       uint32_t RESERVED2[2];
N  __IO uint32_t CRSR_INTMSK;
X  volatile uint32_t CRSR_INTMSK;
N  __O  uint32_t CRSR_INTCLR;
X  volatile  uint32_t CRSR_INTCLR;
N  __I  uint32_t CRSR_INTRAW;
X  volatile const  uint32_t CRSR_INTRAW;
N  __I  uint32_t CRSR_INTSTAT;
X  volatile const  uint32_t CRSR_INTSTAT;
N} LPC_LCD_TypeDef;
N
N/*------------- Universal Serial Bus (USB) -----------------------------------*/
Ntypedef struct
N{
N  __I  uint32_t Revision;             /* USB Host Registers                 */
X  volatile const  uint32_t Revision;              
N  __IO uint32_t Control;
X  volatile uint32_t Control;
N  __IO uint32_t CommandStatus;
X  volatile uint32_t CommandStatus;
N  __IO uint32_t InterruptStatus;
X  volatile uint32_t InterruptStatus;
N  __IO uint32_t InterruptEnable;
X  volatile uint32_t InterruptEnable;
N  __IO uint32_t InterruptDisable;
X  volatile uint32_t InterruptDisable;
N  __IO uint32_t HCCA;
X  volatile uint32_t HCCA;
N  __I  uint32_t PeriodCurrentED;
X  volatile const  uint32_t PeriodCurrentED;
N  __IO uint32_t ControlHeadED;
X  volatile uint32_t ControlHeadED;
N  __IO uint32_t ControlCurrentED;
X  volatile uint32_t ControlCurrentED;
N  __IO uint32_t BulkHeadED;
X  volatile uint32_t BulkHeadED;
N  __IO uint32_t BulkCurrentED;
X  volatile uint32_t BulkCurrentED;
N  __I  uint32_t DoneHead;
X  volatile const  uint32_t DoneHead;
N  __IO uint32_t FmInterval;
X  volatile uint32_t FmInterval;
N  __I  uint32_t FmRemaining;
X  volatile const  uint32_t FmRemaining;
N  __I  uint32_t FmNumber;
X  volatile const  uint32_t FmNumber;
N  __IO uint32_t PeriodicStart;
X  volatile uint32_t PeriodicStart;
N  __IO uint32_t LSTreshold;
X  volatile uint32_t LSTreshold;
N  __IO uint32_t RhDescriptorA;
X  volatile uint32_t RhDescriptorA;
N  __IO uint32_t RhDescriptorB;
X  volatile uint32_t RhDescriptorB;
N  __IO uint32_t RhStatus;
X  volatile uint32_t RhStatus;
N  __IO uint32_t RhPortStatus1;
X  volatile uint32_t RhPortStatus1;
N  __IO uint32_t RhPortStatus2;
X  volatile uint32_t RhPortStatus2;
N       uint32_t RESERVED0[40];
N  __I  uint32_t Module_ID;
X  volatile const  uint32_t Module_ID;
N
N  __I  uint32_t IntSt;               /* USB On-The-Go Registers            */
X  volatile const  uint32_t IntSt;                
N  __IO uint32_t IntEn;
X  volatile uint32_t IntEn;
N  __O  uint32_t IntSet;
X  volatile  uint32_t IntSet;
N  __O  uint32_t IntClr;
X  volatile  uint32_t IntClr;
N  __IO uint32_t StCtrl;
X  volatile uint32_t StCtrl;
N  __IO uint32_t Tmr;
X  volatile uint32_t Tmr;
N       uint32_t RESERVED1[58];
N
N  __I  uint32_t DevIntSt;            /* USB Device Interrupt Registers     */
X  volatile const  uint32_t DevIntSt;             
N  __IO uint32_t DevIntEn;
X  volatile uint32_t DevIntEn;
N  __O  uint32_t DevIntClr;
X  volatile  uint32_t DevIntClr;
N  __O  uint32_t DevIntSet;
X  volatile  uint32_t DevIntSet;
N
N  __O  uint32_t CmdCode;             /* USB Device SIE Command Registers   */
X  volatile  uint32_t CmdCode;              
N  __I  uint32_t CmdData;
X  volatile const  uint32_t CmdData;
N
N  __I  uint32_t RxData;              /* USB Device Transfer Registers      */
X  volatile const  uint32_t RxData;               
N  __O  uint32_t TxData;
X  volatile  uint32_t TxData;
N  __I  uint32_t RxPLen;
X  volatile const  uint32_t RxPLen;
N  __O  uint32_t TxPLen;
X  volatile  uint32_t TxPLen;
N  __IO uint32_t Ctrl;
X  volatile uint32_t Ctrl;
N  __O  uint32_t DevIntPri;
X  volatile  uint32_t DevIntPri;
N
N  __I  uint32_t EpIntSt;             /* USB Device Endpoint Interrupt Regs */
X  volatile const  uint32_t EpIntSt;              
N  __IO uint32_t EpIntEn;
X  volatile uint32_t EpIntEn;
N  __O  uint32_t EpIntClr;
X  volatile  uint32_t EpIntClr;
N  __O  uint32_t EpIntSet;
X  volatile  uint32_t EpIntSet;
N  __O  uint32_t EpIntPri;
X  volatile  uint32_t EpIntPri;
N
N  __IO uint32_t ReEp;                /* USB Device Endpoint Realization Reg*/
X  volatile uint32_t ReEp;                 
N  __O  uint32_t EpInd;
X  volatile  uint32_t EpInd;
N  __IO uint32_t MaxPSize;
X  volatile uint32_t MaxPSize;
N
N  __I  uint32_t DMARSt;              /* USB Device DMA Registers           */
X  volatile const  uint32_t DMARSt;               
N  __O  uint32_t DMARClr;
X  volatile  uint32_t DMARClr;
N  __O  uint32_t DMARSet;
X  volatile  uint32_t DMARSet;
N       uint32_t RESERVED2[9];
N  __IO uint32_t UDCAH;
X  volatile uint32_t UDCAH;
N  __I  uint32_t EpDMASt;
X  volatile const  uint32_t EpDMASt;
N  __O  uint32_t EpDMAEn;
X  volatile  uint32_t EpDMAEn;
N  __O  uint32_t EpDMADis;
X  volatile  uint32_t EpDMADis;
N  __I  uint32_t DMAIntSt;
X  volatile const  uint32_t DMAIntSt;
N  __IO uint32_t DMAIntEn;
X  volatile uint32_t DMAIntEn;
N       uint32_t RESERVED3[2];
N  __I  uint32_t EoTIntSt;
X  volatile const  uint32_t EoTIntSt;
N  __O  uint32_t EoTIntClr;
X  volatile  uint32_t EoTIntClr;
N  __O  uint32_t EoTIntSet;
X  volatile  uint32_t EoTIntSet;
N  __I  uint32_t NDDRIntSt;
X  volatile const  uint32_t NDDRIntSt;
N  __O  uint32_t NDDRIntClr;
X  volatile  uint32_t NDDRIntClr;
N  __O  uint32_t NDDRIntSet;
X  volatile  uint32_t NDDRIntSet;
N  __I  uint32_t SysErrIntSt;
X  volatile const  uint32_t SysErrIntSt;
N  __O  uint32_t SysErrIntClr;
X  volatile  uint32_t SysErrIntClr;
N  __O  uint32_t SysErrIntSet;
X  volatile  uint32_t SysErrIntSet;
N       uint32_t RESERVED4[15];
N
N  union {
N  __I  uint32_t I2C_RX;                 /* USB OTG I2C Registers              */
X  volatile const  uint32_t I2C_RX;                  
N  __O  uint32_t I2C_TX;
X  volatile  uint32_t I2C_TX;
N  };
N  __IO  uint32_t I2C_STS;
X  volatile  uint32_t I2C_STS;
N  __IO uint32_t I2C_CTL;
X  volatile uint32_t I2C_CTL;
N  __IO uint32_t I2C_CLKHI;
X  volatile uint32_t I2C_CLKHI;
N  __O  uint32_t I2C_CLKLO;
X  volatile  uint32_t I2C_CLKLO;
N       uint32_t RESERVED5[824];
N
N  union {
N  __IO uint32_t USBClkCtrl;             /* USB Clock Control Registers        */
X  volatile uint32_t USBClkCtrl;              
N  __IO uint32_t OTGClkCtrl;
X  volatile uint32_t OTGClkCtrl;
N  };
N  union {
N  __I  uint32_t USBClkSt;
X  volatile const  uint32_t USBClkSt;
N  __I  uint32_t OTGClkSt;
X  volatile const  uint32_t OTGClkSt;
N  };
N} LPC_USB_TypeDef;
N
N/*------------- CRC Engine (CRC) -----------------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t MODE;
X  volatile uint32_t MODE;
N  __IO uint32_t SEED;
X  volatile uint32_t SEED;
N  union {
N  __I  uint32_t SUM;
X  volatile const  uint32_t SUM;
N  struct {
N  __O  uint32_t DATA;
X  volatile  uint32_t DATA;
N  } WR_DATA_DWORD;
N  
N  struct {
N  __O  uint16_t DATA;
X  volatile  uint16_t DATA;
N       uint16_t RESERVED;
N  }WR_DATA_WORD;
N  
N  struct {
N  __O  uint8_t  DATA;
X  volatile  uint8_t  DATA;
N       uint8_t  RESERVED[3];
N  	}WR_DATA_BYTE;
N  };
N} LPC_CRC_TypeDef;
N/*------------- General Purpose Input/Output (GPIO) --------------------------*/
Ntypedef struct
N{
N  __IO uint32_t DIR;
X  volatile uint32_t DIR;
N       uint32_t RESERVED0[3];
N  __IO uint32_t MASK;
X  volatile uint32_t MASK;
N  __IO uint32_t PIN;
X  volatile uint32_t PIN;
N  __IO uint32_t SET;
X  volatile uint32_t SET;
N  __O  uint32_t CLR;
X  volatile  uint32_t CLR;
N} LPC_GPIO_TypeDef;
N
Ntypedef struct
N{
N  __I  uint32_t IntStatus;
X  volatile const  uint32_t IntStatus;
N  __I  uint32_t IO0IntStatR;
X  volatile const  uint32_t IO0IntStatR;
N  __I  uint32_t IO0IntStatF;
X  volatile const  uint32_t IO0IntStatF;
N  __O  uint32_t IO0IntClr;
X  volatile  uint32_t IO0IntClr;
N  __IO uint32_t IO0IntEnR;
X  volatile uint32_t IO0IntEnR;
N  __IO uint32_t IO0IntEnF;
X  volatile uint32_t IO0IntEnF;
N       uint32_t RESERVED0[3];
N  __I  uint32_t IO2IntStatR;
X  volatile const  uint32_t IO2IntStatR;
N  __I  uint32_t IO2IntStatF;
X  volatile const  uint32_t IO2IntStatF;
N  __O  uint32_t IO2IntClr;
X  volatile  uint32_t IO2IntClr;
N  __IO uint32_t IO2IntEnR;
X  volatile uint32_t IO2IntEnR;
N  __IO uint32_t IO2IntEnF;
X  volatile uint32_t IO2IntEnF;
N} LPC_GPIOINT_TypeDef;
N
N/*------------- External Memory Controller (EMC) -----------------------------*/
Ntypedef struct
N{
N  __IO uint32_t Control;
X  volatile uint32_t Control;
N  __I  uint32_t Status;
X  volatile const  uint32_t Status;
N  __IO uint32_t Config;
X  volatile uint32_t Config;
N       uint32_t RESERVED0[5];
N  __IO uint32_t DynamicControl;
X  volatile uint32_t DynamicControl;
N  __IO uint32_t DynamicRefresh;
X  volatile uint32_t DynamicRefresh;
N  __IO uint32_t DynamicReadConfig;
X  volatile uint32_t DynamicReadConfig;
N       uint32_t RESERVED1[1];
N  __IO uint32_t DynamicRP;
X  volatile uint32_t DynamicRP;
N  __IO uint32_t DynamicRAS;
X  volatile uint32_t DynamicRAS;
N  __IO uint32_t DynamicSREX;
X  volatile uint32_t DynamicSREX;
N  __IO uint32_t DynamicAPR;
X  volatile uint32_t DynamicAPR;
N  __IO uint32_t DynamicDAL;
X  volatile uint32_t DynamicDAL;
N  __IO uint32_t DynamicWR;
X  volatile uint32_t DynamicWR;
N  __IO uint32_t DynamicRC;
X  volatile uint32_t DynamicRC;
N  __IO uint32_t DynamicRFC;
X  volatile uint32_t DynamicRFC;
N  __IO uint32_t DynamicXSR;
X  volatile uint32_t DynamicXSR;
N  __IO uint32_t DynamicRRD;
X  volatile uint32_t DynamicRRD;
N  __IO uint32_t DynamicMRD;
X  volatile uint32_t DynamicMRD;
N       uint32_t RESERVED2[9];
N  __IO uint32_t StaticExtendedWait;
X  volatile uint32_t StaticExtendedWait;
N       uint32_t RESERVED3[31];
N  __IO uint32_t DynamicConfig0;
X  volatile uint32_t DynamicConfig0;
N  __IO uint32_t DynamicRasCas0;
X  volatile uint32_t DynamicRasCas0;
N       uint32_t RESERVED4[6];
N  __IO uint32_t DynamicConfig1;
X  volatile uint32_t DynamicConfig1;
N  __IO uint32_t DynamicRasCas1;
X  volatile uint32_t DynamicRasCas1;
N       uint32_t RESERVED5[6];
N  __IO uint32_t DynamicConfig2;
X  volatile uint32_t DynamicConfig2;
N  __IO uint32_t DynamicRasCas2;
X  volatile uint32_t DynamicRasCas2;
N       uint32_t RESERVED6[6];
N  __IO uint32_t DynamicConfig3;
X  volatile uint32_t DynamicConfig3;
N  __IO uint32_t DynamicRasCas3;
X  volatile uint32_t DynamicRasCas3;
N       uint32_t RESERVED7[38];
N  __IO uint32_t StaticConfig0;
X  volatile uint32_t StaticConfig0;
N  __IO uint32_t StaticWaitWen0;
X  volatile uint32_t StaticWaitWen0;
N  __IO uint32_t StaticWaitOen0;
X  volatile uint32_t StaticWaitOen0;
N  __IO uint32_t StaticWaitRd0;
X  volatile uint32_t StaticWaitRd0;
N  __IO uint32_t StaticWaitPage0;
X  volatile uint32_t StaticWaitPage0;
N  __IO uint32_t StaticWaitWr0;
X  volatile uint32_t StaticWaitWr0;
N  __IO uint32_t StaticWaitTurn0;
X  volatile uint32_t StaticWaitTurn0;
N       uint32_t RESERVED8[1];
N  __IO uint32_t StaticConfig1;
X  volatile uint32_t StaticConfig1;
N  __IO uint32_t StaticWaitWen1;
X  volatile uint32_t StaticWaitWen1;
N  __IO uint32_t StaticWaitOen1;
X  volatile uint32_t StaticWaitOen1;
N  __IO uint32_t StaticWaitRd1;
X  volatile uint32_t StaticWaitRd1;
N  __IO uint32_t StaticWaitPage1;
X  volatile uint32_t StaticWaitPage1;
N  __IO uint32_t StaticWaitWr1;
X  volatile uint32_t StaticWaitWr1;
N  __IO uint32_t StaticWaitTurn1;
X  volatile uint32_t StaticWaitTurn1;
N       uint32_t RESERVED9[1];
N  __IO uint32_t StaticConfig2;
X  volatile uint32_t StaticConfig2;
N  __IO uint32_t StaticWaitWen2;
X  volatile uint32_t StaticWaitWen2;
N  __IO uint32_t StaticWaitOen2;
X  volatile uint32_t StaticWaitOen2;
N  __IO uint32_t StaticWaitRd2;
X  volatile uint32_t StaticWaitRd2;
N  __IO uint32_t StaticWaitPage2;
X  volatile uint32_t StaticWaitPage2;
N  __IO uint32_t StaticWaitWr2;
X  volatile uint32_t StaticWaitWr2;
N  __IO uint32_t StaticWaitTurn2;
X  volatile uint32_t StaticWaitTurn2;
N       uint32_t RESERVED10[1];
N  __IO uint32_t StaticConfig3;
X  volatile uint32_t StaticConfig3;
N  __IO uint32_t StaticWaitWen3;
X  volatile uint32_t StaticWaitWen3;
N  __IO uint32_t StaticWaitOen3;
X  volatile uint32_t StaticWaitOen3;
N  __IO uint32_t StaticWaitRd3;
X  volatile uint32_t StaticWaitRd3;
N  __IO uint32_t StaticWaitPage3;
X  volatile uint32_t StaticWaitPage3;
N  __IO uint32_t StaticWaitWr3;
X  volatile uint32_t StaticWaitWr3;
N  __IO uint32_t StaticWaitTurn3;
X  volatile uint32_t StaticWaitTurn3;
N} LPC_EMC_TypeDef;
N
N/*------------- Watchdog Timer (WDT) -----------------------------------------*/
Ntypedef struct
N{
N  __IO uint8_t  MOD;
X  volatile uint8_t  MOD;
N       uint8_t  RESERVED0[3];
N  __IO uint32_t TC;
X  volatile uint32_t TC;
N  __O  uint8_t  FEED;
X  volatile  uint8_t  FEED;
N       uint8_t  RESERVED1[3];
N  __I  uint32_t TV;
X  volatile const  uint32_t TV;
N       uint32_t RESERVED2;
N  __IO uint32_t WARNINT;
X  volatile uint32_t WARNINT;
N  __IO uint32_t WINDOW;
X  volatile uint32_t WINDOW;
N} LPC_WDT_TypeDef;
N
N/*------------- Timer (TIM) --------------------------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t IR;                     /*!< Offset: 0x000 Interrupt Register (R/W) */
X  volatile uint32_t IR;                      
N  __IO uint32_t TCR;                    /*!< Offset: 0x004 Timer Control Register (R/W) */
X  volatile uint32_t TCR;                     
N  __IO uint32_t TC;                     /*!< Offset: 0x008 Timer Counter Register (R/W) */
X  volatile uint32_t TC;                      
N  __IO uint32_t PR;                     /*!< Offset: 0x00C Prescale Register (R/W) */
X  volatile uint32_t PR;                      
N  __IO uint32_t PC;                     /*!< Offset: 0x010 Prescale Counter Register (R/W) */
X  volatile uint32_t PC;                      
N  __IO uint32_t MCR;                    /*!< Offset: 0x014 Match Control Register (R/W) */
X  volatile uint32_t MCR;                     
N  __IO uint32_t MR0;                    /*!< Offset: 0x018 Match Register 0 (R/W) */
X  volatile uint32_t MR0;                     
N  __IO uint32_t MR1;                    /*!< Offset: 0x01C Match Register 1 (R/W) */
X  volatile uint32_t MR1;                     
N  __IO uint32_t MR2;                    /*!< Offset: 0x020 Match Register 2 (R/W) */
X  volatile uint32_t MR2;                     
N  __IO uint32_t MR3;                    /*!< Offset: 0x024 Match Register 3 (R/W) */
X  volatile uint32_t MR3;                     
N  __IO uint32_t CCR;                    /*!< Offset: 0x028 Capture Control Register (R/W) */
X  volatile uint32_t CCR;                     
N  __I  uint32_t CR0;                    /*!< Offset: 0x02C Capture Register 0 (R/ ) */
X  volatile const  uint32_t CR0;                     
N  __I  uint32_t CR1;					/*!< Offset: 0x030 Capture Register 1 (R/ ) */
X  volatile const  uint32_t CR1;					 
N       uint32_t RESERVED0[2];
N  __IO uint32_t EMR;                    /*!< Offset: 0x03C External Match Register (R/W) */
X  volatile uint32_t EMR;                     
N       uint32_t RESERVED1[12];
N  __IO uint32_t CTCR;                   /*!< Offset: 0x070 Count Control Register (R/W) */
X  volatile uint32_t CTCR;                    
N} LPC_TIM_TypeDef;
N
N
N/*------------- Pulse-Width Modulation (PWM) ---------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t IR;                     /*!< Offset: 0x000 Interrupt Register (R/W) */
X  volatile uint32_t IR;                      
N  __IO uint32_t TCR;                    /*!< Offset: 0x004 Timer Control Register (R/W) */
X  volatile uint32_t TCR;                     
N  __IO uint32_t TC;                     /*!< Offset: 0x008 Timer Counter Register (R/W) */
X  volatile uint32_t TC;                      
N  __IO uint32_t PR;                     /*!< Offset: 0x00C Prescale Register (R/W) */
X  volatile uint32_t PR;                      
N  __IO uint32_t PC;                     /*!< Offset: 0x010 Prescale Counter Register (R/W) */
X  volatile uint32_t PC;                      
N  __IO uint32_t MCR;                    /*!< Offset: 0x014 Match Control Register (R/W) */
X  volatile uint32_t MCR;                     
N  __IO uint32_t MR0;                    /*!< Offset: 0x018 Match Register 0 (R/W) */
X  volatile uint32_t MR0;                     
N  __IO uint32_t MR1;                    /*!< Offset: 0x01C Match Register 1 (R/W) */
X  volatile uint32_t MR1;                     
N  __IO uint32_t MR2;                    /*!< Offset: 0x020 Match Register 2 (R/W) */
X  volatile uint32_t MR2;                     
N  __IO uint32_t MR3;                    /*!< Offset: 0x024 Match Register 3 (R/W) */
X  volatile uint32_t MR3;                     
N  __IO uint32_t CCR;                    /*!< Offset: 0x028 Capture Control Register (R/W) */
X  volatile uint32_t CCR;                     
N  __I  uint32_t CR0;                    /*!< Offset: 0x02C Capture Register 0 (R/ ) */
X  volatile const  uint32_t CR0;                     
N  __I  uint32_t CR1;					/*!< Offset: 0x030 Capture Register 1 (R/ ) */
X  volatile const  uint32_t CR1;					 
N  __I  uint32_t CR2;					/*!< Offset: 0x034 Capture Register 2 (R/ ) */
X  volatile const  uint32_t CR2;					 
N  __I  uint32_t CR3;					/*!< Offset: 0x038 Capture Register 3 (R/ ) */
X  volatile const  uint32_t CR3;					 
N       uint32_t RESERVED0;
N  __IO uint32_t MR4;					/*!< Offset: 0x040 Match Register 4 (R/W) */
X  volatile uint32_t MR4;					 
N  __IO uint32_t MR5;					/*!< Offset: 0x044 Match Register 5 (R/W) */
X  volatile uint32_t MR5;					 
N  __IO uint32_t MR6;					/*!< Offset: 0x048 Match Register 6 (R/W) */
X  volatile uint32_t MR6;					 
N  __IO uint32_t PCR;					/*!< Offset: 0x04C PWM Control Register (R/W) */
X  volatile uint32_t PCR;					 
N  __IO uint32_t LER;					/*!< Offset: 0x050 Load Enable Register (R/W) */
X  volatile uint32_t LER;					 
N       uint32_t RESERVED1[7];
N  __IO uint32_t CTCR;					/*!< Offset: 0x070 Counter Control Register (R/W) */
X  volatile uint32_t CTCR;					 
N} LPC_PWM_TypeDef;
N
N/*------------- Universal Asynchronous Receiver Transmitter (UARTx) -----------*/
N/* There are three types of UARTs on the chip:
N(1) UART0,UART2, and UART3 are the standard UART.
N(2) UART1 is the standard with modem capability.
N(3) USART(UART4) is the sync/async UART with smart card capability.
NMore details can be found on the Users Manual. */
N
N#if 0
Stypedef struct
S{
S  union {
S  __I  uint8_t  RBR;
S  __O  uint8_t  THR;
S  __IO uint8_t  DLL;
S       uint32_t RESERVED0;
S  };
S  union {
S  __IO uint8_t  DLM;
S  __IO uint32_t IER;
S  };
S  union {
S  __I  uint32_t IIR;
S  __O  uint8_t  FCR;
S  };
S  __IO uint8_t  LCR;
S       uint8_t  RESERVED1[7];
S  __I  uint8_t  LSR;
S       uint8_t  RESERVED2[7];
S  __IO uint8_t  SCR;
S       uint8_t  RESERVED3[3];
S  __IO uint32_t ACR;
S  __IO uint8_t  ICR;
S       uint8_t  RESERVED4[3];
S  __IO uint8_t  FDR;
S       uint8_t  RESERVED5[7];
S  __IO uint8_t  TER;
S       uint8_t  RESERVED6[39];
S  __I  uint8_t  FIFOLVL;
S} LPC_UART_TypeDef;
N#else
Ntypedef struct
N{
N	union
N	{
N		__I  uint8_t  RBR;
X		volatile const  uint8_t  RBR;
N		__O  uint8_t  THR;
X		volatile  uint8_t  THR;
N		__IO uint8_t  DLL;
X		volatile uint8_t  DLL;
N		uint32_t RESERVED0;
N	};
N	union
N	{
N		__IO uint8_t  DLM;
X		volatile uint8_t  DLM;
N		__IO uint32_t IER;
X		volatile uint32_t IER;
N	};
N	union
N	{
N		__I  uint32_t IIR;
X		volatile const  uint32_t IIR;
N		__O  uint8_t  FCR;
X		volatile  uint8_t  FCR;
N	};
N	__IO uint8_t  LCR;
X	volatile uint8_t  LCR;
N	uint8_t  RESERVED1[7];//Reserved
N	__I  uint8_t  LSR;
X	volatile const  uint8_t  LSR;
N	uint8_t  RESERVED2[7];//Reserved
N	__IO uint8_t  SCR;
X	volatile uint8_t  SCR;
N	uint8_t  RESERVED3[3];//Reserved
N	__IO uint32_t ACR;
X	volatile uint32_t ACR;
N	__IO uint8_t  ICR;
X	volatile uint8_t  ICR;
N	uint8_t  RESERVED4[3];//Reserved
N	__IO uint8_t  FDR;
X	volatile uint8_t  FDR;
N	uint8_t  RESERVED5[7];//Reserved
N	__IO uint8_t  TER;
X	volatile uint8_t  TER;
N	uint8_t  RESERVED8[27];//Reserved
N	__IO uint8_t  RS485CTRL;
X	volatile uint8_t  RS485CTRL;
N	uint8_t  RESERVED9[3];//Reserved
N	__IO uint8_t  ADRMATCH;
X	volatile uint8_t  ADRMATCH;
N	uint8_t  RESERVED10[3];//Reserved
N	__IO uint8_t  RS485DLY;
X	volatile uint8_t  RS485DLY;
N	uint8_t  RESERVED11[3];//Reserved
N	__I  uint8_t  FIFOLVL;
X	volatile const  uint8_t  FIFOLVL;
N}LPC_UART_TypeDef;
N#endif
N
N
Ntypedef struct
N{
N  union {
N  __I  uint8_t  RBR;
X  volatile const  uint8_t  RBR;
N  __O  uint8_t  THR;
X  volatile  uint8_t  THR;
N  __IO uint8_t  DLL;
X  volatile uint8_t  DLL;
N       uint32_t RESERVED0;
N  };
N  union {
N  __IO uint8_t  DLM;
X  volatile uint8_t  DLM;
N  __IO uint32_t IER;
X  volatile uint32_t IER;
N  };
N  union {
N  __I  uint32_t IIR;
X  volatile const  uint32_t IIR;
N  __O  uint8_t  FCR;
X  volatile  uint8_t  FCR;
N  };
N  __IO uint8_t  LCR;
X  volatile uint8_t  LCR;
N       uint8_t  RESERVED1[3];
N  __IO uint8_t  MCR;
X  volatile uint8_t  MCR;
N       uint8_t  RESERVED2[3];
N  __I  uint8_t  LSR;
X  volatile const  uint8_t  LSR;
N       uint8_t  RESERVED3[3];
N  __I  uint8_t  MSR;
X  volatile const  uint8_t  MSR;
N       uint8_t  RESERVED4[3];
N  __IO uint8_t  SCR;
X  volatile uint8_t  SCR;
N       uint8_t  RESERVED5[3];
N  __IO uint32_t ACR;
X  volatile uint32_t ACR;
N       uint32_t RESERVED6;
N  __IO uint32_t FDR;
X  volatile uint32_t FDR;
N       uint32_t RESERVED7;
N  __IO uint8_t  TER;
X  volatile uint8_t  TER;
N       uint8_t  RESERVED8[27];
N  __IO uint8_t  RS485CTRL;
X  volatile uint8_t  RS485CTRL;
N       uint8_t  RESERVED9[3];
N  __IO uint8_t  ADRMATCH;
X  volatile uint8_t  ADRMATCH;
N       uint8_t  RESERVED10[3];
N  __IO uint8_t  RS485DLY;
X  volatile uint8_t  RS485DLY;
N       uint8_t  RESERVED11[3];
N  __I  uint8_t  FIFOLVL;
X  volatile const  uint8_t  FIFOLVL;
N} LPC_UART1_TypeDef;
N
Ntypedef struct
N{
N  union {
N  __I  uint32_t  RBR;                   /*!< Offset: 0x000 Receiver Buffer  Register (R/ ) */
X  volatile const  uint32_t  RBR;                    
N  __O  uint32_t  THR;                   /*!< Offset: 0x000 Transmit Holding Register ( /W) */
X  volatile  uint32_t  THR;                    
N  __IO uint32_t  DLL;                   /*!< Offset: 0x000 Divisor Latch LSB (R/W) */
X  volatile uint32_t  DLL;                    
N  };
N  union {
N  __IO uint32_t  DLM;                   /*!< Offset: 0x004 Divisor Latch MSB (R/W) */
X  volatile uint32_t  DLM;                    
N  __IO uint32_t  IER;                   /*!< Offset: 0x000 Interrupt Enable Register (R/W) */
X  volatile uint32_t  IER;                    
N  };
N  union {
N  __I  uint32_t  IIR;                   /*!< Offset: 0x008 Interrupt ID Register (R/ ) */
X  volatile const  uint32_t  IIR;                    
N  __O  uint32_t  FCR;                   /*!< Offset: 0x008 FIFO Control Register ( /W) */
X  volatile  uint32_t  FCR;                    
N  };
N  __IO uint32_t  LCR;                   /*!< Offset: 0x00C Line Control Register (R/W) */
X  volatile uint32_t  LCR;                    
N  __IO uint32_t  MCR;                   /*!< Offset: 0x010 Modem control Register (R/W) */
X  volatile uint32_t  MCR;                    
N  __I  uint32_t  LSR;                   /*!< Offset: 0x014 Line Status Register (R/ ) */
X  volatile const  uint32_t  LSR;                    
N  __I  uint32_t  MSR;                   /*!< Offset: 0x018 Modem status Register (R/ ) */
X  volatile const  uint32_t  MSR;                    
N  __IO uint32_t  SCR;                   /*!< Offset: 0x01C Scratch Pad Register (R/W) */
X  volatile uint32_t  SCR;                    
N  __IO uint32_t  ACR;                   /*!< Offset: 0x020 Auto-baud Control Register (R/W) */
X  volatile uint32_t  ACR;                    
N  __IO uint32_t  ICR;                   /*!< Offset: 0x024 irDA Control Register (R/W) */
X  volatile uint32_t  ICR;                    
N  __IO uint32_t  FDR;                   /*!< Offset: 0x028 Fractional Divider Register (R/W) */
X  volatile uint32_t  FDR;                    
N  __IO uint32_t  OSR;                   /*!< Offset: 0x02C Over sampling Register (R/W) */
X  volatile uint32_t  OSR;                    
N  __O  uint32_t  POP;                   /*!< Offset: 0x030 NHP Pop Register (W) */
X  volatile  uint32_t  POP;                    
N  __IO uint32_t  MODE;                  /*!< Offset: 0x034 NHP Mode selection Register (W) */
X  volatile uint32_t  MODE;                   
N       uint32_t  RESERVED0[2];
N  __IO uint32_t  HDEN;                  /*!< Offset: 0x040 Half duplex Enable Register (R/W) */
X  volatile uint32_t  HDEN;                   
N       uint32_t  RESERVED1;
N  __IO uint32_t  SCI_CTRL;				/*!< Offset: 0x048 Smart card Interface Control Register (R/W) */
X  volatile uint32_t  SCI_CTRL;				 
N  __IO uint32_t  RS485CTRL;             /*!< Offset: 0x04C RS-485/EIA-485 Control Register (R/W) */
X  volatile uint32_t  RS485CTRL;              
N  __IO uint32_t  ADRMATCH;              /*!< Offset: 0x050 RS-485/EIA-485 address match Register (R/W) */
X  volatile uint32_t  ADRMATCH;               
N  __IO uint32_t  RS485DLY;              /*!< Offset: 0x054 RS-485/EIA-485 direction control delay Register (R/W) */
X  volatile uint32_t  RS485DLY;               
N  __IO uint32_t  SYNCCTRL;              /*!< Offset: 0x058 Synchronous Mode Control Register (R/W ) */
X  volatile uint32_t  SYNCCTRL;               
N  __IO uint32_t  TER;                   /*!< Offset: 0x05C Transmit Enable Register (R/W) */
X  volatile uint32_t  TER;                    
N       uint32_t  RESERVED2[989];
N  __I  uint32_t  CFG;                   /*!< Offset: 0xFD4 Configuration Register (R) */
X  volatile const  uint32_t  CFG;                    
N  __O  uint32_t  INTCE;                 /*!< Offset: 0xFD8 Interrupt Clear Enable Register (W) */
X  volatile  uint32_t  INTCE;                  
N  __O  uint32_t  INTSE;                 /*!< Offset: 0xFDC Interrupt Set Enable Register (W) */
X  volatile  uint32_t  INTSE;                  
N  __I  uint32_t  INTS;                  /*!< Offset: 0xFE0 Interrupt Status Register (R) */
X  volatile const  uint32_t  INTS;                   
N  __I  uint32_t  INTE;                  /*!< Offset: 0xFE4 Interrupt Enable Register (R) */
X  volatile const  uint32_t  INTE;                   
N  __O  uint32_t  INTCS;                 /*!< Offset: 0xFE8 Interrupt Clear Status Register (W) */
X  volatile  uint32_t  INTCS;                  
N  __O  uint32_t  INTSS;                 /*!< Offset: 0xFEC Interrupt Set Status Register (W) */
X  volatile  uint32_t  INTSS;                  
N       uint32_t  RESERVED3[3];
N  __I  uint32_t  MID;                   /*!< Offset: 0xFFC Module Identification Register (R) */
X  volatile const  uint32_t  MID;                    
N} LPC_UART4_TypeDef;
N/*------------- Inter-Integrated Circuit (I2C) -------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t CONSET;                 /*!< Offset: 0x000 I2C Control Set Register (R/W) */
X  volatile uint32_t CONSET;                  
N  __I  uint32_t STAT;                   /*!< Offset: 0x004 I2C Status Register (R/ ) */
X  volatile const  uint32_t STAT;                    
N  __IO uint32_t DAT;                    /*!< Offset: 0x008 I2C Data Register (R/W) */
X  volatile uint32_t DAT;                     
N  __IO uint32_t ADR0;                   /*!< Offset: 0x00C I2C Slave Address Register 0 (R/W) */
X  volatile uint32_t ADR0;                    
N  __IO uint32_t SCLH;                   /*!< Offset: 0x010 SCH Duty Cycle Register High Half Word (R/W) */
X  volatile uint32_t SCLH;                    
N  __IO uint32_t SCLL;                   /*!< Offset: 0x014 SCL Duty Cycle Register Low Half Word (R/W) */
X  volatile uint32_t SCLL;                    
N  __O  uint32_t CONCLR;                 /*!< Offset: 0x018 I2C Control Clear Register ( /W) */
X  volatile  uint32_t CONCLR;                  
N  __IO uint32_t MMCTRL;                 /*!< Offset: 0x01C Monitor mode control register (R/W) */
X  volatile uint32_t MMCTRL;                  
N  __IO uint32_t ADR1;                   /*!< Offset: 0x020 I2C Slave Address Register 1 (R/W) */
X  volatile uint32_t ADR1;                    
N  __IO uint32_t ADR2;                   /*!< Offset: 0x024 I2C Slave Address Register 2 (R/W) */
X  volatile uint32_t ADR2;                    
N  __IO uint32_t ADR3;                   /*!< Offset: 0x028 I2C Slave Address Register 3 (R/W) */
X  volatile uint32_t ADR3;                    
N  __I  uint32_t DATA_BUFFER;            /*!< Offset: 0x02C Data buffer register ( /W) */
X  volatile const  uint32_t DATA_BUFFER;             
N  __IO uint32_t MASK0;                  /*!< Offset: 0x030 I2C Slave address mask register 0 (R/W) */
X  volatile uint32_t MASK0;                   
N  __IO uint32_t MASK1;                  /*!< Offset: 0x034 I2C Slave address mask register 1 (R/W) */
X  volatile uint32_t MASK1;                   
N  __IO uint32_t MASK2;                  /*!< Offset: 0x038 I2C Slave address mask register 2 (R/W) */
X  volatile uint32_t MASK2;                   
N  __IO uint32_t MASK3;                  /*!< Offset: 0x03C I2C Slave address mask register 3 (R/W) */
X  volatile uint32_t MASK3;                   
N} LPC_I2C_TypeDef;
N
N/*------------- Real-Time Clock (RTC) ----------------------------------------*/
Ntypedef struct
N{
N  __IO uint8_t  ILR;
X  volatile uint8_t  ILR;
N       uint8_t  RESERVED0[7];
N  __IO uint8_t  CCR;
X  volatile uint8_t  CCR;
N       uint8_t  RESERVED1[3];
N  __IO uint8_t  CIIR;
X  volatile uint8_t  CIIR;
N       uint8_t  RESERVED2[3];
N  __IO uint8_t  AMR;
X  volatile uint8_t  AMR;
N       uint8_t  RESERVED3[3];
N  __I  uint32_t CTIME0;
X  volatile const  uint32_t CTIME0;
N  __I  uint32_t CTIME1;
X  volatile const  uint32_t CTIME1;
N  __I  uint32_t CTIME2;
X  volatile const  uint32_t CTIME2;
N  __IO uint8_t  SEC;
X  volatile uint8_t  SEC;
N       uint8_t  RESERVED4[3];
N  __IO uint8_t  MIN;
X  volatile uint8_t  MIN;
N       uint8_t  RESERVED5[3];
N  __IO uint8_t  HOUR;
X  volatile uint8_t  HOUR;
N       uint8_t  RESERVED6[3];
N  __IO uint8_t  DOM;
X  volatile uint8_t  DOM;
N       uint8_t  RESERVED7[3];
N  __IO uint8_t  DOW;
X  volatile uint8_t  DOW;
N       uint8_t  RESERVED8[3];
N  __IO uint16_t DOY;
X  volatile uint16_t DOY;
N       uint16_t RESERVED9;
N  __IO uint8_t  MONTH;
X  volatile uint8_t  MONTH;
N       uint8_t  RESERVED10[3];
N  __IO uint16_t YEAR;
X  volatile uint16_t YEAR;
N       uint16_t RESERVED11;
N  __IO uint32_t CALIBRATION;
X  volatile uint32_t CALIBRATION;
N  __IO uint32_t GPREG0;
X  volatile uint32_t GPREG0;
N  __IO uint32_t GPREG1;
X  volatile uint32_t GPREG1;
N  __IO uint32_t GPREG2;
X  volatile uint32_t GPREG2;
N  __IO uint32_t GPREG3;
X  volatile uint32_t GPREG3;
N  __IO uint32_t GPREG4;
X  volatile uint32_t GPREG4;
N  __IO uint8_t  RTC_AUXEN;
X  volatile uint8_t  RTC_AUXEN;
N       uint8_t  RESERVED12[3];
N  __IO uint8_t  RTC_AUX;
X  volatile uint8_t  RTC_AUX;
N       uint8_t  RESERVED13[3];
N  __IO uint8_t  ALSEC;
X  volatile uint8_t  ALSEC;
N       uint8_t  RESERVED14[3];
N  __IO uint8_t  ALMIN;
X  volatile uint8_t  ALMIN;
N       uint8_t  RESERVED15[3];
N  __IO uint8_t  ALHOUR;
X  volatile uint8_t  ALHOUR;
N       uint8_t  RESERVED16[3];
N  __IO uint8_t  ALDOM;
X  volatile uint8_t  ALDOM;
N       uint8_t  RESERVED17[3];
N  __IO uint8_t  ALDOW;
X  volatile uint8_t  ALDOW;
N       uint8_t  RESERVED18[3];
N  __IO uint16_t ALDOY;
X  volatile uint16_t ALDOY;
N       uint16_t RESERVED19;
N  __IO uint8_t  ALMON;
X  volatile uint8_t  ALMON;
N       uint8_t  RESERVED20[3];
N  __IO uint16_t ALYEAR;
X  volatile uint16_t ALYEAR;
N       uint16_t RESERVED21;
N  __IO uint32_t ERSTATUS;
X  volatile uint32_t ERSTATUS;
N  __IO uint32_t ERCONTROL;
X  volatile uint32_t ERCONTROL;
N  __IO uint32_t ERCOUNTERS;
X  volatile uint32_t ERCOUNTERS;
N       uint32_t RESERVED22;
N  __IO uint32_t ERFIRSTSTAMP0;
X  volatile uint32_t ERFIRSTSTAMP0;
N  __IO uint32_t ERFIRSTSTAMP1;
X  volatile uint32_t ERFIRSTSTAMP1;
N  __IO uint32_t ERFIRSTSTAMP2;
X  volatile uint32_t ERFIRSTSTAMP2;
N       uint32_t RESERVED23;
N  __IO uint32_t ERLASTSTAMP0;
X  volatile uint32_t ERLASTSTAMP0;
N  __IO uint32_t ERLASTSTAMP1;
X  volatile uint32_t ERLASTSTAMP1;
N  __IO uint32_t ERLASTSTAMP2;
X  volatile uint32_t ERLASTSTAMP2;
N} LPC_RTC_TypeDef;
N
N
N
N/*------------- Pin Connect Block (PINCON) -----------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t P0_0;				/* 0x000 */
X  volatile uint32_t P0_0;				 
N  __IO uint32_t P0_1;
X  volatile uint32_t P0_1;
N  __IO uint32_t P0_2;
X  volatile uint32_t P0_2;
N  __IO uint32_t P0_3;
X  volatile uint32_t P0_3;
N  __IO uint32_t P0_4;
X  volatile uint32_t P0_4;
N  __IO uint32_t P0_5;
X  volatile uint32_t P0_5;
N  __IO uint32_t P0_6;
X  volatile uint32_t P0_6;
N  __IO uint32_t P0_7;
X  volatile uint32_t P0_7;
N
N  __IO uint32_t P0_8;				/* 0x020 */
X  volatile uint32_t P0_8;				 
N  __IO uint32_t P0_9;
X  volatile uint32_t P0_9;
N  __IO uint32_t P0_10;
X  volatile uint32_t P0_10;
N  __IO uint32_t P0_11;
X  volatile uint32_t P0_11;
N  __IO uint32_t P0_12;
X  volatile uint32_t P0_12;
N  __IO uint32_t P0_13;
X  volatile uint32_t P0_13;
N  __IO uint32_t P0_14;
X  volatile uint32_t P0_14;
N  __IO uint32_t P0_15;
X  volatile uint32_t P0_15;
N
N  __IO uint32_t P0_16;				/* 0x040 */
X  volatile uint32_t P0_16;				 
N  __IO uint32_t P0_17;
X  volatile uint32_t P0_17;
N  __IO uint32_t P0_18;
X  volatile uint32_t P0_18;
N  __IO uint32_t P0_19;
X  volatile uint32_t P0_19;
N  __IO uint32_t P0_20;
X  volatile uint32_t P0_20;
N  __IO uint32_t P0_21;
X  volatile uint32_t P0_21;
N  __IO uint32_t P0_22;
X  volatile uint32_t P0_22;
N  __IO uint32_t P0_23;
X  volatile uint32_t P0_23;
N
N  __IO uint32_t P0_24;				/* 0x060 */
X  volatile uint32_t P0_24;				 
N  __IO uint32_t P0_25;
X  volatile uint32_t P0_25;
N  __IO uint32_t P0_26;
X  volatile uint32_t P0_26;
N  __IO uint32_t P0_27;
X  volatile uint32_t P0_27;
N  __IO uint32_t P0_28;
X  volatile uint32_t P0_28;
N  __IO uint32_t P0_29;
X  volatile uint32_t P0_29;
N  __IO uint32_t P0_30;
X  volatile uint32_t P0_30;
N  __IO uint32_t P0_31;
X  volatile uint32_t P0_31;
N
N  __IO uint32_t P1_0;				/* 0x080 */
X  volatile uint32_t P1_0;				 
N  __IO uint32_t P1_1;
X  volatile uint32_t P1_1;
N  __IO uint32_t P1_2;
X  volatile uint32_t P1_2;
N  __IO uint32_t P1_3;
X  volatile uint32_t P1_3;
N  __IO uint32_t P1_4;
X  volatile uint32_t P1_4;
N  __IO uint32_t P1_5;
X  volatile uint32_t P1_5;
N  __IO uint32_t P1_6;
X  volatile uint32_t P1_6;
N  __IO uint32_t P1_7;
X  volatile uint32_t P1_7;
N
N  __IO uint32_t P1_8;				/* 0x0A0 */
X  volatile uint32_t P1_8;				 
N  __IO uint32_t P1_9;
X  volatile uint32_t P1_9;
N  __IO uint32_t P1_10;
X  volatile uint32_t P1_10;
N  __IO uint32_t P1_11;
X  volatile uint32_t P1_11;
N  __IO uint32_t P1_12;
X  volatile uint32_t P1_12;
N  __IO uint32_t P1_13;
X  volatile uint32_t P1_13;
N  __IO uint32_t P1_14;
X  volatile uint32_t P1_14;
N  __IO uint32_t P1_15;
X  volatile uint32_t P1_15;
N
N  __IO uint32_t P1_16;				/* 0x0C0 */
X  volatile uint32_t P1_16;				 
N  __IO uint32_t P1_17;
X  volatile uint32_t P1_17;
N  __IO uint32_t P1_18;
X  volatile uint32_t P1_18;
N  __IO uint32_t P1_19;
X  volatile uint32_t P1_19;
N  __IO uint32_t P1_20;
X  volatile uint32_t P1_20;
N  __IO uint32_t P1_21;
X  volatile uint32_t P1_21;
N  __IO uint32_t P1_22;
X  volatile uint32_t P1_22;
N  __IO uint32_t P1_23;
X  volatile uint32_t P1_23;
N
N  __IO uint32_t P1_24;				/* 0x0E0 */
X  volatile uint32_t P1_24;				 
N  __IO uint32_t P1_25;
X  volatile uint32_t P1_25;
N  __IO uint32_t P1_26;
X  volatile uint32_t P1_26;
N  __IO uint32_t P1_27;
X  volatile uint32_t P1_27;
N  __IO uint32_t P1_28;
X  volatile uint32_t P1_28;
N  __IO uint32_t P1_29;
X  volatile uint32_t P1_29;
N  __IO uint32_t P1_30;
X  volatile uint32_t P1_30;
N  __IO uint32_t P1_31;
X  volatile uint32_t P1_31;
N
N  __IO uint32_t P2_0;				/* 0x100 */
X  volatile uint32_t P2_0;				 
N  __IO uint32_t P2_1;
X  volatile uint32_t P2_1;
N  __IO uint32_t P2_2;
X  volatile uint32_t P2_2;
N  __IO uint32_t P2_3;
X  volatile uint32_t P2_3;
N  __IO uint32_t P2_4;
X  volatile uint32_t P2_4;
N  __IO uint32_t P2_5;
X  volatile uint32_t P2_5;
N  __IO uint32_t P2_6;
X  volatile uint32_t P2_6;
N  __IO uint32_t P2_7;
X  volatile uint32_t P2_7;
N
N  __IO uint32_t P2_8;				/* 0x120 */
X  volatile uint32_t P2_8;				 
N  __IO uint32_t P2_9;
X  volatile uint32_t P2_9;
N  __IO uint32_t P2_10;
X  volatile uint32_t P2_10;
N  __IO uint32_t P2_11;
X  volatile uint32_t P2_11;
N  __IO uint32_t P2_12;
X  volatile uint32_t P2_12;
N  __IO uint32_t P2_13;
X  volatile uint32_t P2_13;
N  __IO uint32_t P2_14;
X  volatile uint32_t P2_14;
N  __IO uint32_t P2_15;
X  volatile uint32_t P2_15;
N
N  __IO uint32_t P2_16;				/* 0x140 */
X  volatile uint32_t P2_16;				 
N  __IO uint32_t P2_17;
X  volatile uint32_t P2_17;
N  __IO uint32_t P2_18;
X  volatile uint32_t P2_18;
N  __IO uint32_t P2_19;
X  volatile uint32_t P2_19;
N  __IO uint32_t P2_20;
X  volatile uint32_t P2_20;
N  __IO uint32_t P2_21;
X  volatile uint32_t P2_21;
N  __IO uint32_t P2_22;
X  volatile uint32_t P2_22;
N  __IO uint32_t P2_23;
X  volatile uint32_t P2_23;
N
N  __IO uint32_t P2_24;				/* 0x160 */
X  volatile uint32_t P2_24;				 
N  __IO uint32_t P2_25;
X  volatile uint32_t P2_25;
N  __IO uint32_t P2_26;
X  volatile uint32_t P2_26;
N  __IO uint32_t P2_27;
X  volatile uint32_t P2_27;
N  __IO uint32_t P2_28;
X  volatile uint32_t P2_28;
N  __IO uint32_t P2_29;
X  volatile uint32_t P2_29;
N  __IO uint32_t P2_30;
X  volatile uint32_t P2_30;
N  __IO uint32_t P2_31;
X  volatile uint32_t P2_31;
N
N  __IO uint32_t P3_0;				/* 0x180 */
X  volatile uint32_t P3_0;				 
N  __IO uint32_t P3_1;
X  volatile uint32_t P3_1;
N  __IO uint32_t P3_2;
X  volatile uint32_t P3_2;
N  __IO uint32_t P3_3;
X  volatile uint32_t P3_3;
N  __IO uint32_t P3_4;
X  volatile uint32_t P3_4;
N  __IO uint32_t P3_5;
X  volatile uint32_t P3_5;
N  __IO uint32_t P3_6;
X  volatile uint32_t P3_6;
N  __IO uint32_t P3_7;
X  volatile uint32_t P3_7;
N
N  __IO uint32_t P3_8;				/* 0x1A0 */
X  volatile uint32_t P3_8;				 
N  __IO uint32_t P3_9;
X  volatile uint32_t P3_9;
N  __IO uint32_t P3_10;
X  volatile uint32_t P3_10;
N  __IO uint32_t P3_11;
X  volatile uint32_t P3_11;
N  __IO uint32_t P3_12;
X  volatile uint32_t P3_12;
N  __IO uint32_t P3_13;
X  volatile uint32_t P3_13;
N  __IO uint32_t P3_14;
X  volatile uint32_t P3_14;
N  __IO uint32_t P3_15;
X  volatile uint32_t P3_15;
N
N  __IO uint32_t P3_16;				/* 0x1C0 */
X  volatile uint32_t P3_16;				 
N  __IO uint32_t P3_17;
X  volatile uint32_t P3_17;
N  __IO uint32_t P3_18;
X  volatile uint32_t P3_18;
N  __IO uint32_t P3_19;
X  volatile uint32_t P3_19;
N  __IO uint32_t P3_20;
X  volatile uint32_t P3_20;
N  __IO uint32_t P3_21;
X  volatile uint32_t P3_21;
N  __IO uint32_t P3_22;
X  volatile uint32_t P3_22;
N  __IO uint32_t P3_23;
X  volatile uint32_t P3_23;
N
N  __IO uint32_t P3_24;				/* 0x1E0 */
X  volatile uint32_t P3_24;				 
N  __IO uint32_t P3_25;
X  volatile uint32_t P3_25;
N  __IO uint32_t P3_26;
X  volatile uint32_t P3_26;
N  __IO uint32_t P3_27;
X  volatile uint32_t P3_27;
N  __IO uint32_t P3_28;
X  volatile uint32_t P3_28;
N  __IO uint32_t P3_29;
X  volatile uint32_t P3_29;
N  __IO uint32_t P3_30;
X  volatile uint32_t P3_30;
N  __IO uint32_t P3_31;
X  volatile uint32_t P3_31;
N
N  __IO uint32_t P4_0;				/* 0x200 */
X  volatile uint32_t P4_0;				 
N  __IO uint32_t P4_1;
X  volatile uint32_t P4_1;
N  __IO uint32_t P4_2;
X  volatile uint32_t P4_2;
N  __IO uint32_t P4_3;
X  volatile uint32_t P4_3;
N  __IO uint32_t P4_4;
X  volatile uint32_t P4_4;
N  __IO uint32_t P4_5;
X  volatile uint32_t P4_5;
N  __IO uint32_t P4_6;
X  volatile uint32_t P4_6;
N  __IO uint32_t P4_7;
X  volatile uint32_t P4_7;
N
N  __IO uint32_t P4_8;				/* 0x220 */
X  volatile uint32_t P4_8;				 
N  __IO uint32_t P4_9;
X  volatile uint32_t P4_9;
N  __IO uint32_t P4_10;
X  volatile uint32_t P4_10;
N  __IO uint32_t P4_11;
X  volatile uint32_t P4_11;
N  __IO uint32_t P4_12;
X  volatile uint32_t P4_12;
N  __IO uint32_t P4_13;
X  volatile uint32_t P4_13;
N  __IO uint32_t P4_14;
X  volatile uint32_t P4_14;
N  __IO uint32_t P4_15;
X  volatile uint32_t P4_15;
N
N  __IO uint32_t P4_16;				/* 0x240 */
X  volatile uint32_t P4_16;				 
N  __IO uint32_t P4_17;
X  volatile uint32_t P4_17;
N  __IO uint32_t P4_18;
X  volatile uint32_t P4_18;
N  __IO uint32_t P4_19;
X  volatile uint32_t P4_19;
N  __IO uint32_t P4_20;
X  volatile uint32_t P4_20;
N  __IO uint32_t P4_21;
X  volatile uint32_t P4_21;
N  __IO uint32_t P4_22;
X  volatile uint32_t P4_22;
N  __IO uint32_t P4_23;
X  volatile uint32_t P4_23;
N
N  __IO uint32_t P4_24;				/* 0x260 */
X  volatile uint32_t P4_24;				 
N  __IO uint32_t P4_25;
X  volatile uint32_t P4_25;
N  __IO uint32_t P4_26;
X  volatile uint32_t P4_26;
N  __IO uint32_t P4_27;
X  volatile uint32_t P4_27;
N  __IO uint32_t P4_28;
X  volatile uint32_t P4_28;
N  __IO uint32_t P4_29;
X  volatile uint32_t P4_29;
N  __IO uint32_t P4_30;
X  volatile uint32_t P4_30;
N  __IO uint32_t P4_31;
X  volatile uint32_t P4_31;
N
N  __IO uint32_t P5_0;				/* 0x280 */
X  volatile uint32_t P5_0;				 
N  __IO uint32_t P5_1;
X  volatile uint32_t P5_1;
N  __IO uint32_t P5_2;
X  volatile uint32_t P5_2;
N  __IO uint32_t P5_3;
X  volatile uint32_t P5_3;
N  __IO uint32_t P5_4;				/* 0x290 */
X  volatile uint32_t P5_4;				 
N} LPC_IOCON_TypeDef;
N
N
N
N
N
N
N/*------------- Synchronous Serial Communication (SSP) -----------------------*/
Ntypedef struct
N{
N  __IO uint32_t CR0;                    /*!< Offset: 0x000 Control Register 0 (R/W) */
X  volatile uint32_t CR0;                     
N  __IO uint32_t CR1;                    /*!< Offset: 0x004 Control Register 1 (R/W) */
X  volatile uint32_t CR1;                     
N  __IO uint32_t DR;                     /*!< Offset: 0x008 Data Register (R/W) */
X  volatile uint32_t DR;                      
N  __I  uint32_t SR;                     /*!< Offset: 0x00C Status Registe (R/ ) */
X  volatile const  uint32_t SR;                      
N  __IO uint32_t CPSR;                   /*!< Offset: 0x010 Clock Prescale Register (R/W) */
X  volatile uint32_t CPSR;                    
N  __IO uint32_t IMSC;                   /*!< Offset: 0x014 Interrupt Mask Set and Clear Register (R/W) */
X  volatile uint32_t IMSC;                    
N  __IO uint32_t RIS;                    /*!< Offset: 0x018 Raw Interrupt Status Register (R/W) */
X  volatile uint32_t RIS;                     
N  __IO uint32_t MIS;                    /*!< Offset: 0x01C Masked Interrupt Status Register (R/W) */
X  volatile uint32_t MIS;                     
N  __IO uint32_t ICR;                    /*!< Offset: 0x020 SSPICR Interrupt Clear Register (R/W) */
X  volatile uint32_t ICR;                     
N  __IO uint32_t DMACR;
X  volatile uint32_t DMACR;
N} LPC_SSP_TypeDef;
N
N/*------------- Analog-to-Digital Converter (ADC) ----------------------------*/
Ntypedef struct
N{
N  __IO uint32_t CR;                     /*!< Offset: 0x000       A/D Control Register (R/W) */
X  volatile uint32_t CR;                      
N  __IO uint32_t GDR;                    /*!< Offset: 0x004       A/D Global Data Register (R/W) */
X  volatile uint32_t GDR;                     
N       uint32_t RESERVED0;
N  __IO uint32_t INTEN;                  /*!< Offset: 0x00C       A/D Interrupt Enable Register (R/W) */
X  volatile uint32_t INTEN;                   
N  __IO uint32_t DR[8];                  /*!< Offset: 0x010-0x02C A/D Channel 0..7 Data Register (R/W) */
X  volatile uint32_t DR[8];                   
N  __I  uint32_t STAT;                   /*!< Offset: 0x030       A/D Status Register (R/ ) */
X  volatile const  uint32_t STAT;                    
N  __IO uint32_t ADTRM;
X  volatile uint32_t ADTRM;
N} LPC_ADC_TypeDef;
N
N/*------------- Controller Area Network (CAN) --------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t mask[512];              /* ID Masks                           */
X  volatile uint32_t mask[512];               
N} LPC_CANAF_RAM_TypeDef;
N
Ntypedef struct                          /* Acceptance Filter Registers        */
N{
N	///Offset: 0x00000000 - Acceptance Filter Register
N	__IO uint32_t AFMR;
X	volatile uint32_t AFMR;
N
N	///Offset: 0x00000004 - Standard Frame Individual Start Address Register
N	__IO uint32_t SFF_sa;
X	volatile uint32_t SFF_sa;
N
N	///Offset: 0x00000008 - Standard Frame Group Start Address Register
N	__IO uint32_t SFF_GRP_sa;
X	volatile uint32_t SFF_GRP_sa;
N
N	///Offset: 0x0000000C - Extended Frame Start Address Register
N	__IO uint32_t EFF_sa;
X	volatile uint32_t EFF_sa;
N
N	///Offset: 0x00000010 - Extended Frame Group Start Address Register
N	__IO uint32_t EFF_GRP_sa;
X	volatile uint32_t EFF_GRP_sa;
N
N	///Offset: 0x00000014 - End of AF Tables register
N	__IO uint32_t ENDofTable;
X	volatile uint32_t ENDofTable;
N
N	///Offset: 0x00000018 - LUT Error Address register
N	__I  uint32_t LUTerrAd;
X	volatile const  uint32_t LUTerrAd;
N
N	///Offset: 0x0000001C - LUT Error Register
N	__I  uint32_t LUTerr;
X	volatile const  uint32_t LUTerr;
N
N	///Offset: 0x00000020 - CAN Central Transmit Status Register
N	__IO uint32_t FCANIE;
X	volatile uint32_t FCANIE;
N
N	///Offset: 0x00000024 - FullCAN Interrupt and Capture registers 0
N	__IO uint32_t FCANIC0;
X	volatile uint32_t FCANIC0;
N
N	///Offset: 0x00000028 - FullCAN Interrupt and Capture registers 1
N	__IO uint32_t FCANIC1;
X	volatile uint32_t FCANIC1;
N} LPC_CANAF_TypeDef;
N
Ntypedef struct                          /* Central Registers                  */
N{
N  __I  uint32_t TxSR;
X  volatile const  uint32_t TxSR;
N  __I  uint32_t RxSR;
X  volatile const  uint32_t RxSR;
N  __I  uint32_t MSR;
X  volatile const  uint32_t MSR;
N} LPC_CANCR_TypeDef;
N
Ntypedef struct                          /* Controller Registers               */
N{
N	///Offset: 0x00000000 - Controls the operating mode of the CAN Controller
N	__IO uint32_t MOD;
X	volatile uint32_t MOD;
N
N	///Offset: 0x00000004 - Command bits that affect the state
N	__O  uint32_t CMR;
X	volatile  uint32_t CMR;
N
N	///Offset: 0x00000008 - Global Controller Status and Error Counters
N	__IO uint32_t GSR;
X	volatile uint32_t GSR;
N
N	///Offset: 0x0000000C - Interrupt status, Arbitration Lost Capture, Error Code Capture
N	__I  uint32_t ICR;
X	volatile const  uint32_t ICR;
N
N	///Offset: 0x00000010 - Interrupt Enable Register
N	__IO uint32_t IER;
X	volatile uint32_t IER;
N
N	///Offset: 0x00000014 - Bus Timing Register
N	__IO uint32_t BTR;
X	volatile uint32_t BTR;
N
N	///Offset: 0x00000018 - Error Warning Limit
N	__IO uint32_t EWL;
X	volatile uint32_t EWL;
N
N	///Offset: 0x0000001C - Status Register
N	__I  uint32_t SR;
X	volatile const  uint32_t SR;
N
N	///Offset: 0x00000020 - Receive frame status
N	__IO uint32_t RFS;
X	volatile uint32_t RFS;
N
N	///Offset: 0x00000024 - Received Identifier
N	__IO uint32_t RID;
X	volatile uint32_t RID;
N
N	///Offset: 0x00000028 - Received data bytes 1-4
N	__IO uint32_t RDA;
X	volatile uint32_t RDA;
N
N	///Offset: 0x0000002C - Received data bytes 5-8
N	__IO uint32_t RDB;
X	volatile uint32_t RDB;
N
N	///Offset: 0x00000030 - Transmit frame info (Tx Buffer 1)
N	__IO uint32_t TFI1;
X	volatile uint32_t TFI1;
N
N	///Offset: 0x00000034 - Transmit Identifier (Tx Buffer 1)
N	__IO uint32_t TID1;
X	volatile uint32_t TID1;
N
N	///Offset: 0x00000038 - Transmit data bytes 1-4 (Tx Buffer 1)
N	__IO uint32_t TDA1;
X	volatile uint32_t TDA1;
N
N	///Offset: 0x0000003C - Transmit data bytes 5-8 (Tx Buffer 1)
N	__IO uint32_t TDB1;
X	volatile uint32_t TDB1;
N
N	///Offset: 0x00000040 - Transmit frame info (Tx Buffer 2)
N	__IO uint32_t TFI2;
X	volatile uint32_t TFI2;
N
N	///Offset: 0x00000044 - Transmit Identifier (Tx Buffer 2)
N	__IO uint32_t TID2;
X	volatile uint32_t TID2;
N
N	///Offset: 0x00000048 - Transmit data bytes 1-4 (Tx Buffer 2)
N	__IO uint32_t TDA2;
X	volatile uint32_t TDA2;
N
N	///Offset: 0x0000004C - Transmit data bytes 5-8 (Tx Buffer 2)
N	__IO uint32_t TDB2;
X	volatile uint32_t TDB2;
N
N	///Offset: 0x00000050 - Transmit frame info (Tx Buffer 3)
N	__IO uint32_t TFI3;
X	volatile uint32_t TFI3;
N
N	///Offset: 0x00000054 - Transmit Identifier (Tx Buffer 3)
N	__IO uint32_t TID3;
X	volatile uint32_t TID3;
N
N	///Offset: 0x00000058 - Transmit data bytes 1-4 (Tx Buffer 3)
N	__IO uint32_t TDA3;
X	volatile uint32_t TDA3;
N
N	///Offset: 0x0000005C - Transmit data bytes 5-8 (Tx Buffer 3)
N	__IO uint32_t TDB3;
X	volatile uint32_t TDB3;
N} LPC_CAN_TypeDef;
N
N/*------------- Digital-to-Analog Converter (DAC) ----------------------------*/
Ntypedef struct
N{
N  __IO uint32_t CR;
X  volatile uint32_t CR;
N  __IO uint32_t CTRL;
X  volatile uint32_t CTRL;
N  __IO uint32_t CNTVAL;
X  volatile uint32_t CNTVAL;
N} LPC_DAC_TypeDef;
N
N
N/*------------- Inter IC Sound (I2S) -----------------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t DAO;
X  volatile uint32_t DAO;
N  __IO uint32_t DAI;
X  volatile uint32_t DAI;
N  __O  uint32_t TXFIFO;
X  volatile  uint32_t TXFIFO;
N  __I  uint32_t RXFIFO;
X  volatile const  uint32_t RXFIFO;
N  __I  uint32_t STATE;
X  volatile const  uint32_t STATE;
N  __IO uint32_t DMA1;
X  volatile uint32_t DMA1;
N  __IO uint32_t DMA2;
X  volatile uint32_t DMA2;
N  __IO uint32_t IRQ;
X  volatile uint32_t IRQ;
N  __IO uint32_t TXRATE;
X  volatile uint32_t TXRATE;
N  __IO uint32_t RXRATE;
X  volatile uint32_t RXRATE;
N  __IO uint32_t TXBITRATE;
X  volatile uint32_t TXBITRATE;
N  __IO uint32_t RXBITRATE;
X  volatile uint32_t RXBITRATE;
N  __IO uint32_t TXMODE;
X  volatile uint32_t TXMODE;
N  __IO uint32_t RXMODE;
X  volatile uint32_t RXMODE;
N} LPC_I2S_TypeDef;
N
N
N
N
N
N
N/*------------- Motor Control Pulse-Width Modulation (MCPWM) -----------------*/
Ntypedef struct
N{
N  __I  uint32_t CON;
X  volatile const  uint32_t CON;
N  __O  uint32_t CON_SET;
X  volatile  uint32_t CON_SET;
N  __O  uint32_t CON_CLR;
X  volatile  uint32_t CON_CLR;
N  __I  uint32_t CAPCON;
X  volatile const  uint32_t CAPCON;
N  __O  uint32_t CAPCON_SET;
X  volatile  uint32_t CAPCON_SET;
N  __O  uint32_t CAPCON_CLR;
X  volatile  uint32_t CAPCON_CLR;
N  __IO uint32_t TC0;
X  volatile uint32_t TC0;
N  __IO uint32_t TC1;
X  volatile uint32_t TC1;
N  __IO uint32_t TC2;
X  volatile uint32_t TC2;
N  __IO uint32_t LIM0;
X  volatile uint32_t LIM0;
N  __IO uint32_t LIM1;
X  volatile uint32_t LIM1;
N  __IO uint32_t LIM2;
X  volatile uint32_t LIM2;
N  __IO uint32_t MAT0;
X  volatile uint32_t MAT0;
N  __IO uint32_t MAT1;
X  volatile uint32_t MAT1;
N  __IO uint32_t MAT2;
X  volatile uint32_t MAT2;
N  __IO uint32_t DT;
X  volatile uint32_t DT;
N  __IO uint32_t CP;
X  volatile uint32_t CP;
N  __IO uint32_t CAP0;
X  volatile uint32_t CAP0;
N  __IO uint32_t CAP1;
X  volatile uint32_t CAP1;
N  __IO uint32_t CAP2;
X  volatile uint32_t CAP2;
N  __I  uint32_t INTEN;
X  volatile const  uint32_t INTEN;
N  __O  uint32_t INTEN_SET;
X  volatile  uint32_t INTEN_SET;
N  __O  uint32_t INTEN_CLR;
X  volatile  uint32_t INTEN_CLR;
N  __I  uint32_t CNTCON;
X  volatile const  uint32_t CNTCON;
N  __O  uint32_t CNTCON_SET;
X  volatile  uint32_t CNTCON_SET;
N  __O  uint32_t CNTCON_CLR;
X  volatile  uint32_t CNTCON_CLR;
N  __I  uint32_t INTF;
X  volatile const  uint32_t INTF;
N  __O  uint32_t INTF_SET;
X  volatile  uint32_t INTF_SET;
N  __O  uint32_t INTF_CLR;
X  volatile  uint32_t INTF_CLR;
N  __O  uint32_t CAP_CLR;
X  volatile  uint32_t CAP_CLR;
N} LPC_MCPWM_TypeDef;
N
N/*------------- Quadrature Encoder Interface (QEI) ---------------------------*/
Ntypedef struct
N{
N  __O  uint32_t CON;
X  volatile  uint32_t CON;
N  __I  uint32_t STAT;
X  volatile const  uint32_t STAT;
N  __IO uint32_t CONF;
X  volatile uint32_t CONF;
N  __I  uint32_t POS;
X  volatile const  uint32_t POS;
N  __IO uint32_t MAXPOS;
X  volatile uint32_t MAXPOS;
N  __IO uint32_t CMPOS0;
X  volatile uint32_t CMPOS0;
N  __IO uint32_t CMPOS1;
X  volatile uint32_t CMPOS1;
N  __IO uint32_t CMPOS2;
X  volatile uint32_t CMPOS2;
N  __I  uint32_t INXCNT;
X  volatile const  uint32_t INXCNT;
N  __IO uint32_t INXCMP0;
X  volatile uint32_t INXCMP0;
N  __IO uint32_t LOAD;
X  volatile uint32_t LOAD;
N  __I  uint32_t TIME;
X  volatile const  uint32_t TIME;
N  __I  uint32_t VEL;
X  volatile const  uint32_t VEL;
N  __I  uint32_t CAP;
X  volatile const  uint32_t CAP;
N  __IO uint32_t VELCOMP;
X  volatile uint32_t VELCOMP;
N  __IO uint32_t FILTERPHA;
X  volatile uint32_t FILTERPHA;
N  __IO uint32_t FILTERPHB;
X  volatile uint32_t FILTERPHB;
N  __IO uint32_t FILTERINX;
X  volatile uint32_t FILTERINX;
N  __IO uint32_t WINDOW;
X  volatile uint32_t WINDOW;
N  __IO uint32_t INXCMP1;
X  volatile uint32_t INXCMP1;
N  __IO uint32_t INXCMP2;
X  volatile uint32_t INXCMP2;
N       uint32_t RESERVED0[993];
N  __O  uint32_t IEC;
X  volatile  uint32_t IEC;
N  __O  uint32_t IES;
X  volatile  uint32_t IES;
N  __I  uint32_t INTSTAT;
X  volatile const  uint32_t INTSTAT;
N  __I  uint32_t IE;
X  volatile const  uint32_t IE;
N  __O  uint32_t CLR;
X  volatile  uint32_t CLR;
N  __O  uint32_t SET;
X  volatile  uint32_t SET;
N} LPC_QEI_TypeDef;
N
N/*------------- SD/MMC card Interface (MCI)-----------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t POWER;
X  volatile uint32_t POWER;
N  __IO uint32_t CLOCK;
X  volatile uint32_t CLOCK;
N  __IO uint32_t ARGUMENT;
X  volatile uint32_t ARGUMENT;
N  __IO uint32_t COMMAND;
X  volatile uint32_t COMMAND;
N  __I  uint32_t RESP_CMD;
X  volatile const  uint32_t RESP_CMD;
N  __I  uint32_t RESP0;
X  volatile const  uint32_t RESP0;
N  __I  uint32_t RESP1;
X  volatile const  uint32_t RESP1;
N  __I  uint32_t RESP2;
X  volatile const  uint32_t RESP2;
N  __I  uint32_t RESP3;
X  volatile const  uint32_t RESP3;
N  __IO uint32_t DATATMR;
X  volatile uint32_t DATATMR;
N  __IO uint32_t DATALEN;
X  volatile uint32_t DATALEN;
N  __IO uint32_t DATACTRL;
X  volatile uint32_t DATACTRL;
N  __I  uint32_t DATACNT;
X  volatile const  uint32_t DATACNT;
N  __I  uint32_t STATUS;
X  volatile const  uint32_t STATUS;
N  __O  uint32_t CLEAR;
X  volatile  uint32_t CLEAR;
N  __IO uint32_t MASK0;
X  volatile uint32_t MASK0;
N       uint32_t RESERVED0[2];
N  __I  uint32_t FIFOCNT;
X  volatile const  uint32_t FIFOCNT;
N       uint32_t RESERVED1[13];
N  __IO uint32_t FIFO[16];
X  volatile uint32_t FIFO[16];
N} LPC_MCI_TypeDef;
N
N
N
N
N
N
N
N
N
N
N/*------------- EEPROM Controller (EEPROM) -----------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t CMD;			/* 0x0080 */
X  volatile uint32_t CMD;			 
N  __IO uint32_t ADDR;
X  volatile uint32_t ADDR;
N  __IO uint32_t WDATA;
X  volatile uint32_t WDATA;
N  __IO uint32_t RDATA;
X  volatile uint32_t RDATA;
N  __IO uint32_t WSTATE;			/* 0x0090 */
X  volatile uint32_t WSTATE;			 
N  __IO uint32_t CLKDIV;
X  volatile uint32_t CLKDIV;
N  __IO uint32_t PWRDWN;			/* 0x0098 */
X  volatile uint32_t PWRDWN;			 
N       uint32_t RESERVED0[975];
N  __IO uint32_t INT_CLR_ENABLE;	/* 0x0FD8 */
X  volatile uint32_t INT_CLR_ENABLE;	 
N  __IO uint32_t INT_SET_ENABLE;
X  volatile uint32_t INT_SET_ENABLE;
N  __IO uint32_t INT_STATUS;		/* 0x0FE0 */
X  volatile uint32_t INT_STATUS;		 
N  __IO uint32_t INT_ENABLE;
X  volatile uint32_t INT_ENABLE;
N  __IO uint32_t INT_CLR_STATUS;
X  volatile uint32_t INT_CLR_STATUS;
N  __IO uint32_t INT_SET_STATUS;
X  volatile uint32_t INT_SET_STATUS;
N} LPC_EEPROM_TypeDef;
N
N
N/*------------- COMPARATOR ----------------------------------------------------*/
N
Ntypedef struct {                                    /*!< (@ 0x40020000) COMPARATOR Structure                                   */
N  __IO uint32_t  CTRL;                              /*!< (@ 0x40020000) Comparator block control register                      */
X  volatile uint32_t  CTRL;                               
N  __IO uint32_t  CTRL0;                             /*!< (@ 0x40020004) Comparator 0 control register                          */
X  volatile uint32_t  CTRL0;                              
N  __IO uint32_t  CTRL1;                             /*!< (@ 0x40020008) Comparator 1 control register                          */
X  volatile uint32_t  CTRL1;                              
N} LPC_COMPARATOR_Type;
N
N
N#if defined ( __CC_ARM   )
X#if 1L
N#pragma no_anon_unions
N#elif defined ( __ICCARM__ )
S#pragma language=restore
N#endif
N
N/******************************************************************************/
N/*                         Peripheral memory map                              */
N/******************************************************************************/
N/* Base addresses                                                             */
N#define LPC_FLASH_BASE        (0x00000000UL)
N#define LPC_RAM_BASE          (0x10000000UL)
N#define LPC_PERI_RAM_BASE     (0x20000000UL)
N#define LPC_APB0_BASE         (0x40000000UL)
N#define LPC_APB1_BASE         (0x40080000UL)
N#define LPC_AHBRAM1_BASE      (0x20004000UL)
N#define LPC_AHB_BASE          (0x20080000UL)
N#define LPC_CM3_BASE          (0xE0000000UL)
N
N/* APB0 peripherals                                                           */
N#define LPC_WDT_BASE          (LPC_APB0_BASE + 0x00000)
N#define LPC_TIM0_BASE         (LPC_APB0_BASE + 0x04000)
N#define LPC_TIM1_BASE         (LPC_APB0_BASE + 0x08000)
N#define LPC_UART0_BASE        (LPC_APB0_BASE + 0x0C000)
N#define LPC_UART1_BASE        (LPC_APB0_BASE + 0x10000)
N#define LPC_PWM0_BASE         (LPC_APB0_BASE + 0x14000)
N#define LPC_PWM1_BASE         (LPC_APB0_BASE + 0x18000)
N#define LPC_I2C0_BASE         (LPC_APB0_BASE + 0x1C000)
N#define LPC_COMPARATOR_BASE   (LPC_APB0_BASE + 0x20000)					
N#define LPC_RTC_BASE          (LPC_APB0_BASE + 0x24000)
N#define LPC_GPIOINT_BASE      (LPC_APB0_BASE + 0x28080)
N#define LPC_IOCON_BASE        (LPC_APB0_BASE + 0x2C000)
N#define LPC_SSP1_BASE         (LPC_APB0_BASE + 0x30000)
N#define LPC_ADC_BASE          (LPC_APB0_BASE + 0x34000)
N#define LPC_CANAF_RAM_BASE    (LPC_APB0_BASE + 0x38000)
N#define LPC_CANAF_BASE        (LPC_APB0_BASE + 0x3C000)
N#define LPC_CANCR_BASE        (LPC_APB0_BASE + 0x40000)
N#define LPC_CAN1_BASE         (LPC_APB0_BASE + 0x44000)
N#define LPC_CAN2_BASE         (LPC_APB0_BASE + 0x48000)
N#define LPC_I2C1_BASE         (LPC_APB0_BASE + 0x5C000)
N
N/* APB1 peripherals                                                           */
N#define LPC_SSP0_BASE         (LPC_APB1_BASE + 0x08000)
N#define LPC_DAC_BASE          (LPC_APB1_BASE + 0x0C000)
N#define LPC_TIM2_BASE         (LPC_APB1_BASE + 0x10000)
N#define LPC_TIM3_BASE         (LPC_APB1_BASE + 0x14000)
N#define LPC_UART2_BASE        (LPC_APB1_BASE + 0x18000)
N#define LPC_UART3_BASE        (LPC_APB1_BASE + 0x1C000)
N#define LPC_I2C2_BASE         (LPC_APB1_BASE + 0x20000)
N#define LPC_UART4_BASE        (LPC_APB1_BASE + 0x24000)
N#define LPC_I2S_BASE          (LPC_APB1_BASE + 0x28000)
N#define LPC_SSP2_BASE         (LPC_APB1_BASE + 0x2C000)
N#define LPC_MCPWM_BASE        (LPC_APB1_BASE + 0x38000)
N#define LPC_QEI_BASE          (LPC_APB1_BASE + 0x3C000)
N#define LPC_MCI_BASE          (LPC_APB1_BASE + 0x40000)
N#define LPC_SC_BASE           (LPC_APB1_BASE + 0x7C000)
N
N/* AHB peripherals                                                            */
N#define LPC_GPDMA_BASE        (LPC_AHB_BASE  + 0x00000)
N#define LPC_GPDMACH0_BASE     (LPC_AHB_BASE  + 0x00100)
N#define LPC_GPDMACH1_BASE     (LPC_AHB_BASE  + 0x00120)
N#define LPC_GPDMACH2_BASE     (LPC_AHB_BASE  + 0x00140)
N#define LPC_GPDMACH3_BASE     (LPC_AHB_BASE  + 0x00160)
N#define LPC_GPDMACH4_BASE     (LPC_AHB_BASE  + 0x00180)
N#define LPC_GPDMACH5_BASE     (LPC_AHB_BASE  + 0x001A0)
N#define LPC_GPDMACH6_BASE     (LPC_AHB_BASE  + 0x001C0)
N#define LPC_GPDMACH7_BASE     (LPC_AHB_BASE  + 0x001E0)
N#define LPC_EMAC_BASE         (LPC_AHB_BASE  + 0x04000)
N#define LPC_LCD_BASE          (LPC_AHB_BASE  + 0x08000)
N#define LPC_USB_BASE          (LPC_AHB_BASE  + 0x0C000)
N#define LPC_CRC_BASE          (LPC_AHB_BASE  + 0x10000)
N#define LPC_GPIO0_BASE        (LPC_AHB_BASE  + 0x18000)
N#define LPC_GPIO1_BASE        (LPC_AHB_BASE  + 0x18020)
N#define LPC_GPIO2_BASE        (LPC_AHB_BASE  + 0x18040)
N#define LPC_GPIO3_BASE        (LPC_AHB_BASE  + 0x18060)
N#define LPC_GPIO4_BASE        (LPC_AHB_BASE  + 0x18080)
N#define LPC_GPIO5_BASE        (LPC_AHB_BASE  + 0x180A0)
N#define LPC_EMC_BASE          (LPC_AHB_BASE  + 0x1C000)
N
N#define LPC_EEPROM_BASE       (LPC_FLASH_BASE+ 0x200080)
N
N
N/******************************************************************************/
N/*                         Peripheral declaration                             */
N/******************************************************************************/
N#define LPC_SC                ((LPC_SC_TypeDef        *) LPC_SC_BASE       )
N#define LPC_WDT               ((LPC_WDT_TypeDef       *) LPC_WDT_BASE      )
N#define LPC_TIM0              ((LPC_TIM_TypeDef       *) LPC_TIM0_BASE     )
N#define LPC_TIM1              ((LPC_TIM_TypeDef       *) LPC_TIM1_BASE     )
N#define LPC_TIM2              ((LPC_TIM_TypeDef       *) LPC_TIM2_BASE     )
N#define LPC_TIM3              ((LPC_TIM_TypeDef       *) LPC_TIM3_BASE     )
N#define LPC_UART0             ((LPC_UART_TypeDef      *) LPC_UART0_BASE    )
N#define LPC_UART1             ((LPC_UART1_TypeDef     *) LPC_UART1_BASE    )
N#define LPC_UART2             ((LPC_UART_TypeDef      *) LPC_UART2_BASE    )
N#define LPC_UART3             ((LPC_UART_TypeDef      *) LPC_UART3_BASE    )
N#define LPC_UART4             ((LPC_UART4_TypeDef     *) LPC_UART4_BASE    )
N#define LPC_PWM0              ((LPC_PWM_TypeDef       *) LPC_PWM0_BASE     )
N#define LPC_PWM1              ((LPC_PWM_TypeDef       *) LPC_PWM1_BASE     )
N#define LPC_I2C0              ((LPC_I2C_TypeDef       *) LPC_I2C0_BASE     )
N#define LPC_I2C1              ((LPC_I2C_TypeDef       *) LPC_I2C1_BASE     )
N#define LPC_I2C2              ((LPC_I2C_TypeDef       *) LPC_I2C2_BASE     )
N#define LPC_I2S               ((LPC_I2S_TypeDef       *) LPC_I2S_BASE      )
N#define LPC_COMPARATOR        ((LPC_COMPARATOR_Type	  *) LPC_COMPARATOR_BASE)
N#define LPC_RTC               ((LPC_RTC_TypeDef       *) LPC_RTC_BASE      )
N#define LPC_GPIOINT           ((LPC_GPIOINT_TypeDef   *) LPC_GPIOINT_BASE  )
N#define LPC_IOCON             ((LPC_IOCON_TypeDef     *) LPC_IOCON_BASE    )
N#define LPC_SSP0              ((LPC_SSP_TypeDef       *) LPC_SSP0_BASE     )
N#define LPC_SSP1              ((LPC_SSP_TypeDef       *) LPC_SSP1_BASE     )
N#define LPC_SSP2              ((LPC_SSP_TypeDef       *) LPC_SSP2_BASE     )
N#define LPC_ADC               ((LPC_ADC_TypeDef       *) LPC_ADC_BASE      )
N#define LPC_DAC               ((LPC_DAC_TypeDef       *) LPC_DAC_BASE      )
N#define LPC_CANAF_RAM         ((LPC_CANAF_RAM_TypeDef *) LPC_CANAF_RAM_BASE)
N#define LPC_CANAF             ((LPC_CANAF_TypeDef     *) LPC_CANAF_BASE    )
N#define LPC_CANCR             ((LPC_CANCR_TypeDef     *) LPC_CANCR_BASE    )
N#define LPC_CAN1              ((LPC_CAN_TypeDef       *) LPC_CAN1_BASE     )
N#define LPC_CAN2              ((LPC_CAN_TypeDef       *) LPC_CAN2_BASE     )
N#define LPC_MCPWM             ((LPC_MCPWM_TypeDef     *) LPC_MCPWM_BASE    )
N#define LPC_QEI               ((LPC_QEI_TypeDef       *) LPC_QEI_BASE      )
N#define LPC_MCI               ((LPC_MCI_TypeDef       *) LPC_MCI_BASE      )
N#define LPC_GPDMA             ((LPC_GPDMA_TypeDef     *) LPC_GPDMA_BASE    )
N#define LPC_GPDMACH0          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH0_BASE )
N#define LPC_GPDMACH1          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH1_BASE )
N#define LPC_GPDMACH2          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH2_BASE )
N#define LPC_GPDMACH3          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH3_BASE )
N#define LPC_GPDMACH4          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH4_BASE )
N#define LPC_GPDMACH5          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH5_BASE )
N#define LPC_GPDMACH6          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH6_BASE )
N#define LPC_GPDMACH7          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH7_BASE )
N#define LPC_EMAC              ((LPC_EMAC_TypeDef      *) LPC_EMAC_BASE     )
N#define LPC_LCD               ((LPC_LCD_TypeDef       *) LPC_LCD_BASE      )
N#define LPC_USB               ((LPC_USB_TypeDef       *) LPC_USB_BASE      )
N#define LPC_GPIO0             ((LPC_GPIO_TypeDef      *) LPC_GPIO0_BASE    )
N#define LPC_GPIO1             ((LPC_GPIO_TypeDef      *) LPC_GPIO1_BASE    )
N#define LPC_GPIO2             ((LPC_GPIO_TypeDef      *) LPC_GPIO2_BASE    )
N#define LPC_GPIO3             ((LPC_GPIO_TypeDef      *) LPC_GPIO3_BASE    )
N#define LPC_GPIO4             ((LPC_GPIO_TypeDef      *) LPC_GPIO4_BASE    )
N#define LPC_GPIO5             ((LPC_GPIO_TypeDef      *) LPC_GPIO5_BASE    )
N#define LPC_EMC               ((LPC_EMC_TypeDef       *) LPC_EMC_BASE      )
N#define LPC_CRC               ((LPC_CRC_TypeDef       *) LPC_CRC_BASE      )
N#define LPC_EEPROM            ((LPC_EEPROM_TypeDef    *) LPC_EEPROM_BASE   )
N
N
N
N#endif  // __LPC407x_8x_177x_8x_H__
L 44 ".\Drivers\include\lpc_pinsel.h" 2
N#include "lpc_types.h"
N
N
N/* Public Macros -------------------------------------------------------------- */
N/** @defgroup PINSEL_Public_Macros PINSEL Public Macros
N * @{
N */
N
N/* Macros define IOCON bits*/
N
N/** Selects pin functions */
N#define IOCON_FUNC_POS              (0)
N#define IOCON_FUNC_MASK             (0x07<<IOCON_FUNC_POS)
N
N/** Selects output function mode (on-chip pull-up/pull-down resistor control */
N#define IOCON_MODE_POS              (3)
N#define IOCON_MODE_MASK             (0x03<<IOCON_MODE_POS)
N#define IOCON_MODE_PLAIN                ((0<<IOCON_MODE_POS))
N#define IOCON_MODE_PULLDOWN     ((1<<IOCON_MODE_POS))
N#define IOCON_MODE_PULLUP           ((2<<IOCON_MODE_POS))
N#define IOCON_MODE_REPEATER         ((3<<IOCON_MODE_POS))
N
N/** Hysteresis */
N#define IOCON_HYS_POS               (5)
N#define IOCON_HYS_MASK              (0x01<<IOCON_HYS_POS)
N#define IOCON_HYS_ENABLE                ((1<<IOCON_HYS_POS))
N
N/** Input polarity */
N#define IOCON_INVERT_POS                (6)
N#define IOCON_INVERT_MASK           (0x01<<IOCON_INVERT_POS)
N#define IOCON_INVERT_INPUT          (1<<IOCON_INVERT_POS)
N
N/** Selects Analog/Digital mode */
N#define IOCON_ADMODE_POS            (7)
N#define IOCON_ADMODE_MASK           (0x01<<IOCON_ADMODE_POS)
N#define IOCON_ANALOG_MODE           (0<<IOCON_ADMODE_POS)
N#define IOCON_DIGITIAL_MODE         (1<<IOCON_ADMODE_POS)
N
N/* Controls Glitch Filter */
N#define IOCON_FILTER_POS                (8)
N#define IOCON_FILTER_MASK               (0x01<<IOCON_FILTER_POS)
N#define IOCON_10ns_FILTER_ENABLE            (0<<IOCON_FILTER_POS)
N#define IOCON_10ns_FILTER_DISABLE           (1<<IOCON_FILTER_POS)
N
N/** I2C 50ns glitch filter and slew rate control */ 
N#define IOCON_HS_POS                    (8)
N#define IOCON_HS_MASK               (0x01<<IOCON_HS_POS)
N#define IOCON_I2C_FILTER_ENABLE     (0<<IOCON_HS_POS)
N#define IOCON_I2C_FILTER_DISABLE        (1<<IOCON_HS_POS)
N
N/** Driver Output Slew Rate Control*/
N#define IOCON_SLEW_POS              (9)
N#define IOCON_SLEW_MASK             (0x01<<IOCON_SLEW_POS)
N#define IOCON_SLEW_ENABLE           ((1<<IOCON_SLEW_POS))
N
N/** Controls sink current capability of the pin*/
N#define IOCON_HIDRIVE_POS               (9)
N#define IOCON_HIDRIVE_MASK          (0x01<<IOCON_HIDRIVE_POS)
N#define IOCON_I2CMODE_FASTPLUS      (1<<IOCON_HIDRIVE_POS)
N
N/** Controls open-drain mode */
N#define IOCON_OD_POS                    (10)
N#define IOCON_OD_MASK               (0x01<<IOCON_OD_POS)
N#define IOCON_OPENDRAIN_MODE        (1<<IOCON_OD_POS)
N
N/** DAC enable control */
N#define IOCON_DACEN_POS             (16)
N#define IOCON_DACEN_MASK            (0x01<<IOCON_DACEN_POS)
N#define IOCON_DAC_ENABLE                (1<<IOCON_DACEN_POS)
N
N/* Macros define for Return Code */
Ntypedef    int32_t      PINSEL_RET_CODE;
N#define PINSEL_RET_OK               (0)
N#define PINSEL_RET_INVALID_PIN      (0x10000001)
N#define PINSEL_RET_NOT_SUPPORT      (0x10000002)
N#define PINSEL_RET_ERR              (-1)
N
N/**
N * @}
N */
N
N/** @defgroup PINSEL_Public_Types PINSEL Public Types
N * @{
N */
N 
N
Ntypedef enum
N{
N    PINSEL_BASICMODE_PLAINOUT  = 0, /**< Plain output */
N    PINSEL_BASICMODE_PULLDOWN,      /**< Pull-down enabled */
N    PINSEL_BASICMODE_PULLUP,        /**< Pull-up enabled (default) */
N    PINSEL_BASICMODE_REPEATER       /**< Repeater mode */
N}PinSel_BasicMode;
N
Ntypedef enum
N{
N    /** Fast mode (400 kHz clock rate) and standard (100 kHz clock rate) */
N    PINSEL_I2CMODE_FAST_STANDARD  = 0,
N    /** Open drain I/O (not I2C). No glitch filter, 3 mA typical output drive */
N    PINSEL_I2CMODE_OPENDRAINIO,
N    /** Fast Mode Plus I2C. This includes a filter for <50 ns glitches */
N    PINSEL_I2CMODE_FASTMODEPLUS,
N}PinSel_I2cMode;
N
Ntypedef enum
N{
N    /** Type D IOCON registers */
N    PINSEL_PIN_TYPE_D,
N    /** Type A IOCON registers */
N    PINSEL_PIN_TYPE_A,
N    /** Type U IOCON registers */
N    PINSEL_PIN_TYPE_U,
N    /** Type I IOCON registers */
N    PINSEL_PIN_TYPE_I,
N    /** Type W IOCON registers */
N    PINSEL_PIN_TYPE_W,
N    /** Unknown type */
N    PINSEL_PIN_TYPE_UNKNOWN,
N}PinSel_PinType;
N
N
N/**
N * @}
N */
N 
N
N/* Public Functions ----------------------------------------------------------- */
N/** @defgroup PINSEL_Public_Functions PINSEL Public Functions
N * @{
N */
N PinSel_PinType       PINSEL_GetPinType(uint8_t portnum, uint8_t pinnum);
NPINSEL_RET_CODE PINSEL_ConfigPin(uint8_t portnum, uint8_t pinnum, uint8_t funcnum);
NPINSEL_RET_CODE PINSEL_SetPinMode(uint8_t portnum, uint8_t pinnum, PinSel_BasicMode modenum);
NPINSEL_RET_CODE PINSEL_SetHysMode(uint8_t portnum, uint8_t pinnum, FunctionalState NewState);
NPINSEL_RET_CODE PINSEL_SetInvertInput(uint8_t portnum, uint8_t pinnum, FunctionalState NewState);
NPINSEL_RET_CODE PINSEL_SetSlewMode(uint8_t portnum, uint8_t pinnum, FunctionalState NewState);
NPINSEL_RET_CODE PINSEL_SetI2CMode(uint8_t portnum, uint8_t pinnum, PinSel_I2cMode I2CMode);
NPINSEL_RET_CODE PINSEL_SetOpenDrainMode(uint8_t portnum, uint8_t pinnum, FunctionalState NewState);
NPINSEL_RET_CODE PINSEL_SetAnalogPinMode (uint8_t portnum, uint8_t pinnum, uint8_t enable);
NPINSEL_RET_CODE PINSEL_DacEnable (uint8_t portnum, uint8_t pinnum, uint8_t enable);
NPINSEL_RET_CODE PINSEL_SetFilter (uint8_t portnum, uint8_t pinnum, uint8_t enable);
NPINSEL_RET_CODE PINSEL_SetI2CFilter (uint8_t portnum, uint8_t pinnum, uint8_t enable);
N
N
N/**
N * @}
N */
N
N#endif /* LPC_PINSEL_H */
N
N/**
N * @}
N */
N
N/* --------------------------------- End Of File ------------------------------ */
N
L 46 "Drivers\source\lpc_pinsel.c" 2
N
N/* Private Functions ---------------------------------------------------------- */
N
N/*********************************************************************//**
N * @brief       Get pointer to GPIO peripheral due to GPIO port
N * @param[in]   portnum     Port Number value, should be in range from 0..3.
N * @param[in]   pinnum      Pin number value, should be in range from 0..31
N * @return      Pointer to GPIO peripheral
N **********************************************************************/
Nstatic uint32_t * PIN_GetPointer(uint8_t portnum, uint8_t pinnum)
N{
N    uint32_t *pPIN = NULL;
X    uint32_t *pPIN = ((void*) 0);
N    pPIN = (uint32_t *)(LPC_IOCON_BASE + ((portnum * 32 + pinnum)*sizeof(uint32_t)));
X    pPIN = (uint32_t *)(((0x40000000UL) + 0x2C000) + ((portnum * 32 + pinnum)*sizeof(uint32_t)));
N    return pPIN;
N}
N
N/* Public Functions ----------------------------------------------------------- */
N/** @addtogroup PINSEL_Public_Functions
N * @{
N */
N
N/*********************************************************************//**
N * @brief       Get type of a pin.
N * @param[in]   portnum PORT number, should be in range: 0..3
N * @param[in]   pinnum  Pin number, should be in range: 0..31
N * @return      Port type:
N *              - PINSEL_PIN_TYPE_D
N *              - PINSEL_PIN_TYPE_A
N *              - PINSEL_PIN_TYPE_I
N *              - PINSEL_PIN_TYPE_W
N *              - PINSEL_PIN_TYPE_U   
N *              - PINSEL_PIN_TYPE_UNKNOWN: Invalid pin
N **********************************************************************/
NPinSel_PinType PINSEL_GetPinType(uint8_t portnum, uint8_t pinnum)
N{
N    PinSel_PinType Ret = PINSEL_PIN_TYPE_UNKNOWN;
N    switch(portnum)
N    {
N        case 0:
N            if((pinnum <=6)||
N                ((pinnum >= 10)&&(pinnum <=11))||
N                ((pinnum >= 14)&&(pinnum <=22)))
N                Ret = PINSEL_PIN_TYPE_D;
N            else if ((pinnum == 12)||(pinnum==13)||
N                    ((pinnum >= 23)&&(pinnum <=26)))
N                Ret = PINSEL_PIN_TYPE_A;
N            else if ((pinnum == 29) || (pinnum==30)|| (pinnum==31))
N                Ret = PINSEL_PIN_TYPE_U;
N            else if ((pinnum == 27) || (pinnum==28))
N                Ret = PINSEL_PIN_TYPE_I;
N            else if ((pinnum == 7) || (pinnum==8)|| (pinnum==9))
N                Ret = PINSEL_PIN_TYPE_W;
N            break;
N        case 1:
N            if(pinnum <=29)
N                Ret = PINSEL_PIN_TYPE_D;
N            else if ((pinnum == 30) || (pinnum==31))
N                Ret = PINSEL_PIN_TYPE_A;
N            break;
N        case 2:
N        case 3:
N        case 4:
N            Ret = PINSEL_PIN_TYPE_D;
N            break;
N        case 5:
N            if((pinnum <=1)||
N                (pinnum == 4))
N                Ret = PINSEL_PIN_TYPE_D;
N            else if ((pinnum == 2) || (pinnum==3))
N                Ret = PINSEL_PIN_TYPE_I;
N            break;
N        default:
N            break;
N    }
N
N    return Ret;
N}
N
N/*********************************************************************//**
N * @brief       Setup the pin selection function
N * @param[in]   portnum PORT number, should be in range: 0..3
N * @param[in]   pinnum  Pin number, should be in range: 0..31
N * @param[in]   funcnum Function number, should be range: 0..7
N *              - 0: Select GPIO (Default)
N *              - 1: Selects the 1st alternate function
N *              - 2: Selects the 2nd alternate function
N *              ...
N *              - 7: Selects the 7th alternate function
N * @return      PINSEL Return Code
N *              - PINSEL_RET_INVALID_PIN
N *              - PINSEL_RET_OK
N **********************************************************************/
NPINSEL_RET_CODE PINSEL_ConfigPin ( uint8_t portnum, uint8_t pinnum, uint8_t funcnum)
N{
N    uint32_t *pPIN = NULL;
X    uint32_t *pPIN = ((void*) 0);
N    PinSel_PinType type = PINSEL_GetPinType(portnum,pinnum);
N
N    if(type == PINSEL_PIN_TYPE_UNKNOWN)
N        return PINSEL_RET_INVALID_PIN;
X        return (0x10000001);
N    
N    pPIN = PIN_GetPointer(portnum, pinnum);
N    *pPIN &= ~IOCON_FUNC_MASK;//Clear function bits
X    *pPIN &= ~(0x07<<(0));
N    *pPIN |= funcnum&IOCON_FUNC_MASK;
X    *pPIN |= funcnum&(0x07<<(0));
N
N    return PINSEL_RET_OK;
X    return (0);
N}
N
N
N/*********************************************************************//**
N * @brief       Setup resistor mode for pin of type D,A,W
N * @param[in]   portnum PORT number, should be in range: 0..3
N * @param[in]   pinnum  Pin number, should be in range: 0..31
N * @param[in]   modenum: Mode number, should be in range: 0..3
N                - PINSEL_BASICMODE_PLAINOUT: Plain output
N                - PINSEL_BASICMODE_PULLDOWN: Pull-down enable
N                - PINSEL_BASICMODE_PULLUP: Pull-up enable
N                - PINSEL_BASICMODE_REPEATER: Repeater mode
N * @return      PINSEL Return Code
N *              - PINSEL_RET_INVALID_PIN
N *              - PINSEL_RET_NOT_SUPPORT
N *              - PINSEL_RET_OK
N **********************************************************************/
NPINSEL_RET_CODE PINSEL_SetPinMode ( uint8_t portnum, uint8_t pinnum, PinSel_BasicMode modenum)
N{
N    uint32_t *pPIN = NULL;
X    uint32_t *pPIN = ((void*) 0);
N    PinSel_PinType type = PINSEL_GetPinType(portnum,pinnum);
N
N    if(type == PINSEL_PIN_TYPE_UNKNOWN)
N        return PINSEL_RET_INVALID_PIN;
X        return (0x10000001);
N    if((type != PINSEL_PIN_TYPE_D )&&
N        (type != PINSEL_PIN_TYPE_A )&&
N        (type != PINSEL_PIN_TYPE_W))
N        return PINSEL_RET_NOT_SUPPORT;
X        return (0x10000002);
N    
N    pPIN = PIN_GetPointer(portnum, pinnum);
N    *(uint32_t *)pPIN &= ~(IOCON_MODE_MASK);//Clear function bits
X    *(uint32_t *)pPIN &= ~((0x03<<(3)));
N    *(uint32_t *)pPIN |= (modenum << IOCON_MODE_POS)&IOCON_MODE_MASK;
X    *(uint32_t *)pPIN |= (modenum << (3))&(0x03<<(3));
N
N    return PINSEL_RET_OK;
X    return (0);
N}
N
N/*********************************************************************//**
N * @brief       Setup hysteresis for pin of type D, W
N * @param[in]   portnum Port number, should be in range: 0..3
N * @param[in]   pinnum  Pin number, should be in range: 0..31
N * @param[in]   NewState new state of Hysteresis mode, should be:
N *              - ENABLE: Hysteresis enable
N *              - DISABLE: Hysteresis disable
N * @return      PINSEL Return Code
N *              - PINSEL_RET_INVALID_PIN
N *              - PINSEL_RET_NOT_SUPPORT
N *              - PINSEL_RET_OK
N **********************************************************************/
NPINSEL_RET_CODE PINSEL_SetHysMode(uint8_t portnum, uint8_t pinnum, FunctionalState NewState)
N{
N    uint32_t *pPIN = NULL;
X    uint32_t *pPIN = ((void*) 0);
N    PinSel_PinType type = PINSEL_GetPinType(portnum,pinnum);
N
N    if(type == PINSEL_PIN_TYPE_UNKNOWN)
N        return PINSEL_RET_INVALID_PIN;
X        return (0x10000001);
N    if((type != PINSEL_PIN_TYPE_D )&&
N        (type != PINSEL_PIN_TYPE_W))
N        return PINSEL_RET_NOT_SUPPORT;
X        return (0x10000002);
N    
N    pPIN = PIN_GetPointer(portnum, pinnum);
N    if(NewState == DISABLE)
N    {
N        *(uint32_t *)pPIN &= ~IOCON_HYS_ENABLE;//Clear hys bits
X        *(uint32_t *)pPIN &= ~((1<<(5)));
N    }
N    else
N        *(uint32_t *)pPIN |= IOCON_HYS_ENABLE;
X        *(uint32_t *)pPIN |= ((1<<(5)));
N
N    return PINSEL_RET_OK;
X    return (0);
N}
N/*********************************************************************//**
N * @brief       Setup input polarity for pin of type A,I,D,W
N * @param[in]   portnum Port number, should be in range: 0..3
N * @param[in]   pinnum  Pin number, should be in range: 0..31
N * @param[in]   NewState new state of Invert mode, should be:
N *              - ENABLE: Input is inverted.
N *              - DISABLE: Input isn't inverted.
N * @return      PINSEL Return Code
N *              - PINSEL_RET_INVALID_PIN
N *              - PINSEL_RET_NOT_SUPPORT
N *              - PINSEL_RET_OK
N **********************************************************************/
NPINSEL_RET_CODE PINSEL_SetInvertInput(uint8_t portnum, uint8_t pinnum, FunctionalState NewState)
N{
N    uint32_t *pPIN = NULL;
X    uint32_t *pPIN = ((void*) 0);
N    PinSel_PinType type = PINSEL_GetPinType(portnum,pinnum);
N
N    if(type == PINSEL_PIN_TYPE_UNKNOWN)
N        return PINSEL_RET_INVALID_PIN;
X        return (0x10000001);
N    if(type== PINSEL_PIN_TYPE_U)
N        return PINSEL_RET_NOT_SUPPORT;
X        return (0x10000002);
N    
N    pPIN = PIN_GetPointer(portnum, pinnum);
N    if(NewState == DISABLE)
N    {
N        *(uint32_t *)pPIN &= ~IOCON_INVERT_INPUT;//Clear hys bits
X        *(uint32_t *)pPIN &= ~(1<<(6));
N    }
N    else
N        *(uint32_t *)pPIN |= IOCON_INVERT_INPUT;
X        *(uint32_t *)pPIN |= (1<<(6));
N
N    return PINSEL_RET_OK;
X    return (0);
N}
N
N/*********************************************************************//**
N * @brief       Setup Slew rate for pin of type D,W
N * @param[in]   portnum Port number, should be in range: 0..3
N * @param[in]   pinnum  Pin number, should be in range: 0..31
N * @param[in]   NewState new state of Slew rate control, should be:
N *              - ENABLE: Output slew rate control is enable
N *              - DISABLE: Output slew rate control is disable
N * @return      PINSEL Return Code
N *              - PINSEL_RET_INVALID_PIN
N *              - PINSEL_RET_NOT_SUPPORT
N *              - PINSEL_RET_OK
N **********************************************************************/
NPINSEL_RET_CODE PINSEL_SetSlewMode(uint8_t portnum, uint8_t pinnum, FunctionalState NewState)
N{
N    uint32_t *pPIN = NULL;
X    uint32_t *pPIN = ((void*) 0);
N    PinSel_PinType type = PINSEL_GetPinType(portnum,pinnum);
N
N    if(type == PINSEL_PIN_TYPE_UNKNOWN)
N        return PINSEL_RET_INVALID_PIN;
X        return (0x10000001);
N    if((type!= PINSEL_PIN_TYPE_D) &&
N        (type!= PINSEL_PIN_TYPE_W))
N        return PINSEL_RET_NOT_SUPPORT;
X        return (0x10000002);
N    
N    pPIN = PIN_GetPointer(portnum, pinnum);
N    if(NewState == DISABLE)
N    {
N        *(uint32_t *)pPIN &= ~IOCON_SLEW_ENABLE;//Clear hys bits
X        *(uint32_t *)pPIN &= ~((1<<(9)));
N    }
N    else
N        *(uint32_t *)pPIN |= IOCON_SLEW_ENABLE;
X        *(uint32_t *)pPIN |= ((1<<(9)));
N
N    return PINSEL_RET_OK;
X    return (0);
N}
N
N/*********************************************************************//**
N * @brief       Setup I2CMode for only pins that provide special I2C functionality
N * @param[in]   portnum Port number, should be in range: 0..3
N * @param[in]   pinnum  Pin number, should be in range: 0..31
N * @param[in]   I2CMode I2C mode, should be:
N *              - PINSEL_I2CMODE_FAST_STANDARD: Fast mode and standard I2C mode
N *              - PINSEL_I2CMODE_OPENDRAINIO: Open drain I/O
N *              - PINSEL_I2CMODE_FASTMODEPLUS: Fast Mode Plus I/O
N * @return      PINSEL Return Code
N *              - PINSEL_RET_INVALID_PIN
N *              - PINSEL_RET_NOT_SUPPORT
N *              - PINSEL_RET_OK
N **********************************************************************/
NPINSEL_RET_CODE PINSEL_SetI2CMode(uint8_t portnum, uint8_t pinnum, PinSel_I2cMode I2CMode)
N{
N    uint32_t *pPIN = NULL;
X    uint32_t *pPIN = ((void*) 0);
N    PinSel_PinType type = PINSEL_GetPinType(portnum,pinnum);
N
N    if(type == PINSEL_PIN_TYPE_UNKNOWN)
N        return PINSEL_RET_INVALID_PIN;
X        return (0x10000001);
N    if(type != PINSEL_PIN_TYPE_I )
N        return PINSEL_RET_NOT_SUPPORT;
X        return (0x10000002);
N    
N    pPIN = PIN_GetPointer(portnum, pinnum);
N
N    switch(I2CMode)
N    {
N        // Standard/Fast Mode I2C: HS = HIDRIVE = 0
N        case PINSEL_I2CMODE_FAST_STANDARD: 
N            PINSEL_SetI2CFilter(portnum,pinnum,ENABLE);
N            *(uint32_t *)pPIN &= ~(IOCON_I2CMODE_FASTPLUS);
X            *(uint32_t *)pPIN &= ~((1<<(9)));
N            break;
N
N        // Non-I2C: HS = 1, HIDRIVE = 0
N        case PINSEL_I2CMODE_OPENDRAINIO:
N            PINSEL_SetI2CFilter(portnum,pinnum,DISABLE);
N            *(uint32_t *)pPIN &= ~(IOCON_I2CMODE_FASTPLUS);
X            *(uint32_t *)pPIN &= ~((1<<(9)));
N            break;
N
N        // Fast Mode Plus I2C: HS = 0, HIDRIVE =1
N        case PINSEL_I2CMODE_FASTMODEPLUS:   
N            PINSEL_SetI2CFilter(portnum,pinnum,ENABLE);
N            *(uint32_t *)pPIN |= (IOCON_I2CMODE_FASTPLUS);
X            *(uint32_t *)pPIN |= ((1<<(9)));
N            break;
N        default:
N            return PINSEL_RET_ERR;
X            return (-1);
N    }
N
N    return PINSEL_RET_OK;
X    return (0);
N}
N
N/*********************************************************************//**
N * @brief       Setup Open-drain mode in pin of type D, A, W
N * @param[in]   portnum Port number, should be in range: 0..3
N * @param[in]   pinnum  Pin number, should be in range: 0..31
N * @param[in]   NewState new state of Open-drain mode:
N *              - DISABLE: Normal pin I/O mode
N *              - ENABLE: Open-drain enable
N * @return      PINSEL Return Code
N *              - PINSEL_RET_INVALID_PIN
N *              - PINSEL_RET_NOT_SUPPORT
N *              - PINSEL_RET_OK
N **********************************************************************/
NPINSEL_RET_CODE PINSEL_SetOpenDrainMode(uint8_t portnum, uint8_t pinnum, FunctionalState NewState)
N{
N    uint32_t *pPIN = NULL;
X    uint32_t *pPIN = ((void*) 0);
N    PinSel_PinType type = PINSEL_GetPinType(portnum,pinnum);
N
N    if(type == PINSEL_PIN_TYPE_UNKNOWN)
N        return PINSEL_RET_INVALID_PIN;
X        return (0x10000001);
N    if((type != PINSEL_PIN_TYPE_D ) &&
N        (type != PINSEL_PIN_TYPE_A ) &&
N        (type != PINSEL_PIN_TYPE_W ))
N        return PINSEL_RET_NOT_SUPPORT;
X        return (0x10000002);
N    
N    pPIN = PIN_GetPointer(portnum, pinnum);
N    if(NewState == DISABLE)
N    {
N        *(uint32_t *)pPIN &= ~IOCON_OPENDRAIN_MODE;//Clear hys bits
X        *(uint32_t *)pPIN &= ~(1<<(10));
N    }
N    else
N    {
N        *(uint32_t *)pPIN |= IOCON_OPENDRAIN_MODE;
X        *(uint32_t *)pPIN |= (1<<(10));
N    }
N    return PINSEL_RET_OK;
X    return (0);
N}
N
N/*********************************************************************//**
N * @brief       Enable the Analog mode for each pin  of Type A(default is as Digital pins)
N * @param[in]   portnum PORT number, should be in range: 0..3
N * @param[in]   pinnum  Pin number, should be in range: 0..31
N * @param[in]   enable: the state of the pin that is expected to run
N                - ENABLE: Enable the DAC mode of the pin
N                - DISABLE: Disable the DAC mode
N * @return      PINSEL Return Code
N *              - PINSEL_RET_INVALID_PIN
N *              - PINSEL_RET_NOT_SUPPORT
N *              - PINSEL_RET_OK
N **********************************************************************/
NPINSEL_RET_CODE PINSEL_SetAnalogPinMode (uint8_t portnum, uint8_t pinnum, uint8_t enable)
N{
N    uint32_t *pPIN = NULL;
X    uint32_t *pPIN = ((void*) 0);
N    PinSel_PinType type = PINSEL_GetPinType(portnum,pinnum);
N
N    if(type == PINSEL_PIN_TYPE_UNKNOWN)
N        return PINSEL_RET_INVALID_PIN;
X        return (0x10000001);
N    if(type != PINSEL_PIN_TYPE_A )
N        return PINSEL_RET_NOT_SUPPORT;
X        return (0x10000002);
N
N    pPIN = PIN_GetPointer(portnum, pinnum);
N
N    if(enable)
N    {
N        *(uint32_t *)pPIN &= ~(IOCON_DIGITIAL_MODE);
X        *(uint32_t *)pPIN &= ~((1<<(7)));
N    }
N    else
N    {
N        *(uint32_t *)pPIN |= IOCON_DIGITIAL_MODE;//Set 7th bit to one
X        *(uint32_t *)pPIN |= (1<<(7));
N    }
N
N    return PINSEL_RET_OK;
X    return (0);
N}
N
N
N
N/*********************************************************************//**
N * @brief       Choose the DAC mode for pin P0.26
N * @param[in]   portnum PORT number, should be in range: 0..3
N * @param[in]   pinnum  Pin number, should be in range: 0..31
N * @param[in]   enable: the state of the pin that is expected to run
N                - ENABLE: Enable the DAC mode of the pin
N                - DISABLE: Disable the DAC mode
N * @return      PINSEL Return Code
N *              - PINSEL_RET_INVALID_PIN
N *              - PINSEL_RET_NOT_SUPPORT
N *              - PINSEL_RET_OK
N **********************************************************************/
NPINSEL_RET_CODE PINSEL_DacEnable (uint8_t portnum, uint8_t pinnum, uint8_t enable)
N{
N    uint32_t *pPIN = NULL;
X    uint32_t *pPIN = ((void*) 0);
N    
N    PinSel_PinType type = PINSEL_GetPinType(portnum,pinnum);
N    
N    if(type == PINSEL_PIN_TYPE_UNKNOWN)
N        return PINSEL_RET_INVALID_PIN;
X        return (0x10000001);
N
N    // This setting is only for DAC pin (output pin)
N    if(!((portnum == 0) && (pinnum == 26)))
N    {
N        return PINSEL_RET_NOT_SUPPORT;
X        return (0x10000002);
N    }
N
N    pPIN = PIN_GetPointer(portnum, pinnum);
N
N    if(enable)
N    {
N        *(uint32_t *)pPIN |= IOCON_DAC_ENABLE;//Set 16th bit to one
X        *(uint32_t *)pPIN |= (1<<(16));
N    }
N    else
N    {
N        *(uint32_t *)pPIN &= ~IOCON_DAC_ENABLE;//Set 16th bit to one
X        *(uint32_t *)pPIN &= ~(1<<(16));
N
N    }
N
N    return PINSEL_RET_OK;
X    return (0);
N}
N
N/*********************************************************************//**
N * @brief       Control the 10ns glitch filter for pin of type A,W
N * @param[in]   portnum PORT number, should be in range: 0..3
N * @param[in]   pinnum  Pin number, should be in range: 0..31
N * @param[in]   enable: the state of the pin that is expected to run
N                - ENABLE: The noise pulses below approximately 10ns are filtered out
N                - DISABLE: No input filtering is done.
N * @return      PINSEL Return Code
N *              - PINSEL_RET_INVALID_PIN
N *              - PINSEL_RET_NOT_SUPPORT
N *              - PINSEL_RET_OK
N **********************************************************************/
NPINSEL_RET_CODE PINSEL_SetFilter (uint8_t portnum, uint8_t pinnum, uint8_t enable)
N{
N    uint32_t *pPIN = NULL;
X    uint32_t *pPIN = ((void*) 0);
N    PinSel_PinType type = PINSEL_GetPinType(portnum,pinnum);
N    
N    if(type == PINSEL_PIN_TYPE_UNKNOWN)
N        return PINSEL_RET_INVALID_PIN;
X        return (0x10000001);
N    if((type != PINSEL_PIN_TYPE_A ) &&
N        (type != PINSEL_PIN_TYPE_W ))
N        return PINSEL_RET_NOT_SUPPORT;
X        return (0x10000002);
N
N    pPIN = PIN_GetPointer(portnum, pinnum);
N
N
N    if(enable)
N    {
N        *(uint32_t *)pPIN &= ~(IOCON_10ns_FILTER_DISABLE);//Clear 8th bit to 0
X        *(uint32_t *)pPIN &= ~((1<<(8)));
N    }
N    else
N    {
N        *(uint32_t *)pPIN |= (IOCON_10ns_FILTER_DISABLE);//Set 8th bit to one
X        *(uint32_t *)pPIN |= ((1<<(8)));
N    }
N
N
N    return PINSEL_RET_OK;
X    return (0);
N}
N/*********************************************************************//**
N * @brief       Control the 50ns glitch filter for I2C pins (type I)
N * @param[in]   portnum PORT number, should be in range: 0..3
N * @param[in]   pinnum  Pin number, should be in range: 0..31
N * @param[in]   enable: the state of the pin that is expected to run
N                - ENABLE: The noise pulses below approximately 10ns are filtered out
N                - DISABLE: No input filtering is done.
N * @return      PINSEL Return Code
N *              - PINSEL_RET_INVALID_PIN
N *              - PINSEL_RET_NOT_SUPPORT
N *              - PINSEL_RET_OK
N **********************************************************************/
NPINSEL_RET_CODE PINSEL_SetI2CFilter (uint8_t portnum, uint8_t pinnum, uint8_t enable)
N{
N    uint32_t *pPIN = NULL;
X    uint32_t *pPIN = ((void*) 0);
N    PinSel_PinType type = PINSEL_GetPinType(portnum,pinnum);
N    
N    if(type == PINSEL_PIN_TYPE_UNKNOWN)
N        return PINSEL_RET_INVALID_PIN;
X        return (0x10000001);
N    if(type != PINSEL_PIN_TYPE_I)
N        return PINSEL_RET_NOT_SUPPORT;
X        return (0x10000002);
N
N    pPIN = PIN_GetPointer(portnum, pinnum);
N
N
N    if(enable)
N    {
N        *(uint32_t *)pPIN &= ~(IOCON_HS_MASK);//Clear 8th bit to 0
X        *(uint32_t *)pPIN &= ~((0x01<<(8)));
N    }
N    else
N    {
N        *(uint32_t *)pPIN |= (IOCON_I2C_FILTER_DISABLE);//Set 8th bit to one
X        *(uint32_t *)pPIN |= ((1<<(8)));
N    }
N
N
N    return PINSEL_RET_OK;
X    return (0);
N}
N
N
N/**
N * @}
N */
N#endif /*_PINSEL*/
N
N/**
N * @}
N */
N
N/* --------------------------------- End Of File ------------------------------ */
