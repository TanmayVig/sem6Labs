; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\isp_iap.o --asm_dir=.\Obj\ --list_dir=.\Obj\ --depend=.\obj\isp_iap.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I. -I.\Core_CM3 -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\INC\NXP -D__UVISION_VERSION=524 --omf_browse=.\obj\isp_iap.crf isp\isp_iap.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  is_div PROC
;;;34     
;;;35     int is_div(unsigned value,unsigned div)
000000  1e49              SUBS     r1,r1,#1
;;;36     {
;;;37         if(value & (div -1))
000002  4008              ANDS     r0,r0,r1
000004  d000              BEQ      |L1.8|
;;;38         {
;;;39             return(1);
000006  2001              MOVS     r0,#1
                  |L1.8|
;;;40         }
;;;41         else
;;;42         {
;;;43             return(0);
;;;44         }
;;;45     }/* is_div */
000008  4770              BX       lr
;;;46     
                          ENDP

                  __rt_div0 PROC
;;;47     void __rt_div0(void)
00000a  4770              BX       lr
;;;48     {
;;;49     } /* __rt_div0 */
;;;50     
                          ENDP

                  str_cmp PROC
;;;51     int str_cmp(char * src, char * dst)
00000c  b510              PUSH     {r4,lr}
;;;52     {
;;;53         int i = 0;
00000e  2200              MOVS     r2,#0
000010  e001              B        |L1.22|
                  |L1.18|
;;;54         
;;;55         for(i=0;src[i] == dst[i];i++)
;;;56         {
;;;57             if(src[i] == NUL)
000012  b143              CBZ      r3,|L1.38|
000014  1c52              ADDS     r2,r2,#1
                  |L1.22|
000016  5c83              LDRB     r3,[r0,r2]            ;55
000018  5c8c              LDRB     r4,[r1,r2]            ;55
00001a  42a3              CMP      r3,r4                 ;55
00001c  d0f9              BEQ      |L1.18|
;;;58             {
;;;59                 return(NUL);
;;;60             }
;;;61         }
;;;62         return(src[i]-dst[i]);
00001e  b2d8              UXTB     r0,r3
000020  b2e1              UXTB     r1,r4
000022  1a40              SUBS     r0,r0,r1
;;;63     } /* str_cmp */
000024  bd10              POP      {r4,pc}
                  |L1.38|
000026  2000              MOVS     r0,#0                 ;59
000028  bd10              POP      {r4,pc}
;;;64     
                          ENDP

                  a_to_i PROC
;;;65     int a_to_i(char * inbuf,unsigned * outint)
00002a  b570              PUSH     {r4-r6,lr}
;;;66     {
;;;67         unsigned int value=0,i;
00002c  2400              MOVS     r4,#0
;;;68         
;;;69         for(i=0;inbuf[i] != 0;i++)
00002e  4622              MOV      r2,r4
;;;70         {
;;;71             if(inbuf[i] >= '0' && inbuf[i] <= '9')
;;;72             {
;;;73                 value = 10 * value +(inbuf[i] - '0');
000030  f06f062f          MVN      r6,#0x2f
000034  e00a              B        |L1.76|
000036  bf00              NOP                            ;71
                  |L1.56|
000038  f1a30530          SUB      r5,r3,#0x30           ;71
00003c  2d09              CMP      r5,#9                 ;71
00003e  d80b              BHI      |L1.88|
000040  eb040484          ADD      r4,r4,r4,LSL #2
000044  eb060444          ADD      r4,r6,r4,LSL #1
000048  441c              ADD      r4,r4,r3
00004a  1c52              ADDS     r2,r2,#1
                  |L1.76|
00004c  5c83              LDRB     r3,[r0,r2]            ;69
00004e  2b00              CMP      r3,#0                 ;69
000050  d1f2              BNE      |L1.56|
;;;74             }
;;;75             else
;;;76             {
;;;77                 return(1);
;;;78             }
;;;79         }
;;;80         *outint = value;
;;;81         return(0);
000052  2000              MOVS     r0,#0
000054  600c              STR      r4,[r1,#0]
;;;82     } /* a_to_i */
000056  bd70              POP      {r4-r6,pc}
                  |L1.88|
000058  2001              MOVS     r0,#1                 ;77
00005a  bd70              POP      {r4-r6,pc}
;;;83     
                          ENDP

                  i_to_a PROC
;;;84     
;;;85     char * i_to_a(unsigned i_num, char * str, unsigned str_len)
00005c  b510              PUSH     {r4,lr}
;;;86     {
;;;87         char remainder;
;;;88     
;;;89         str[--str_len] = NUL;
00005e  2300              MOVS     r3,#0
000060  1e52              SUBS     r2,r2,#1
;;;90     
;;;91         if(i_num == 0)
;;;92         {
;;;93             str[--str_len] = '0';
;;;94             return(str + str_len);
;;;95         }
;;;96     
;;;97         while (((str_len>0) && (i_num!=0)))
;;;98         {
;;;99             str_len--;
;;;100            remainder = (char) (i_num % 10);
000062  240a              MOVS     r4,#0xa
000064  548b              STRB     r3,[r1,r2]            ;89
000066  b980              CBNZ     r0,|L1.138|
000068  2030              MOVS     r0,#0x30              ;93
00006a  1e52              SUBS     r2,r2,#1              ;93
00006c  5488              STRB     r0,[r1,r2]            ;93
00006e  e00f              B        |L1.144|
                  |L1.112|
000070  fbb0f3f4          UDIV     r3,r0,r4
000074  fb040313          MLS      r3,r4,r3,r0
000078  1e52              SUBS     r2,r2,#1
;;;101            if ( remainder <= 9 )
00007a  2b09              CMP      r3,#9
00007c  d801              BHI      |L1.130|
00007e  3330              ADDS     r3,r3,#0x30
;;;102            {
;;;103                str[str_len] = remainder + '0';
000080  e000              B        |L1.132|
                  |L1.130|
000082  3337              ADDS     r3,r3,#0x37
                  |L1.132|
;;;104            }
;;;105            else  
;;;106            {
;;;107                str[str_len] = remainder - 10 + 'A';
;;;108            }
;;;109            i_num = i_num/10;
000084  fbb0f0f4          UDIV     r0,r0,r4
000088  548b              STRB     r3,[r1,r2]            ;107
                  |L1.138|
00008a  b10a              CBZ      r2,|L1.144|
00008c  2800              CMP      r0,#0                 ;97
00008e  d1ef              BNE      |L1.112|
                  |L1.144|
;;;110        }
;;;111        return (str + str_len);
000090  1888              ADDS     r0,r1,r2
;;;112    } /* i_to_a */
000092  bd10              POP      {r4,pc}
;;;113    
                          ENDP

                  run_isp PROC
;;;114    const char sync_str[] = "Synchronized";
;;;115    void run_isp(void)
000094  b508              PUSH     {r3,lr}
;;;116    {
;;;117        int count;
;;;118    
;;;119        /* wait for host to initiate communication */
;;;120    	getline(cmd_buf,CMD_SIZE,&count);
000096  466a              MOV      r2,sp
000098  2146              MOVS     r1,#0x46
00009a  48f8              LDR      r0,|L1.1148|
00009c  f7fffffe          BL       getline
;;;121    
;;;122    	/* send "Synchronized" string response */
;;;123    	sendline_crlf((char *)sync_str);
0000a0  48f7              LDR      r0,|L1.1152|
0000a2  f7fffffe          BL       sendline_crlf
;;;124    
;;;125        /* wait for host to respond */
;;;126    	getline(cmd_buf,CMD_SIZE,&count);
0000a6  466a              MOV      r2,sp
0000a8  2146              MOVS     r1,#0x46
0000aa  48f4              LDR      r0,|L1.1148|
0000ac  f7fffffe          BL       getline
;;;127    
;;;128    	/* Compare HOST response with the original string */
;;;129    	if(str_cmp(cmd_buf,(char *)sync_str) == 0)
0000b0  49f3              LDR      r1,|L1.1152|
0000b2  48f2              LDR      r0,|L1.1148|
0000b4  f7fffffe          BL       str_cmp
;;;130    	{
;;;131    		/* Autobaud is successful. Get out of while loop. */
;;;132    	}
;;;133    	else
;;;134    	{
;;;135    	}
;;;136    }
0000b8  bd08              POP      {r3,pc}
;;;137    
                          ENDP

                  param_check PROC
;;;138    unsigned param_check(char * param_str,unsigned * param_ptr,int param_type,int count)
0000ba  b5f0              PUSH     {r4-r7,lr}
;;;139    {
0000bc  461e              MOV      r6,r3
0000be  4615              MOV      r5,r2
0000c0  460f              MOV      r7,r1
;;;140        int rc,return_code,in_flash,in_ram;
;;;141        return_code = 0;
0000c2  2400              MOVS     r4,#0
0000c4  b120              CBZ      r0,|L1.208|
;;;142        /* check if conversion from str to integer is required */
;;;143        if(param_str != NUL)
;;;144        {
;;;145            rc = a_to_i(param_str,param_ptr);
0000c6  f7fffffe          BL       a_to_i
;;;146            if(rc != 0)
0000ca  b108              CBZ      r0,|L1.208|
;;;147            {
;;;148                return(PARAM_ERROR);
0000cc  200c              MOVS     r0,#0xc
;;;149            }
;;;150        }
;;;151    
;;;152        if(param_type == NO_PARAM_CHECK)
;;;153        {
;;;154            /* further testing is not required. Verification is done in  
;;;155               related commands */
;;;156            return(0);
;;;157        }
;;;158        
;;;159        rc = is_div(*param_ptr,BY_4);
;;;160        if( rc != 0)
;;;161        {   
;;;162            if(param_type == COUNT)
;;;163            {
;;;164                return_code = COUNT_ERROR;
;;;165            }
;;;166            else
;;;167            {
;;;168                return_code = ADDR_ERROR;
;;;169                /* Now distinguish between SRC & DST if required */
;;;170                if(param_type == RAM_ADDRESS)
;;;171                {
;;;172                    return_code = SRC_ADDR_ERROR;
;;;173                }
;;;174                if(param_type == FLASH_ADDRESS)
;;;175                {
;;;176                    return_code = DST_ADDR_ERROR;
;;;177                }
;;;178            } /* Address error */
;;;179        } /* is_div by 4 error */
;;;180    
;;;181        /* Check for address mapping if required. Each type of address requires a 
;;;182        different type of test. Do this testing only if previous test is ok */
;;;183        if(return_code == 0)
;;;184        {
;;;185            if( ((*param_ptr >= RAM_START) && ((*param_ptr+count) <= (RAM_END+1))) )
;;;186            {
;;;187                in_ram = TRUE;
;;;188            }
;;;189            else
;;;190            {
;;;191                in_ram = FALSE;
;;;192            }
;;;193            if( ((*param_ptr >= USER_START_SECTOR_ADDRESS) && ((*param_ptr+count) <= (USER_END_SECTOR_ADDRESS+1))) )
;;;194            {
;;;195                in_flash = TRUE;
;;;196            }
;;;197            else
;;;198            {
;;;199                in_flash = FALSE;
;;;200            }
;;;201            if(param_type == RAM_OR_FLASH_ADDRESS)
;;;202            {
;;;203                if( !(in_ram || in_flash) )
;;;204                {
;;;205                    return_code = ADDR_NOT_MAPPED;
;;;206                }
;;;207            }
;;;208            if(param_type == RAM_ADDRESS)
;;;209            {
;;;210                if( !(in_ram) )
;;;211                {
;;;212                    return_code = SRC_ADDR_NOT_MAPPED;
;;;213                }
;;;214            }
;;;215        }
;;;216        return(return_code);
;;;217    }/* param_check */
0000ce  bdf0              POP      {r4-r7,pc}
                  |L1.208|
0000d0  2d69              CMP      r5,#0x69              ;152
0000d2  d00c              BEQ      |L1.238|
0000d4  2104              MOVS     r1,#4                 ;159
0000d6  6838              LDR      r0,[r7,#0]            ;159
0000d8  f7fffffe          BL       is_div
0000dc  b178              CBZ      r0,|L1.254|
0000de  2d64              CMP      r5,#0x64              ;162
0000e0  d007              BEQ      |L1.242|
0000e2  240d              MOVS     r4,#0xd               ;168
0000e4  2d67              CMP      r5,#0x67              ;170
0000e6  d006              BEQ      |L1.246|
0000e8  2d68              CMP      r5,#0x68              ;174
0000ea  d006              BEQ      |L1.250|
0000ec  e027              B        |L1.318|
                  |L1.238|
0000ee  2000              MOVS     r0,#0                 ;156
0000f0  bdf0              POP      {r4-r7,pc}
                  |L1.242|
0000f2  2406              MOVS     r4,#6                 ;164
0000f4  e023              B        |L1.318|
                  |L1.246|
0000f6  2402              MOVS     r4,#2                 ;172
0000f8  e021              B        |L1.318|
                  |L1.250|
0000fa  2403              MOVS     r4,#3                 ;176
0000fc  e01f              B        |L1.318|
                  |L1.254|
0000fe  6839              LDR      r1,[r7,#0]            ;185
000100  f1b15f80          CMP      r1,#0x10000000        ;185
000104  d305              BCC      |L1.274|
000106  4adf              LDR      r2,|L1.1156|
000108  1988              ADDS     r0,r1,r6              ;185
00010a  4290              CMP      r0,r2                 ;185
00010c  d801              BHI      |L1.274|
00010e  2001              MOVS     r0,#1                 ;187
000110  e000              B        |L1.276|
                  |L1.274|
000112  2000              MOVS     r0,#0                 ;191
                  |L1.276|
000114  f5b15f00          CMP      r1,#0x2000            ;193
000118  d305              BCC      |L1.294|
00011a  4431              ADD      r1,r1,r6              ;193
00011c  f5b12f00          CMP      r1,#0x80000           ;193
000120  d801              BHI      |L1.294|
000122  2101              MOVS     r1,#1                 ;195
000124  e000              B        |L1.296|
                  |L1.294|
000126  2100              MOVS     r1,#0                 ;199
                  |L1.296|
000128  2d66              CMP      r5,#0x66              ;201
00012a  d002              BEQ      |L1.306|
00012c  2d67              CMP      r5,#0x67              ;208
00012e  d004              BEQ      |L1.314|
000130  e005              B        |L1.318|
                  |L1.306|
000132  4308              ORRS     r0,r0,r1              ;203
000134  d103              BNE      |L1.318|
000136  240e              MOVS     r4,#0xe               ;205
000138  e001              B        |L1.318|
                  |L1.314|
00013a  b900              CBNZ     r0,|L1.318|
00013c  2404              MOVS     r4,#4                 ;212
                  |L1.318|
00013e  4620              MOV      r0,r4                 ;216
000140  bdf0              POP      {r4-r7,pc}
;;;218    
                          ENDP

                  iap_entry PROC
;;;219    void iap_entry(unsigned param_tab[],unsigned result_tab[])
000142  4ad1              LDR      r2,|L1.1160|
;;;220    {
;;;221        void (*iap)(unsigned [],unsigned []);
;;;222    
;;;223        iap = (void (*)(unsigned [],unsigned []))IAP_ADDRESS;
;;;224        iap(param_tab,result_tab);
000144  4710              BX       r2
;;;225    }
;;;226    
                          ENDP

                  decode PROC
;;;227    char decode(char c)
000146  2860              CMP      r0,#0x60
;;;228    {
000148  d002              BEQ      |L1.336|
00014a  3820              SUBS     r0,r0,#0x20
;;;229        if(c == 0x60)
;;;230        {
;;;231            return(0x00);
;;;232        }
;;;233        else
;;;234        {
;;;235            return(c - SP);
00014c  b2c0              UXTB     r0,r0
;;;236        }
;;;237    }
00014e  4770              BX       lr
                  |L1.336|
000150  2000              MOVS     r0,#0                 ;231
000152  4770              BX       lr
;;;238    
                          ENDP

                  uudecode PROC
;;;239    unsigned uudecode(char * inbuf, char * outbuf, int * count)
000154  b5f0              PUSH     {r4-r7,lr}
;;;240    {
000156  4603              MOV      r3,r0
;;;241        unsigned sum;
;;;242        int in_byte_count,out_byte_count;
;;;243        
;;;244        sum=0;
000158  2600              MOVS     r6,#0
;;;245        out_byte_count=0;
00015a  4635              MOV      r5,r6
;;;246        in_byte_count = decode(*inbuf);
00015c  7800              LDRB     r0,[r0,#0]
00015e  f7fffffe          BL       decode
000162  4604              MOV      r4,r0
;;;247        /* Do not decode if byte count is > 45 */
;;;248        if( (in_byte_count > 0) && (in_byte_count <= UU_LINE) )
000164  1e40              SUBS     r0,r0,#1
000166  282c              CMP      r0,#0x2c
000168  d84d              BHI      |L1.518|
00016a  1c5b              ADDS     r3,r3,#1
;;;249        {
;;;250            for (++inbuf; in_byte_count > 0; inbuf += 4, in_byte_count -= 3)
00016c  e049              B        |L1.514|
                  |L1.366|
;;;251            {
;;;252                /* !!! Test for valid printable character is not done !!! */
;;;253                if(in_byte_count >= 3)
00016e  2c03              CMP      r4,#3
000170  db27              BLT      |L1.450|
;;;254                {
;;;255                    outbuf[0] = (decode(inbuf[0]) << 2) | (decode(inbuf[1]) >> 4);
000172  7818              LDRB     r0,[r3,#0]
000174  f7fffffe          BL       decode
000178  0087              LSLS     r7,r0,#2
00017a  7858              LDRB     r0,[r3,#1]
00017c  f7fffffe          BL       decode
000180  ea471010          ORR      r0,r7,r0,LSR #4
000184  7008              STRB     r0,[r1,#0]
;;;256                    outbuf[1] = (decode(inbuf[1]) << 4) | (decode(inbuf[2]) >> 2);
000186  7858              LDRB     r0,[r3,#1]
000188  f7fffffe          BL       decode
00018c  0107              LSLS     r7,r0,#4
00018e  7898              LDRB     r0,[r3,#2]
000190  f7fffffe          BL       decode
000194  ea470090          ORR      r0,r7,r0,LSR #2
000198  7048              STRB     r0,[r1,#1]
;;;257                    outbuf[2] = (decode(inbuf[2]) << 6) | (decode(inbuf[3]));
00019a  78d8              LDRB     r0,[r3,#3]
00019c  f7fffffe          BL       decode
0001a0  4607              MOV      r7,r0
0001a2  7898              LDRB     r0,[r3,#2]
0001a4  f7fffffe          BL       decode
0001a8  ea471080          ORR      r0,r7,r0,LSL #6
0001ac  b2c0              UXTB     r0,r0
0001ae  7088              STRB     r0,[r1,#2]
;;;258                    out_byte_count += 3;
;;;259                    sum = sum + outbuf[0] + outbuf[1] + outbuf[2];
0001b0  f8117b01          LDRB     r7,[r1],#1
0001b4  4430              ADD      r0,r0,r6
0001b6  f811cb02          LDRB     r12,[r1],#2
0001ba  4467              ADD      r7,r7,r12
0001bc  183e              ADDS     r6,r7,r0
0001be  1ced              ADDS     r5,r5,#3
;;;260                    outbuf+=3;
0001c0  e01d              B        |L1.510|
                  |L1.450|
;;;261                }
;;;262                else
;;;263                {
;;;264                     if(in_byte_count >= 1)
0001c2  2c01              CMP      r4,#1
0001c4  db0c              BLT      |L1.480|
;;;265                    {
;;;266                        outbuf[0] = (decode(inbuf[0]) << 2) | (decode(inbuf[1]) >> 4);
0001c6  7818              LDRB     r0,[r3,#0]
0001c8  f7fffffe          BL       decode
0001cc  0087              LSLS     r7,r0,#2
0001ce  7858              LDRB     r0,[r3,#1]
0001d0  f7fffffe          BL       decode
0001d4  ea471010          ORR      r0,r7,r0,LSR #4
0001d8  b2c0              UXTB     r0,r0
0001da  7008              STRB     r0,[r1,#0]
;;;267                        out_byte_count++;
;;;268                        sum = sum + outbuf[0];
0001dc  4406              ADD      r6,r6,r0
0001de  1c6d              ADDS     r5,r5,#1
                  |L1.480|
;;;269                      /* No need to increment the outbuf as this is the last for loop iteration */
;;;270                    }
;;;271                    if(in_byte_count >= 2)
0001e0  2c02              CMP      r4,#2
0001e2  db0c              BLT      |L1.510|
;;;272                    {
;;;273                        outbuf[1] = (decode(inbuf[1]) << 4) | (decode(inbuf[2]) >> 2);
0001e4  7858              LDRB     r0,[r3,#1]
0001e6  f7fffffe          BL       decode
0001ea  0107              LSLS     r7,r0,#4
0001ec  7898              LDRB     r0,[r3,#2]
0001ee  f7fffffe          BL       decode
0001f2  ea470090          ORR      r0,r7,r0,LSR #2
0001f6  b2c0              UXTB     r0,r0
0001f8  7048              STRB     r0,[r1,#1]
;;;274                        out_byte_count++;
;;;275                        sum = sum + outbuf[1];
0001fa  4406              ADD      r6,r6,r0
0001fc  1c6d              ADDS     r5,r5,#1
                  |L1.510|
0001fe  1d1b              ADDS     r3,r3,#4
000200  1ee4              SUBS     r4,r4,#3
                  |L1.514|
000202  2c00              CMP      r4,#0                 ;250
000204  dcb3              BGT      |L1.366|
                  |L1.518|
;;;276                      /* No need to increment the outbuf as this is the last for loop iteration */
;;;277                    }
;;;278                }
;;;279            } /* for loop */
;;;280        }
;;;281        *count = out_byte_count;
;;;282        return(sum);
000206  4630              MOV      r0,r6
000208  6015              STR      r5,[r2,#0]
;;;283    } /* uudecode */
00020a  bdf0              POP      {r4-r7,pc}
;;;284    
                          ENDP

                  encode PROC
;;;285    char encode(char c)
00020c  b110              CBZ      r0,|L1.532|
;;;286    {
00020e  3020              ADDS     r0,r0,#0x20
;;;287        if( c == 0x00)
;;;288        {
;;;289            return(0x60);
;;;290        }
;;;291        else
;;;292        {
;;;293            return(c+SP);
000210  b2c0              UXTB     r0,r0
;;;294        }
;;;295    }
000212  4770              BX       lr
                  |L1.532|
000214  2060              MOVS     r0,#0x60              ;289
000216  4770              BX       lr
;;;296    
                          ENDP

                  uuencode PROC
;;;297    unsigned uuencode(char * inbuf, char * outbuf, int count)
000218  b570              PUSH     {r4-r6,lr}
;;;298    {
00021a  4605              MOV      r5,r0
;;;299        unsigned sum;
;;;300        char byte1,byte2;
;;;301        sum = 0;
00021c  2600              MOVS     r6,#0
;;;302        *outbuf = encode(count);
00021e  b2d0              UXTB     r0,r2
000220  f7fffffe          BL       encode
000224  f8010b01          STRB     r0,[r1],#1
;;;303        outbuf++;
;;;304        while(count>0)
000228  e028              B        |L1.636|
                  |L1.554|
;;;305        {
;;;306            if(count >= 3)
00022a  2a03              CMP      r2,#3
00022c  db05              BLT      |L1.570|
;;;307            {
;;;308                byte1 = inbuf[1];
00022e  786c              LDRB     r4,[r5,#1]
;;;309                byte2 = inbuf[2];
000230  78ab              LDRB     r3,[r5,#2]
;;;310                sum = sum + inbuf[0] + inbuf[1] + inbuf[2];
000232  7828              LDRB     r0,[r5,#0]
000234  441e              ADD      r6,r6,r3
000236  4420              ADD      r0,r0,r4
000238  e02a              B        |L1.656|
                  |L1.570|
;;;311            }
;;;312            else
;;;313            {
;;;314                if(count == 2)
00023a  2a02              CMP      r2,#2
00023c  d024              BEQ      |L1.648|
;;;315                {
;;;316                    byte1 = inbuf[1];
;;;317                    byte2 = inbuf[1];
;;;318                    sum = sum + inbuf[0] + inbuf[1];
;;;319                }
;;;320                else
;;;321                {
;;;322                    byte1 = inbuf[0];
00023e  782b              LDRB     r3,[r5,#0]
000240  461c              MOV      r4,r3
;;;323                    byte2 = inbuf[0];
;;;324                    sum = sum + inbuf[0];
000242  441e              ADD      r6,r6,r3
                  |L1.580|
;;;325                }
;;;326            }
;;;327            outbuf[0] = encode(((inbuf[0] >> 2) & 0x3F));
000244  7828              LDRB     r0,[r5,#0]
000246  0880              LSRS     r0,r0,#2
000248  f7fffffe          BL       encode
00024c  7008              STRB     r0,[r1,#0]
;;;328            outbuf[1] = encode(((inbuf[0] & 0x03) << 4) + ((byte1 & 0xF0) >> 4));
00024e  7828              LDRB     r0,[r5,#0]
000250  0780              LSLS     r0,r0,#30
000252  0e80              LSRS     r0,r0,#26
000254  eb001014          ADD      r0,r0,r4,LSR #4
000258  f7fffffe          BL       encode
00025c  7048              STRB     r0,[r1,#1]
;;;329            outbuf[2] = encode(((byte1 & 0x0F) << 2) + ((byte2 & 0xC0) >> 6));
00025e  0720              LSLS     r0,r4,#28
000260  0e80              LSRS     r0,r0,#26
000262  eb001093          ADD      r0,r0,r3,LSR #6
000266  f7fffffe          BL       encode
00026a  7088              STRB     r0,[r1,#2]
;;;330            outbuf[3] = encode((byte2 & 0x3F));
00026c  f003003f          AND      r0,r3,#0x3f
000270  f7fffffe          BL       encode
000274  70c8              STRB     r0,[r1,#3]
000276  1d09              ADDS     r1,r1,#4
000278  1ed2              SUBS     r2,r2,#3
00027a  1ced              ADDS     r5,r5,#3
                  |L1.636|
00027c  2a00              CMP      r2,#0                 ;304
00027e  dcd4              BGT      |L1.554|
;;;331            outbuf+=4;
;;;332            inbuf+=3;
;;;333            count-=3;
;;;334        } /* while loop */
;;;335        outbuf[0] = NUL;
000280  2000              MOVS     r0,#0
000282  7008              STRB     r0,[r1,#0]
;;;336        return(sum);
000284  4630              MOV      r0,r6
;;;337    } /* uuencode */
000286  bd70              POP      {r4-r6,pc}
                  |L1.648|
000288  786b              LDRB     r3,[r5,#1]            ;316
00028a  7828              LDRB     r0,[r5,#0]            ;318
00028c  461c              MOV      r4,r3                 ;316
00028e  4418              ADD      r0,r0,r3              ;318
                  |L1.656|
000290  4406              ADD      r6,r6,r0              ;318
000292  e7d7              B        |L1.580|
;;;338    
                          ENDP

                  write_to_ram PROC
;;;342    
;;;343    void write_to_ram(void)
000294  b5f0              PUSH     {r4-r7,lr}
;;;344    {
;;;345        unsigned dst,checksum,recvd_checksum;
;;;346        unsigned line_ctr,last_dst;
;;;347        int count,decode_count,last_cnt,char_cnt;
;;;348        unsigned rc;
;;;349        
;;;350        /* Check count validity first as mapping check requires count */
;;;351        rc = param_check(param_buf[ISP_PARAM_2],(unsigned *)&count,COUNT,count);
000296  4d79              LDR      r5,|L1.1148|
000298  b085              SUB      sp,sp,#0x14           ;344
00029a  3594              ADDS     r5,r5,#0x94
00029c  2264              MOVS     r2,#0x64
00029e  68a8              LDR      r0,[r5,#8]  ; param_buf
0002a0  a901              ADD      r1,sp,#4
0002a2  9b01              LDR      r3,[sp,#4]
0002a4  f7fffffe          BL       param_check
0002a8  0004              MOVS     r4,r0
;;;352        if(rc == 0)
0002aa  d10e              BNE      |L1.714|
;;;353        {
;;;354            rc = param_check(param_buf[ISP_PARAM_1],&dst,RAM_ADDRESS,count);
0002ac  6868              LDR      r0,[r5,#4]  ; param_buf
0002ae  2267              MOVS     r2,#0x67
0002b0  4669              MOV      r1,sp
0002b2  9b01              LDR      r3,[sp,#4]
0002b4  f7fffffe          BL       param_check
0002b8  4604              MOV      r4,r0
;;;355            if (rc == SRC_ADDR_NOT_MAPPED)
0002ba  2804              CMP      r0,#4
0002bc  d002              BEQ      |L1.708|
;;;356            {
;;;357                rc = ADDR_NOT_MAPPED;
;;;358            }
;;;359            if (rc == SRC_ADDR_ERROR)
0002be  2c02              CMP      r4,#2
0002c0  d002              BEQ      |L1.712|
0002c2  e002              B        |L1.714|
                  |L1.708|
0002c4  240e              MOVS     r4,#0xe               ;357
0002c6  e000              B        |L1.714|
                  |L1.712|
;;;360            {
;;;361                rc = ADDR_ERROR;
0002c8  240d              MOVS     r4,#0xd
                  |L1.714|
;;;362            }
;;;363        }
;;;364        /* Do not allow write to ISP RAM variable area */
;;;365        if( (crp_after_reset == CRP1) )
0002ca  4870              LDR      r0,|L1.1164|
0002cc  4970              LDR      r1,|L1.1168|
0002ce  6840              LDR      r0,[r0,#4]  ; crp_after_reset
0002d0  4288              CMP      r0,r1
0002d2  d104              BNE      |L1.734|
;;;366        {
;;;367             if( ( dst < (RAM_START) ) )
0002d4  9800              LDR      r0,[sp,#0]
0002d6  f1b05f80          CMP      r0,#0x10000000
0002da  d200              BCS      |L1.734|
;;;368             {
;;;369                 rc = CODE_READ_PROTECTION_ENABLED;
0002dc  2413              MOVS     r4,#0x13
                  |L1.734|
;;;370             }
;;;371         }
;;;372     
;;;373        /* Print command result on serial channel */
;;;374        sendline_crlf(i_to_a(rc,param_buf[ISP_PARAM_0],PARAM_SIZE));
0002de  220f              MOVS     r2,#0xf
0002e0  4620              MOV      r0,r4
0002e2  6829              LDR      r1,[r5,#0]  ; param_buf
0002e4  f7fffffe          BL       i_to_a
0002e8  f7fffffe          BL       sendline_crlf
;;;375    
;;;376        /* execute command only if parameters are ok */
;;;377        if(rc != CMD_SUCCESS)
0002ec  2c00              CMP      r4,#0
0002ee  d142              BNE      |L1.886|
;;;378        {
;;;379            return;
;;;380        }
;;;381        
;;;382        /* Initialize checksum related variables */
;;;383        checksum = 0;
;;;384        line_ctr = 0;
0002f0  e9dd7600          LDRD     r7,r6,[sp,#0]
0002f4  2500              MOVS     r5,#0                 ;383
0002f6  462c              MOV      r4,r5
;;;385        last_dst = dst;
;;;386        last_cnt = count;
;;;387        while(count>0)
0002f8  e03a              B        |L1.880|
                  |L1.762|
;;;388        {
;;;389            if(getline(cmd_buf,CMD_SIZE,&char_cnt) != CMD_SUCCESS)
0002fa  aa03              ADD      r2,sp,#0xc
0002fc  2146              MOVS     r1,#0x46
0002fe  485f              LDR      r0,|L1.1148|
000300  f7fffffe          BL       getline
000304  2800              CMP      r0,#0
000306  d136              BNE      |L1.886|
;;;390            {
;;;391                /* Abort command */
;;;392                break;
;;;393            }
;;;394            /* Keep track of number of lines decoded. Need to verify checksum
;;;395               once the LINE_CHECKSUM lines are receieved */
;;;396            if(char_cnt != 0) /* Ignore empty lines */
000308  9803              LDR      r0,[sp,#0xc]
00030a  b168              CBZ      r0,|L1.808|
;;;397            {
;;;398                line_ctr++;
;;;399                checksum = checksum + uudecode(cmd_buf,(char *)dst,&decode_count);
00030c  aa02              ADD      r2,sp,#8
00030e  485b              LDR      r0,|L1.1148|
000310  1c64              ADDS     r4,r4,#1
000312  9900              LDR      r1,[sp,#0]
000314  f7fffffe          BL       uudecode
000318  4405              ADD      r5,r5,r0
;;;400                dst = dst + decode_count;
00031a  9900              LDR      r1,[sp,#0]
00031c  9802              LDR      r0,[sp,#8]
00031e  4401              ADD      r1,r1,r0
;;;401                count = count - decode_count;
000320  9100              STR      r1,[sp,#0]
000322  9901              LDR      r1,[sp,#4]
000324  1a08              SUBS     r0,r1,r0
000326  9001              STR      r0,[sp,#4]
                  |L1.808|
;;;402            }
;;;403            /* Need checksum handshake ? */
;;;404            if( ((line_ctr == LINE_CHECKSUM) || (count == 0)) )
000328  2c14              CMP      r4,#0x14
00032a  d001              BEQ      |L1.816|
00032c  9801              LDR      r0,[sp,#4]
00032e  b9f8              CBNZ     r0,|L1.880|
                  |L1.816|
;;;405            {
;;;406                char_cnt = 0;
000330  2000              MOVS     r0,#0
000332  9003              STR      r0,[sp,#0xc]
                  |L1.820|
;;;407                /* Get checksum string (ASCII decimal) from host */
;;;408                while(char_cnt == 0)
;;;409                {
;;;410                    rc = getline(cmd_buf,CMD_SIZE,&char_cnt);
000334  aa03              ADD      r2,sp,#0xc
000336  2146              MOVS     r1,#0x46
000338  4850              LDR      r0,|L1.1148|
00033a  f7fffffe          BL       getline
00033e  9903              LDR      r1,[sp,#0xc]          ;408
000340  2900              CMP      r1,#0                 ;408
000342  d0f7              BEQ      |L1.820|
;;;411                }
;;;412                if( rc != CMD_SUCCESS)
000344  2800              CMP      r0,#0
000346  d116              BNE      |L1.886|
;;;413                {
;;;414                    break;
;;;415                }
;;;416                /* No error check while conversion to integer. If there is an error
;;;417                it will be trapped by wrong checksum */
;;;418                a_to_i(cmd_buf,&recvd_checksum);
000348  a904              ADD      r1,sp,#0x10
00034a  484c              LDR      r0,|L1.1148|
00034c  f7fffffe          BL       a_to_i
;;;419                if( checksum == recvd_checksum)
000350  9804              LDR      r0,[sp,#0x10]
000352  4285              CMP      r5,r0
000354  d104              BNE      |L1.864|
;;;420                {
;;;421                    last_cnt = count;
;;;422                    last_dst = dst;
;;;423                    sendline_crlf((char *)ok);
000356  484a              LDR      r0,|L1.1152|
000358  e9dd7600          LDRD     r7,r6,[sp,#0]
00035c  380a              SUBS     r0,r0,#0xa
00035e  e003              B        |L1.872|
                  |L1.864|
;;;424                }
;;;425                else
;;;426                {
;;;427                    count = last_cnt;
;;;428                    dst = last_dst;
;;;429                    sendline_crlf((char *)resend);
000360  4847              LDR      r0,|L1.1152|
000362  e9cd7600          STRD     r7,r6,[sp,#0]
000366  1fc0              SUBS     r0,r0,#7
                  |L1.872|
000368  f7fffffe          BL       sendline_crlf
;;;430                }
;;;431                /* line counter and checksum has to be reset anyway */
;;;432                line_ctr = 0;
00036c  2400              MOVS     r4,#0
;;;433                checksum = 0;
00036e  4625              MOV      r5,r4
                  |L1.880|
000370  9801              LDR      r0,[sp,#4]            ;387
000372  2800              CMP      r0,#0                 ;387
000374  dcc1              BGT      |L1.762|
                  |L1.886|
;;;434            }
;;;435        }/* While loop */
;;;436    } /* write_to_ram */
000376  b005              ADD      sp,sp,#0x14
000378  bdf0              POP      {r4-r7,pc}
;;;437    
                          ENDP

                  read PROC
;;;438    void read(void)
00037a  e92d43fe          PUSH     {r1-r9,lr}
;;;439    {
;;;440        unsigned src,checksum,last_src,line_ctr;
;;;441        int count,encode_count,last_cnt;
;;;442        unsigned rc;
;;;443    	int char_cnt;
;;;444    
;;;445        /* Check count validity first as address mapping check requires count */
;;;446        rc = param_check(param_buf[ISP_PARAM_2],(unsigned *)&count,COUNT,NUL);
00037e  4d3f              LDR      r5,|L1.1148|
000380  2300              MOVS     r3,#0
000382  3594              ADDS     r5,r5,#0x94
000384  2264              MOVS     r2,#0x64
000386  4669              MOV      r1,sp
000388  68a8              LDR      r0,[r5,#8]  ; param_buf
00038a  f7fffffe          BL       param_check
00038e  0004              MOVS     r4,r0
;;;447        if(rc == 0)
000390  d106              BNE      |L1.928|
;;;448        {
;;;449            rc = param_check(param_buf[ISP_PARAM_1],&src,RAM_OR_FLASH_ADDRESS,count);
000392  6868              LDR      r0,[r5,#4]  ; param_buf
000394  2266              MOVS     r2,#0x66
000396  a901              ADD      r1,sp,#4
000398  9b00              LDR      r3,[sp,#0]
00039a  f7fffffe          BL       param_check
00039e  4604              MOV      r4,r0
                  |L1.928|
;;;450        }
;;;451        /* Print command result on serial channel */
;;;452        sendline_crlf(i_to_a(rc,param_buf[ISP_PARAM_0],PARAM_SIZE));
0003a0  220f              MOVS     r2,#0xf
0003a2  6829              LDR      r1,[r5,#0]  ; param_buf
0003a4  f7fffffe          BL       i_to_a
0003a8  f7fffffe          BL       sendline_crlf
;;;453        /* execute command only if parameters are ok */
;;;454        if(rc != CMD_SUCCESS)
0003ac  2c00              CMP      r4,#0
0003ae  d137              BNE      |L1.1056|
;;;455        {
;;;456            return;
;;;457        }
;;;458        
;;;459        /* Initialize checksum related variables */
;;;460        checksum = 0;
;;;461        line_ctr = 0;
;;;462        last_src = src;
;;;463        last_cnt = count;
;;;464    
;;;465        while(count > 0)
0003b0  e9dd7800          LDRD     r7,r8,[sp,#0]
0003b4  2500              MOVS     r5,#0                 ;460
0003b6  462e              MOV      r6,r5                 ;461
0003b8  e02f              B        |L1.1050|
                  |L1.954|
;;;466        {
;;;467            if(count > UU_LINE)
0003ba  2c2d              CMP      r4,#0x2d
0003bc  dd00              BLE      |L1.960|
;;;468            {
;;;469                encode_count = UU_LINE;
0003be  242d              MOVS     r4,#0x2d
                  |L1.960|
;;;470            }
;;;471            else
;;;472            {
;;;473                encode_count = count;
;;;474            }
;;;475            checksum = checksum + uuencode((char *)src,cmd_buf,encode_count);
0003c0  4622              MOV      r2,r4
0003c2  492e              LDR      r1,|L1.1148|
0003c4  9801              LDR      r0,[sp,#4]
0003c6  f7fffffe          BL       uuencode
0003ca  4405              ADD      r5,r5,r0
;;;476            if(sendline_crlf(cmd_buf) != 1)
0003cc  482b              LDR      r0,|L1.1148|
0003ce  f7fffffe          BL       sendline_crlf
0003d2  2801              CMP      r0,#1
0003d4  d124              BNE      |L1.1056|
;;;477            {
;;;478                /* Abort command */
;;;479                break;
;;;480            }
;;;481            /* Keep track of number of lines encoded. Need to send checksum
;;;482               once the LINE_CHECKSUM lines are transmitted */
;;;483            line_ctr++;        
;;;484            src = src + encode_count;
0003d6  9801              LDR      r0,[sp,#4]
;;;485            count = count - encode_count;
0003d8  1c76              ADDS     r6,r6,#1
0003da  4420              ADD      r0,r0,r4              ;484
0003dc  9001              STR      r0,[sp,#4]
0003de  9800              LDR      r0,[sp,#0]
0003e0  1b00              SUBS     r0,r0,r4
;;;486            if( ((line_ctr == LINE_CHECKSUM) || (count == 0)) )
0003e2  9000              STR      r0,[sp,#0]
0003e4  2e14              CMP      r6,#0x14
0003e6  d000              BEQ      |L1.1002|
0003e8  b9b8              CBNZ     r0,|L1.1050|
                  |L1.1002|
;;;487            {
;;;488                /* Tranmitt checksum string (ASCII decimal) to host */
;;;489                sendline_crlf(i_to_a(checksum,cmd_buf,PARAM_SIZE));
0003ea  220f              MOVS     r2,#0xf
0003ec  4923              LDR      r1,|L1.1148|
0003ee  4628              MOV      r0,r5
0003f0  f7fffffe          BL       i_to_a
0003f4  f7fffffe          BL       sendline_crlf
;;;490                /* Read host response */
;;;491                rc = getline(cmd_buf,CMD_SIZE,&char_cnt);
0003f8  aa02              ADD      r2,sp,#8
0003fa  2146              MOVS     r1,#0x46
0003fc  481f              LDR      r0,|L1.1148|
0003fe  f7fffffe          BL       getline
;;;492                if( rc != CMD_SUCCESS)
000402  2800              CMP      r0,#0
000404  d10c              BNE      |L1.1056|
;;;493                {
;;;494                    break;
;;;495                }
;;;496                if(str_cmp(cmd_buf,(char *)ok) == 0)
000406  491e              LDR      r1,|L1.1152|
000408  481c              LDR      r0,|L1.1148|
00040a  390a              SUBS     r1,r1,#0xa
00040c  f7fffffe          BL       str_cmp
000410  b140              CBZ      r0,|L1.1060|
000412  e9cd7800          STRD     r7,r8,[sp,#0]
                  |L1.1046|
;;;497                {
;;;498                    last_cnt = count;
;;;499                    last_src = src;
;;;500                }
;;;501                else
;;;502                {
;;;503                    count = last_cnt;
;;;504                    src = last_src;
;;;505                }
;;;506                /* line counter and checksum has to be reset anyway */
;;;507                line_ctr = 0;
000416  2600              MOVS     r6,#0
;;;508                checksum = 0;
000418  4635              MOV      r5,r6
                  |L1.1050|
00041a  9c00              LDR      r4,[sp,#0]            ;465
00041c  2c00              CMP      r4,#0                 ;465
00041e  dccc              BGT      |L1.954|
                  |L1.1056|
;;;509            }
;;;510        } /* while count > 0 */
;;;511    } /* read */
000420  e8bd83fe          POP      {r1-r9,pc}
                  |L1.1060|
000424  e9dd7000          LDRD     r7,r0,[sp,#0]
000428  4680              MOV      r8,r0                 ;499
00042a  e7f4              B        |L1.1046|
;;;512    
                          ENDP

                  go_cmd PROC
;;;513    void go_cmd(void)
00042c  b538              PUSH     {r3-r5,lr}
;;;514    {
;;;515        unsigned rc;
;;;516        void (*go)(void);
;;;517        
;;;518        if(lock == FALSE)
00042e  4817              LDR      r0,|L1.1164|
;;;519        {
;;;520            rc = CMD_SUCCESS;
;;;521        }
;;;522        else
;;;523        {
;;;524            rc = CMD_LOCKED;
;;;525        }
;;;526            
;;;527        if(rc == CMD_SUCCESS)
;;;528        {
;;;529            /* Convert and check Go addres */
;;;530            rc = param_check(param_buf[ISP_PARAM_1],(unsigned *)&go, \
000430  4d12              LDR      r5,|L1.1148|
000432  6800              LDR      r0,[r0,#0]            ;518  ; lock
000434  3594              ADDS     r5,r5,#0x94
000436  b108              CBZ      r0,|L1.1084|
000438  240f              MOVS     r4,#0xf               ;524
00043a  e00c              B        |L1.1110|
                  |L1.1084|
00043c  2300              MOVS     r3,#0
00043e  2266              MOVS     r2,#0x66
000440  4669              MOV      r1,sp
000442  6868              LDR      r0,[r5,#4]  ; param_buf
000444  f7fffffe          BL       param_check
000448  0004              MOVS     r4,r0
00044a  d104              BNE      |L1.1110|
;;;531                 RAM_OR_FLASH_ADDRESS,NUL);
;;;532        }
;;;533        
;;;534        if(rc == CMD_SUCCESS)
;;;535        {
;;;536            /* Check for processor mode switch */
;;;537            if(*(param_buf[ISP_PARAM_2]) == 'T')
00044c  68a8              LDR      r0,[r5,#8]  ; param_buf
00044e  7800              LDRB     r0,[r0,#0]
000450  2854              CMP      r0,#0x54
000452  d00e              BEQ      |L1.1138|
;;;538            {
;;;539                /* ARM Thumb compiler generates BX instruction when pointer 
;;;540                to a function is used. Set last bit of the address to 1 
;;;541                to prevent mode switch to ARM */
;;;542                go = (void(*)(void))( ((unsigned)(go) | 0x1) );
;;;543            }
;;;544            else
;;;545            {
;;;546                /* Mode parameter is not specified or incorrect */
;;;547                rc = PARAM_ERROR;
000454  240c              MOVS     r4,#0xc
                  |L1.1110|
;;;548            }
;;;549        }
;;;550        /* Print command result on serial channel */
;;;551        sendline_crlf(i_to_a(rc,param_buf[ISP_PARAM_1],PARAM_SIZE));
000456  220f              MOVS     r2,#0xf
000458  4620              MOV      r0,r4
00045a  6869              LDR      r1,[r5,#4]  ; param_buf
00045c  f7fffffe          BL       i_to_a
000460  f7fffffe          BL       sendline_crlf
;;;552        /* execute command only if all the parameters are ok */
;;;553        if(rc == CMD_SUCCESS)
000464  2c00              CMP      r4,#0
000466  d103              BNE      |L1.1136|
;;;554        {
;;;555    	    /* revert any peripheral changes */
;;;556            Timer_DeInit();
000468  f7fffffe          BL       Timer_DeInit
;;;557            go();
00046c  9800              LDR      r0,[sp,#0]
00046e  4780              BLX      r0
                  |L1.1136|
;;;558        }
;;;559    } /* go */
000470  bd38              POP      {r3-r5,pc}
                  |L1.1138|
000472  9800              LDR      r0,[sp,#0]            ;542
000474  f0400001          ORR      r0,r0,#1              ;542
000478  9000              STR      r0,[sp,#0]            ;542
00047a  e7ec              B        |L1.1110|
                  |L1.1148|
                          DCD      ||.bss||
                  |L1.1152|
                          DCD      ||area_number.6||+0xa
                  |L1.1156|
                          DCD      0x10008000
                  |L1.1160|
                          DCD      0x1fff1ff1
                  |L1.1164|
                          DCD      ||.data||
                  |L1.1168|
                          DCD      0x12345678
                          ENDP

                  unlock PROC
;;;560    
;;;561    void unlock(void)
000494  b538              PUSH     {r3-r5,lr}
;;;562    {
;;;563        int u_code;
;;;564        unsigned rc;
;;;565        rc = param_check(param_buf[ISP_PARAM_1],(unsigned *)&u_code,NO_PARAM_CHECK,NUL);
000496  4cf8              LDR      r4,|L1.2168|
000498  2300              MOVS     r3,#0
00049a  2269              MOVS     r2,#0x69
00049c  4669              MOV      r1,sp
00049e  6860              LDR      r0,[r4,#4]  ; param_buf
0004a0  f7fffffe          BL       param_check
;;;566        /* execute command only if parameters are ok */
;;;567        if(rc == 0)
0004a4  b928              CBNZ     r0,|L1.1202|
;;;568        {
;;;569            if(u_code == unlock_code)
0004a6  9900              LDR      r1,[sp,#0]
0004a8  f5a142b4          SUB      r2,r1,#0x5a00
0004ac  3a5a              SUBS     r2,r2,#0x5a
0004ae  d007              BEQ      |L1.1216|
;;;570            {
;;;571                lock = FALSE;    
;;;572            }
;;;573            else
;;;574            {
;;;575                rc = INVALID_CODE;
0004b0  2010              MOVS     r0,#0x10
                  |L1.1202|
;;;576            }
;;;577        }
;;;578        /* Print command result on serial channel */
;;;579        sendline_crlf(i_to_a(rc,param_buf[ISP_PARAM_1],PARAM_SIZE));
0004b2  220f              MOVS     r2,#0xf
0004b4  6861              LDR      r1,[r4,#4]  ; param_buf
0004b6  f7fffffe          BL       i_to_a
0004ba  f7fffffe          BL       sendline_crlf
;;;580    } /* unlock */
0004be  bd38              POP      {r3-r5,pc}
                  |L1.1216|
0004c0  4aee              LDR      r2,|L1.2172|
0004c2  2100              MOVS     r1,#0                 ;571
0004c4  6011              STR      r1,[r2,#0]            ;571  ; lock
0004c6  e7f4              B        |L1.1202|
;;;581    
                          ENDP

                  prepare_sector PROC
;;;582    void prepare_sector(void)
0004c8  b570              PUSH     {r4-r6,lr}
;;;583    {
;;;584        /* Convert ascii string to integer. Do not validate sector numbers as it is
;;;585           done in IAP prepare sector for write. Parameter type is deliberately 
;;;586           set to NO_PARAM_CHECK so that param_check function just converts ascii 
;;;587           to integer 
;;;588        */
;;;589        result_table[IAP_STAT_CODE] = param_check(param_buf[ISP_PARAM_1], \
0004ca  4deb              LDR      r5,|L1.2168|
0004cc  2300              MOVS     r3,#0
0004ce  f1050614          ADD      r6,r5,#0x14
0004d2  2269              MOVS     r2,#0x69
0004d4  1d31              ADDS     r1,r6,#4
0004d6  6868              LDR      r0,[r5,#4]  ; param_buf
0004d8  f7fffffe          BL       param_check
0004dc  f1050428          ADD      r4,r5,#0x28
;;;590        &param_table[IAP_PARAM_0],NO_PARAM_CHECK,NUL);
;;;591    
;;;592        if( result_table[IAP_STAT_CODE] == CMD_SUCCESS )
0004e0  6020              STR      r0,[r4,#0]  ; result_table
0004e2  b970              CBNZ     r0,|L1.1282|
;;;593        {
;;;594            result_table[IAP_STAT_CODE] = param_check(param_buf[ISP_PARAM_2], \
0004e4  2300              MOVS     r3,#0
0004e6  2269              MOVS     r2,#0x69
0004e8  f1a4010c          SUB      r1,r4,#0xc
0004ec  68a8              LDR      r0,[r5,#8]  ; param_buf
0004ee  f7fffffe          BL       param_check
0004f2  6020              STR      r0,[r4,#0]  ; result_table
0004f4  b928              CBNZ     r0,|L1.1282|
;;;595            &param_table[IAP_PARAM_1],NO_PARAM_CHECK,NUL);
;;;596        }
;;;597            
;;;598        if( result_table[IAP_STAT_CODE] == CMD_SUCCESS )
;;;599        {
;;;600            param_table[IAP_CMD_CODE] = PREPARE_SECTOR_FOR_WRITE;
0004f6  2032              MOVS     r0,#0x32
;;;601            iap_entry(param_table,result_table);
0004f8  6030              STR      r0,[r6,#0]  ; param_table
0004fa  4621              MOV      r1,r4
0004fc  4630              MOV      r0,r6
0004fe  f7fffffe          BL       iap_entry
                  |L1.1282|
;;;602        }
;;;603        sendline_crlf(i_to_a(result_table[IAP_STAT_CODE],param_buf[ISP_PARAM_1], \
000502  6869              LDR      r1,[r5,#4]  ; param_buf
000504  220f              MOVS     r2,#0xf
000506  6820              LDR      r0,[r4,#0]  ; result_table
000508  f7fffffe          BL       i_to_a
00050c  e8bd4070          POP      {r4-r6,lr}
000510  f7ffbffe          B.W      sendline_crlf
;;;604        PARAM_SIZE));
;;;605    } /* prepare_sector */
;;;606    
                          ENDP

                  copy PROC
;;;607    void copy(void)
000514  e92d41f0          PUSH     {r4-r8,lr}
;;;608    {
;;;609        if(lock == TRUE)
000518  4fd8              LDR      r7,|L1.2172|
;;;610        {
;;;611            sendline_crlf(i_to_a(CMD_LOCKED,param_buf[ISP_PARAM_1],PARAM_SIZE));
00051a  4dd7              LDR      r5,|L1.2168|
00051c  6839              LDR      r1,[r7,#0]  ; lock
00051e  6868              LDR      r0,[r5,#4]            ;609
000520  2901              CMP      r1,#1                 ;609
000522  d00b              BEQ      |L1.1340|
;;;612        }
;;;613        else
;;;614        {
;;;615        /* Convert ascii string to integer. Do not validate sector numbers as it is
;;;616        done in IAP copy RAM to FLASH.Parameter type is deliberately 
;;;617        set to NO_PARAM_CHECK so that param_check function just converts ascii to integer
;;;618        */
;;;619            result_table[IAP_STAT_CODE] = param_check(param_buf[ISP_PARAM_1], \
000524  f1050614          ADD      r6,r5,#0x14
000528  2300              MOVS     r3,#0
00052a  2269              MOVS     r2,#0x69
00052c  1d31              ADDS     r1,r6,#4
00052e  f7fffffe          BL       param_check
000532  f1050428          ADD      r4,r5,#0x28
;;;620            &param_table[IAP_PARAM_0],NO_PARAM_CHECK,NUL);
;;;621    
;;;622            if( result_table[IAP_STAT_CODE] == CMD_SUCCESS )
000536  6020              STR      r0,[r4,#0]  ; result_table
000538  b120              CBZ      r0,|L1.1348|
00053a  e014              B        |L1.1382|
                  |L1.1340|
00053c  220f              MOVS     r2,#0xf               ;611
00053e  4601              MOV      r1,r0                 ;611
000540  4610              MOV      r0,r2                 ;611
000542  e02b              B        |L1.1436|
                  |L1.1348|
;;;623            {
;;;624                result_table[IAP_STAT_CODE] = param_check(param_buf[ISP_PARAM_2], \
000544  49cc              LDR      r1,|L1.2168|
000546  2300              MOVS     r3,#0
000548  2269              MOVS     r2,#0x69
00054a  311c              ADDS     r1,r1,#0x1c
00054c  68a8              LDR      r0,[r5,#8]  ; param_buf
00054e  f7fffffe          BL       param_check
000552  6020              STR      r0,[r4,#0]  ; result_table
000554  b938              CBNZ     r0,|L1.1382|
;;;625                &param_table[IAP_PARAM_1],NO_PARAM_CHECK,NUL);
;;;626            }
;;;627    
;;;628            if( result_table[IAP_STAT_CODE] == CMD_SUCCESS )
;;;629            {
;;;630                result_table[IAP_STAT_CODE] = param_check(param_buf[ISP_PARAM_3], \
000556  49c8              LDR      r1,|L1.2168|
000558  2300              MOVS     r3,#0
00055a  2269              MOVS     r2,#0x69
00055c  3120              ADDS     r1,r1,#0x20
00055e  68e8              LDR      r0,[r5,#0xc]  ; param_buf
000560  f7fffffe          BL       param_check
000564  6020              STR      r0,[r4,#0]  ; result_table
                  |L1.1382|
;;;631                &param_table[IAP_PARAM_2],NO_PARAM_CHECK,NUL);
;;;632            }
;;;633    
;;;634            /* Do not allow write to USER Start sector */
;;;635            if( (crp_after_reset == CRP1) )
000566  49c6              LDR      r1,|L1.2176|
000568  6878              LDR      r0,[r7,#4]  ; crp_after_reset
00056a  4288              CMP      r0,r1
00056c  d106              BNE      |L1.1404|
;;;636            {
;;;637                if( (param_table[IAP_PARAM_0] < (USER_START_SECTOR_ADDRESS+USER_START_SECTOR_SIZE)) )
00056e  6870              LDR      r0,[r6,#4]  ; param_table
000570  f5b05f40          CMP      r0,#0x3000
000574  d202              BCS      |L1.1404|
;;;638                {
;;;639                    result_table[IAP_STAT_CODE] = CODE_READ_PROTECTION_ENABLED;
000576  2013              MOVS     r0,#0x13
000578  6020              STR      r0,[r4,#0]  ; result_table
00057a  e00c              B        |L1.1430|
                  |L1.1404|
;;;640                }
;;;641            }
;;;642    
;;;643            if( result_table[IAP_STAT_CODE] == CMD_SUCCESS )
00057c  6820              LDR      r0,[r4,#0]  ; result_table
00057e  b950              CBNZ     r0,|L1.1430|
;;;644            {
;;;645                param_table[IAP_CMD_CODE] = COPY_RAM_TO_FLASH;
000580  2033              MOVS     r0,#0x33
;;;646                param_table[IAP_PARAM_3] = fcclk_KHz;
000582  6030              STR      r0,[r6,#0]  ; param_table
;;;647                iap_entry(param_table,result_table);
000584  49bc              LDR      r1,|L1.2168|
000586  f44f407a          MOV      r0,#0xfa00            ;646
00058a  3128              ADDS     r1,r1,#0x28
00058c  6130              STR      r0,[r6,#0x10]  ; param_table
00058e  f1a10014          SUB      r0,r1,#0x14
000592  f7fffffe          BL       iap_entry
                  |L1.1430|
;;;648            }
;;;649            sendline_crlf(i_to_a(result_table[IAP_STAT_CODE],param_buf[ISP_PARAM_1], \
000596  6869              LDR      r1,[r5,#4]  ; param_buf
000598  220f              MOVS     r2,#0xf
00059a  6820              LDR      r0,[r4,#0]  ; result_table
                  |L1.1436|
00059c  f7fffffe          BL       i_to_a
0005a0  e8bd41f0          POP      {r4-r8,lr}
0005a4  f7ffbffe          B.W      sendline_crlf
;;;650            PARAM_SIZE));
;;;651        }
;;;652    } /* copy */
;;;653    
                          ENDP

                  erase PROC
;;;654    void erase(void)
0005a8  e92d41f0          PUSH     {r4-r8,lr}
;;;655    {
;;;656        if(lock == TRUE)
0005ac  4fb3              LDR      r7,|L1.2172|
;;;657        {
;;;658            sendline_crlf(i_to_a(CMD_LOCKED,param_buf[ISP_PARAM_1],PARAM_SIZE));
0005ae  4eb2              LDR      r6,|L1.2168|
0005b0  6839              LDR      r1,[r7,#0]  ; lock
0005b2  6870              LDR      r0,[r6,#4]            ;656
0005b4  2901              CMP      r1,#1                 ;656
0005b6  d00b              BEQ      |L1.1488|
;;;659        }
;;;660        else
;;;661        {
;;;662        /* Convert ascii string to integer. Do not validate sector numbers as it is
;;;663           done in IAP erase sector. Parameter type is deliberately 
;;;664           set to NO_PARAM_CHECK so that param_check function just converts ascii to integer 
;;;665        */
;;;666            result_table[IAP_STAT_CODE] = param_check(param_buf[ISP_PARAM_1], \
0005b8  f1060414          ADD      r4,r6,#0x14
0005bc  2300              MOVS     r3,#0
0005be  2269              MOVS     r2,#0x69
0005c0  1d21              ADDS     r1,r4,#4
0005c2  f7fffffe          BL       param_check
0005c6  f1040514          ADD      r5,r4,#0x14
;;;667            &param_table[IAP_PARAM_0],NO_PARAM_CHECK,NUL);
;;;668    
;;;669            if( result_table[IAP_STAT_CODE] == CMD_SUCCESS )
0005ca  6028              STR      r0,[r5,#0]  ; result_table
0005cc  b120              CBZ      r0,|L1.1496|
0005ce  e00b              B        |L1.1512|
                  |L1.1488|
0005d0  220f              MOVS     r2,#0xf               ;658
0005d2  4601              MOV      r1,r0                 ;658
0005d4  4610              MOV      r0,r2                 ;658
0005d6  e03b              B        |L1.1616|
                  |L1.1496|
;;;670            {
;;;671                result_table[IAP_STAT_CODE] = param_check(param_buf[ISP_PARAM_2], \
0005d8  49a7              LDR      r1,|L1.2168|
0005da  2300              MOVS     r3,#0
0005dc  2269              MOVS     r2,#0x69
0005de  311c              ADDS     r1,r1,#0x1c
0005e0  68b0              LDR      r0,[r6,#8]  ; param_buf
0005e2  f7fffffe          BL       param_check
0005e6  6028              STR      r0,[r5,#0]  ; result_table
                  |L1.1512|
;;;672                &param_table[IAP_PARAM_1],NO_PARAM_CHECK,NUL);
;;;673            }
;;;674    
;;;675            /* If code read protection level 2 or 3 is enabled allow erase command only when
;;;676               all sectors are selected for erase */
;;;677            if( (crp_after_reset == CRP2) ||                     \
0005e8  4aa6              LDR      r2,|L1.2180|
0005ea  6878              LDR      r0,[r7,#4]  ; crp_after_reset
;;;678                (crp_after_reset == CRP3) 
;;;679               )
;;;680            {
;;;681                if( (param_table[IAP_PARAM_0] != USER_START_SECTOR) ||                         \
;;;682                    (param_table[IAP_PARAM_1] != USER_END_SECTOR)
;;;683                  )
;;;684                {
;;;685                    result_table[IAP_STAT_CODE] = CODE_READ_PROTECTION_ENABLED;
0005ec  2113              MOVS     r1,#0x13
0005ee  4290              CMP      r0,r2                 ;677
0005f0  d003              BEQ      |L1.1530|
0005f2  ea4f4232          ROR      r2,r2,#16             ;678
0005f6  4290              CMP      r0,r2                 ;678
0005f8  d107              BNE      |L1.1546|
                  |L1.1530|
0005fa  6860              LDR      r0,[r4,#4]            ;681  ; param_table
0005fc  2802              CMP      r0,#2                 ;681
0005fe  d102              BNE      |L1.1542|
000600  68a0              LDR      r0,[r4,#8]            ;682  ; param_table
000602  281d              CMP      r0,#0x1d              ;682
000604  d00c              BEQ      |L1.1568|
                  |L1.1542|
000606  6029              STR      r1,[r5,#0]  ; result_table
000608  e017              B        |L1.1594|
                  |L1.1546|
;;;686                }
;;;687            }
;;;688    
;;;689            /* If code read protection level 1 is enabled allow erase command only when
;;;690               user start sector is NOT selected for erase */
;;;691            else if( (crp_after_reset == CRP1) )
00060a  4a9d              LDR      r2,|L1.2176|
00060c  4290              CMP      r0,r2
00060e  d107              BNE      |L1.1568|
;;;692            {
;;;693               if( (param_table[IAP_PARAM_0] == USER_START_SECTOR) &&                         \
000610  6860              LDR      r0,[r4,#4]  ; param_table
000612  2802              CMP      r0,#2
000614  d104              BNE      |L1.1568|
;;;694                   (param_table[IAP_PARAM_1] != USER_END_SECTOR)
000616  68a0              LDR      r0,[r4,#8]  ; param_table
000618  281d              CMP      r0,#0x1d
00061a  d001              BEQ      |L1.1568|
;;;695                 )
;;;696                {
;;;697                    result_table[IAP_STAT_CODE] = CODE_READ_PROTECTION_ENABLED;
00061c  6029              STR      r1,[r5,#0]  ; result_table
00061e  e014              B        |L1.1610|
                  |L1.1568|
;;;698                }
;;;699            }
;;;700    
;;;701            if( result_table[IAP_STAT_CODE] == CMD_SUCCESS )
000620  6828              LDR      r0,[r5,#0]  ; result_table
000622  b950              CBNZ     r0,|L1.1594|
;;;702            {
;;;703                param_table[IAP_CMD_CODE] = ERASE_SECTOR;
000624  2034              MOVS     r0,#0x34
;;;704                param_table[IAP_PARAM_2] = fcclk_KHz;
000626  6020              STR      r0,[r4,#0]  ; param_table
;;;705                iap_entry(param_table,result_table);
000628  4993              LDR      r1,|L1.2168|
00062a  f44f407a          MOV      r0,#0xfa00            ;704
00062e  3128              ADDS     r1,r1,#0x28
000630  60e0              STR      r0,[r4,#0xc]  ; param_table
000632  f1a10014          SUB      r0,r1,#0x14
000636  f7fffffe          BL       iap_entry
                  |L1.1594|
;;;706            }
;;;707            /* Update code protection status if all sectors are erased */
;;;708            if( (param_table[IAP_PARAM_0] == USER_START_SECTOR) &&                         \
00063a  6860              LDR      r0,[r4,#4]  ; param_table
00063c  2802              CMP      r0,#2
00063e  d104              BNE      |L1.1610|
;;;709                (param_table[IAP_PARAM_1] == USER_END_SECTOR)
000640  68a0              LDR      r0,[r4,#8]  ; param_table
000642  281d              CMP      r0,#0x1d
000644  d101              BNE      |L1.1610|
;;;710              )
;;;711            {
;;;712                crp_after_reset = NOCRP;       
000646  4890              LDR      r0,|L1.2184|
000648  6078              STR      r0,[r7,#4]  ; crp_after_reset
                  |L1.1610|
;;;713            }
;;;714            sendline_crlf(i_to_a(result_table[IAP_STAT_CODE],param_buf[ISP_PARAM_1], \
00064a  6871              LDR      r1,[r6,#4]  ; param_buf
00064c  220f              MOVS     r2,#0xf
00064e  6828              LDR      r0,[r5,#0]  ; result_table
                  |L1.1616|
000650  f7fffffe          BL       i_to_a
000654  e8bd41f0          POP      {r4-r8,lr}
000658  f7ffbffe          B.W      sendline_crlf
;;;715            PARAM_SIZE));
;;;716        }
;;;717    } /* erase */
;;;718    
                          ENDP

                  blank_check PROC
;;;719    void blank_check(void)
00065c  b570              PUSH     {r4-r6,lr}
;;;720    {
;;;721        /* Convert ascii string to integer. Do not validate sector numbers as it is
;;;722           done in IAP blank check sector. Parameter type is deliberately 
;;;723           set to NO_PARAM_CHECK so that param_check function just converts ascii 
;;;724           to integer
;;;725        */
;;;726        result_table[IAP_STAT_CODE] = param_check(param_buf[ISP_PARAM_1], \
00065e  4d86              LDR      r5,|L1.2168|
000660  2300              MOVS     r3,#0
000662  f1050614          ADD      r6,r5,#0x14
000666  2269              MOVS     r2,#0x69
000668  1d31              ADDS     r1,r6,#4
00066a  6868              LDR      r0,[r5,#4]  ; param_buf
00066c  f7fffffe          BL       param_check
000670  f1050428          ADD      r4,r5,#0x28
;;;727        &param_table[IAP_PARAM_0],NO_PARAM_CHECK,NUL);
;;;728        
;;;729        if( result_table[IAP_STAT_CODE] == CMD_SUCCESS )
000674  6020              STR      r0,[r4,#0]  ; result_table
000676  b970              CBNZ     r0,|L1.1686|
;;;730        {
;;;731            result_table[IAP_STAT_CODE] = param_check(param_buf[ISP_PARAM_2], \
000678  2300              MOVS     r3,#0
00067a  2269              MOVS     r2,#0x69
00067c  f1a4010c          SUB      r1,r4,#0xc
000680  68a8              LDR      r0,[r5,#8]  ; param_buf
000682  f7fffffe          BL       param_check
000686  6020              STR      r0,[r4,#0]  ; result_table
000688  b928              CBNZ     r0,|L1.1686|
;;;732            &param_table[IAP_PARAM_1],NO_PARAM_CHECK,NUL);
;;;733        }    
;;;734        
;;;735        if( result_table[IAP_STAT_CODE] == CMD_SUCCESS )
;;;736        {
;;;737            param_table[IAP_CMD_CODE] = BLANK_CHECK_SECTOR;
00068a  2035              MOVS     r0,#0x35
;;;738            iap_entry(param_table,result_table);
00068c  6030              STR      r0,[r6,#0]  ; param_table
00068e  4621              MOV      r1,r4
000690  4630              MOV      r0,r6
000692  f7fffffe          BL       iap_entry
                  |L1.1686|
;;;739        }
;;;740        sendline_crlf(i_to_a(result_table[IAP_STAT_CODE],param_buf[ISP_PARAM_1], \
000696  6869              LDR      r1,[r5,#4]  ; param_buf
000698  220f              MOVS     r2,#0xf
00069a  6820              LDR      r0,[r4,#0]  ; result_table
00069c  f7fffffe          BL       i_to_a
0006a0  f7fffffe          BL       sendline_crlf
;;;741        PARAM_SIZE));
;;;742        if(result_table[IAP_STAT_CODE] == SECTOR_NOT_BLANK)
0006a4  6820              LDR      r0,[r4,#0]  ; result_table
0006a6  2808              CMP      r0,#8
0006a8  d11e              BNE      |L1.1768|
;;;743        {
;;;744            if( ( (crp_after_reset == CRP1)       ||       \
0006aa  4874              LDR      r0,|L1.2172|
0006ac  4974              LDR      r1,|L1.2176|
0006ae  6840              LDR      r0,[r0,#4]  ; crp_after_reset
0006b0  4288              CMP      r0,r1
0006b2  d006              BEQ      |L1.1730|
;;;745                  (crp_after_reset == CRP2)       ||       \
0006b4  4973              LDR      r1,|L1.2180|
0006b6  4288              CMP      r0,r1
0006b8  d003              BEQ      |L1.1730|
;;;746                  (crp_after_reset == CRP3) )              \
0006ba  ea4f4131          ROR      r1,r1,#16
0006be  4288              CMP      r0,r1
0006c0  d102              BNE      |L1.1736|
                  |L1.1730|
;;;747              )
;;;748            {
;;;749                result_table[IAP_RESULT_0]=0;
0006c2  2000              MOVS     r0,#0
;;;750                result_table[IAP_RESULT_1]=0;
0006c4  6060              STR      r0,[r4,#4]  ; result_table
0006c6  60a0              STR      r0,[r4,#8]  ; result_table
                  |L1.1736|
;;;751            }
;;;752            sendline_crlf(i_to_a(result_table[IAP_RESULT_0],param_buf[ISP_PARAM_1], \
0006c8  6869              LDR      r1,[r5,#4]  ; param_buf
0006ca  220f              MOVS     r2,#0xf
0006cc  6860              LDR      r0,[r4,#4]  ; result_table
0006ce  f7fffffe          BL       i_to_a
0006d2  f7fffffe          BL       sendline_crlf
;;;753            PARAM_SIZE));
;;;754            sendline_crlf(i_to_a(result_table[IAP_RESULT_1],param_buf[ISP_PARAM_1], \
0006d6  6869              LDR      r1,[r5,#4]  ; param_buf
0006d8  220f              MOVS     r2,#0xf
0006da  68a0              LDR      r0,[r4,#8]  ; result_table
0006dc  f7fffffe          BL       i_to_a
0006e0  e8bd4070          POP      {r4-r6,lr}
0006e4  f7ffbffe          B.W      sendline_crlf
                  |L1.1768|
;;;755            PARAM_SIZE));
;;;756        }
;;;757    } /* blank_check */
0006e8  bd70              POP      {r4-r6,pc}
;;;758    
                          ENDP

                  compare_mem PROC
;;;759    void compare_mem(void)
0006ea  b570              PUSH     {r4-r6,lr}
;;;760    {
;;;761        /* Convert ascii string to integer. Do not validate address & count as it is
;;;762        done in IAP COMPARE command.Parameter type is deliberately 
;;;763        set to NO_PARAM_CHECK so that param_check function just converts ascii to integer
;;;764        */
;;;765        result_table[IAP_STAT_CODE] = param_check(param_buf[ISP_PARAM_1], \
0006ec  4d62              LDR      r5,|L1.2168|
0006ee  2300              MOVS     r3,#0
0006f0  f1050614          ADD      r6,r5,#0x14
0006f4  2269              MOVS     r2,#0x69
0006f6  1d31              ADDS     r1,r6,#4
0006f8  6868              LDR      r0,[r5,#4]  ; param_buf
0006fa  f7fffffe          BL       param_check
0006fe  f1050428          ADD      r4,r5,#0x28
;;;766        &param_table[IAP_PARAM_0],NO_PARAM_CHECK,NUL);
;;;767    
;;;768        if( result_table[IAP_STAT_CODE] == CMD_SUCCESS )
000702  6020              STR      r0,[r4,#0]  ; result_table
000704  b9b8              CBNZ     r0,|L1.1846|
;;;769        {
;;;770            result_table[IAP_STAT_CODE] = param_check(param_buf[ISP_PARAM_2], \
000706  2300              MOVS     r3,#0
000708  2269              MOVS     r2,#0x69
00070a  f1a4010c          SUB      r1,r4,#0xc
00070e  68a8              LDR      r0,[r5,#8]  ; param_buf
000710  f7fffffe          BL       param_check
000714  6020              STR      r0,[r4,#0]  ; result_table
000716  b970              CBNZ     r0,|L1.1846|
;;;771            &param_table[IAP_PARAM_1],NO_PARAM_CHECK,NUL);
;;;772        }
;;;773    
;;;774        if( result_table[IAP_STAT_CODE] == CMD_SUCCESS )
;;;775        {
;;;776            result_table[IAP_STAT_CODE] = param_check(param_buf[ISP_PARAM_3], \
000718  2300              MOVS     r3,#0
00071a  2269              MOVS     r2,#0x69
00071c  f1a40108          SUB      r1,r4,#8
000720  68e8              LDR      r0,[r5,#0xc]  ; param_buf
000722  f7fffffe          BL       param_check
000726  6020              STR      r0,[r4,#0]  ; result_table
000728  b928              CBNZ     r0,|L1.1846|
;;;777            &param_table[IAP_PARAM_2],NO_PARAM_CHECK,NUL);
;;;778        }
;;;779    
;;;780        if( result_table[IAP_STAT_CODE] == CMD_SUCCESS )
;;;781        {
;;;782            param_table[IAP_CMD_CODE] = COMPARE;
00072a  2038              MOVS     r0,#0x38
;;;783            iap_entry(param_table,result_table);
00072c  6030              STR      r0,[r6,#0]  ; param_table
00072e  4621              MOV      r1,r4
000730  4630              MOV      r0,r6
000732  f7fffffe          BL       iap_entry
                  |L1.1846|
;;;784        }
;;;785        sendline_crlf(i_to_a(result_table[IAP_STAT_CODE],param_buf[ISP_PARAM_1], \
000736  6869              LDR      r1,[r5,#4]  ; param_buf
000738  220f              MOVS     r2,#0xf
00073a  6820              LDR      r0,[r4,#0]  ; result_table
00073c  f7fffffe          BL       i_to_a
000740  f7fffffe          BL       sendline_crlf
;;;786        PARAM_SIZE));
;;;787        if(result_table[IAP_STAT_CODE] == COMPARE_ERROR)
000744  6820              LDR      r0,[r4,#0]  ; result_table
000746  280a              CMP      r0,#0xa
000748  d108              BNE      |L1.1884|
;;;788        {
;;;789            sendline_crlf(i_to_a(result_table[IAP_RESULT_0],param_buf[ISP_PARAM_1], \
00074a  6869              LDR      r1,[r5,#4]  ; param_buf
00074c  220f              MOVS     r2,#0xf
00074e  6860              LDR      r0,[r4,#4]  ; result_table
000750  f7fffffe          BL       i_to_a
000754  e8bd4070          POP      {r4-r6,lr}
000758  f7ffbffe          B.W      sendline_crlf
                  |L1.1884|
;;;790            PARAM_SIZE));
;;;791        }
;;;792    }
00075c  bd70              POP      {r4-r6,pc}
;;;793    
                          ENDP

                  tokenize PROC
;;;794    int tokenize(char * in_buf,int no_of_chars_in_inbuf,char * out_buf[],   \
00075e  e92d43f0          PUSH     {r4-r9,lr}
;;;795                 int max_tokens,int max_chars_per_token )
;;;796    {
000762  4607              MOV      r7,r0
000764  4691              MOV      r9,r2
;;;797        int i,token_count=0,pos=0, chars_in_token=0;
000766  2000              MOVS     r0,#0
;;;798    
;;;799        if(in_buf[0] == NUL)
000768  783a              LDRB     r2,[r7,#0]
00076a  9e07              LDR      r6,[sp,#0x1c]         ;796
00076c  4605              MOV      r5,r0                 ;797
00076e  4604              MOV      r4,r0                 ;797
000770  b112              CBZ      r2,|L1.1912|
;;;800        {
;;;801            return(0);
;;;802        }
;;;803        for(i=0;i<=no_of_chars_in_inbuf;i++)
000772  2200              MOVS     r2,#0
000774  1eb6              SUBS     r6,r6,#2
000776  e028              B        |L1.1994|
                  |L1.1912|
000778  2000              MOVS     r0,#0                 ;801
                  |L1.1914|
;;;804        {
;;;805            if( token_count+1 > max_tokens)
;;;806            {
;;;807                return(token_count+1);
;;;808            }
;;;809            
;;;810            if( (in_buf[i] != SP)  &&                                      \
;;;811                (chars_in_token < (max_chars_per_token -2)) )
;;;812            {
;;;813                *(out_buf[token_count]+pos) = in_buf[i];
;;;814                pos++;
;;;815                chars_in_token++;
;;;816            }
;;;817            else if( (in_buf[i+1] != SP) ||                                \
;;;818                     (chars_in_token == (max_chars_per_token -2)) )
;;;819            {
;;;820                *(out_buf[token_count]+pos) = NUL;
;;;821                token_count++;
;;;822                pos=0;
;;;823                chars_in_token=0;
;;;824            }            
;;;825        }
;;;826        return(token_count+1);
;;;827    } /* tokenize */
00077a  e8bd83f0          POP      {r4-r9,pc}
00077e  bf00              NOP                            ;805
                  |L1.1920|
000780  f1000c01          ADD      r12,r0,#1             ;805
000784  459c              CMP      r12,r3                ;805
000786  dc22              BGT      |L1.1998|
000788  f817c002          LDRB     r12,[r7,r2]           ;810
00078c  f1bc0f20          CMP      r12,#0x20             ;810
000790  d008              BEQ      |L1.1956|
000792  42b4              CMP      r4,r6                 ;811
000794  da06              BGE      |L1.1956|
000796  f8598020          LDR      r8,[r9,r0,LSL #2]     ;813
00079a  1c64              ADDS     r4,r4,#1              ;813
00079c  f808c005          STRB     r12,[r8,r5]           ;813
0007a0  1c6d              ADDS     r5,r5,#1              ;813
0007a2  e011              B        |L1.1992|
                  |L1.1956|
0007a4  eb070c02          ADD      r12,r7,r2             ;817
0007a8  f89cc001          LDRB     r12,[r12,#1]          ;817
0007ac  f1bc0f20          CMP      r12,#0x20             ;817
0007b0  d101              BNE      |L1.1974|
0007b2  42b4              CMP      r4,r6                 ;818
0007b4  d108              BNE      |L1.1992|
                  |L1.1974|
0007b6  f8594020          LDR      r4,[r9,r0,LSL #2]     ;820
0007ba  f04f0c00          MOV      r12,#0                ;820
0007be  1c40              ADDS     r0,r0,#1              ;823
0007c0  f804c005          STRB     r12,[r4,r5]           ;820
0007c4  4665              MOV      r5,r12                ;822
0007c6  4664              MOV      r4,r12                ;823
                  |L1.1992|
0007c8  1c52              ADDS     r2,r2,#1              ;823
                  |L1.1994|
0007ca  428a              CMP      r2,r1                 ;803
0007cc  ddd8              BLE      |L1.1920|
                  |L1.1998|
0007ce  1c40              ADDS     r0,r0,#1              ;803
0007d0  e7d3              B        |L1.1914|
;;;828    
                          ENDP

                  enable_interrupts PROC
;;;829    void enable_interrupts(unsigned interrupts)
0007d2  b662              CPSIE    i
;;;830    {
;;;831      __enable_irq();
;;;832    }
0007d4  4770              BX       lr
;;;833    
                          ENDP

                  disable_interrupts PROC
;;;834    void disable_interrupts(unsigned interrupts)
0007d6  b672              CPSID    i
;;;835    {
;;;836      __disable_irq();
;;;837    }
0007d8  4770              BX       lr
;;;838    
                          ENDP

                  execute_user_code PROC
;;;839    void execute_user_code(void)
0007da  f2420001          MOV      r0,#0x2001
;;;840    {
;;;841        void (*user_code_entry)(void);
;;;842        user_code_entry = (void (*)(void))(USER_START_SECTOR_ADDRESS | 0x00000001);
;;;843        user_code_entry();
0007de  4700              BX       r0
;;;844    }
;;;845    
                          ENDP

                  user_code_present PROC
;;;846    unsigned user_code_present(void)
0007e0  4825              LDR      r0,|L1.2168|
;;;847    {
0007e2  b510              PUSH     {r4,lr}
;;;848        param_table[IAP_CMD_CODE] = BLANK_CHECK_SECTOR;
0007e4  3014              ADDS     r0,r0,#0x14
0007e6  2135              MOVS     r1,#0x35
;;;849        param_table[IAP_PARAM_0] = USER_START_SECTOR;
0007e8  6001              STR      r1,[r0,#0]  ; param_table
0007ea  2102              MOVS     r1,#2
;;;850        param_table[IAP_PARAM_1] = USER_START_SECTOR;
0007ec  6041              STR      r1,[r0,#4]  ; param_table
;;;851        iap_entry(param_table,result_table);
0007ee  6081              STR      r1,[r0,#8]  ; param_table
0007f0  f1000114          ADD      r1,r0,#0x14
0007f4  f7fffffe          BL       iap_entry
;;;852    	if( result_table[IAP_STAT_CODE] == CMD_SUCCESS )
0007f8  481f              LDR      r0,|L1.2168|
0007fa  3028              ADDS     r0,r0,#0x28
0007fc  6800              LDR      r0,[r0,#0]  ; result_table
0007fe  2800              CMP      r0,#0
000800  d000              BEQ      |L1.2052|
;;;853    	{
;;;854    	    return (FALSE);
;;;855    	}
;;;856    	else
;;;857    	{
;;;858    	    return (TRUE);
000802  2001              MOVS     r0,#1
                  |L1.2052|
;;;859    	}
;;;860    }
000804  bd10              POP      {r4,pc}
;;;861    
                          ENDP

                  check_isp_entry_pin PROC
;;;862    unsigned check_isp_entry_pin(void)
000806  4821              LDR      r0,|L1.2188|
;;;863    {
;;;864      if( (*(volatile unsigned *)ISP_ENTRY_GPIO_REG) & (0x1<<ISP_ENTRY_PIN) )
000808  6940              LDR      r0,[r0,#0x14]
00080a  0400              LSLS     r0,r0,#16
00080c  d501              BPL      |L1.2066|
;;;865    	{
;;;866    	    return(TRUE);
00080e  2001              MOVS     r0,#1
;;;867    	}
;;;868    	else
;;;869    	{
;;;870    	    return(FALSE);
;;;871    	}
;;;872    }
000810  4770              BX       lr
                  |L1.2066|
000812  2000              MOVS     r0,#0                 ;870
000814  4770              BX       lr
;;;873    
                          ENDP

                  is_LPC175x PROC
;;;875    /* returns TRUE if device is an LPC175x */
;;;876    int is_LPC175x(void)
000816  4918              LDR      r1,|L1.2168|
;;;877    {
000818  b510              PUSH     {r4,lr}
;;;878      param_table[IAP_CMD_CODE] = READ_PART_ID;
00081a  3114              ADDS     r1,r1,#0x14
00081c  2036              MOVS     r0,#0x36
;;;879      iap_entry(param_table,result_table);
00081e  6008              STR      r0,[r1,#0]  ; param_table
000820  3114              ADDS     r1,r1,#0x14
000822  f1a10014          SUB      r0,r1,#0x14
000826  f7fffffe          BL       iap_entry
;;;880      if ((result_table[ISP_PARAM_1] >> 24) == 0x25)
00082a  4813              LDR      r0,|L1.2168|
00082c  2125              MOVS     r1,#0x25
00082e  3028              ADDS     r0,r0,#0x28
000830  6840              LDR      r0,[r0,#4]  ; result_table
000832  ebb16f10          CMP      r1,r0,LSR #24
000836  d101              BNE      |L1.2108|
;;;881      {
;;;882        return TRUE;
000838  2001              MOVS     r0,#1
;;;883      }
;;;884    
;;;885      return FALSE;
;;;886    }
00083a  bd10              POP      {r4,pc}
                  |L1.2108|
00083c  2000              MOVS     r0,#0                 ;885
00083e  bd10              POP      {r4,pc}
;;;887    
                          ENDP

                  exec_isp_cmd PROC
;;;888    void exec_isp_cmd(int no_of_param)
000840  b570              PUSH     {r4-r6,lr}
;;;889    {
;;;890        int c;
;;;891    
;;;892        c = *(param_buf[ISP_CMD_CODE]);
000842  4d0d              LDR      r5,|L1.2168|
;;;893        if(c != NUL);
;;;894        {
;;;895            switch(c)
;;;896            {
;;;897            /* Write to RAM command */
;;;898            case 'W':
;;;899                write_to_ram();
;;;900                break;
;;;901            /* Read command */
;;;902            case 'R':
;;;903                read();
;;;904                break;
;;;905            /* Go command */
;;;906            case 'G':
;;;907                go_cmd();
;;;908                break;
;;;909            /* Unlock command */
;;;910            case 'U':
;;;911                unlock();
;;;912                break;
;;;913            /* Read Part Identification number command */
;;;914            case 'J':
;;;915                param_table[IAP_CMD_CODE] = READ_PART_ID;
000844  f1050114          ADD      r1,r5,#0x14
000848  6828              LDR      r0,[r5,#0]            ;892  ; param_buf
;;;916                iap_entry(param_table,result_table);
00084a  f1010414          ADD      r4,r1,#0x14
00084e  7800              LDRB     r0,[r0,#0]            ;892
000850  3843              SUBS     r0,r0,#0x43
000852  2815              CMP      r0,#0x15              ;895
000854  d277              BCS      |L1.2374|
000856  e8dff000          TBB      [pc,r0]               ;895
00085a  808c              DCB      0x80,0x8c
00085c  838c1e8c          DCB      0x83,0x8c,0x1e,0x8c
000860  86245c8c          DCB      0x86,0x24,0x5c,0x8c
000864  89358c7d          DCB      0x89,0x35,0x8c,0x7d
000868  8c1b8c8c          DCB      0x8c,0x1b,0x8c,0x8c
00086c  218c0b00          DCB      0x21,0x8c,0x0b,0x00
000870  e8bd4070          POP      {r4-r6,lr}            ;899
000874  e7fe              B        write_to_ram
000876  0000              DCW      0x0000
                  |L1.2168|
                          DCD      ||.bss||+0x94
                  |L1.2172|
                          DCD      ||.data||
                  |L1.2176|
                          DCD      0x12345678
                  |L1.2180|
                          DCD      0x87654321
                  |L1.2184|
                          DCD      0x11223344
                  |L1.2188|
                          DCD      0x2009c000
000890  e8bd4070          POP      {r4-r6,lr}            ;903
000894  e7fe              B        read
000896  e8bd4070          POP      {r4-r6,lr}            ;907
00089a  e7fe              B        go_cmd
00089c  e8bd4070          POP      {r4-r6,lr}            ;911
0008a0  e7fe              B        unlock
0008a2  2036              MOVS     r0,#0x36              ;915
0008a4  6008              STR      r0,[r1,#0]  ; param_table
0008a6  4966              LDR      r1,|L1.2624|
0008a8  f1a10014          SUB      r0,r1,#0x14
0008ac  f7fffffe          BL       iap_entry
;;;917                sendline_crlf(i_to_a(result_table[IAP_STAT_CODE],param_buf[ISP_PARAM_1], \
0008b0  6869              LDR      r1,[r5,#4]  ; param_buf
0008b2  220f              MOVS     r2,#0xf
0008b4  6820              LDR      r0,[r4,#0]  ; result_table
0008b6  f7fffffe          BL       i_to_a
0008ba  f7fffffe          BL       sendline_crlf
;;;918                PARAM_SIZE));
;;;919                sendline_crlf(i_to_a(result_table[IAP_RESULT_0],param_buf[ISP_PARAM_1], \
0008be  6869              LDR      r1,[r5,#4]  ; param_buf
;;;920                PARAM_SIZE));
;;;921            break;
0008c0  6860              LDR      r0,[r4,#4]  ; result_table
0008c2  e024              B        |L1.2318|
;;;922            /* read serial number command */
;;;923            case 'N':
;;;924                param_table[IAP_CMD_CODE] = READ_SERIAL_NUMBER;
0008c4  203a              MOVS     r0,#0x3a
;;;925                iap_entry(param_table, result_table);
0008c6  6008              STR      r0,[r1,#0]  ; param_table
0008c8  495d              LDR      r1,|L1.2624|
0008ca  f1a10014          SUB      r0,r1,#0x14
0008ce  f7fffffe          BL       iap_entry
;;;926                sendline_crlf(i_to_a(result_table[IAP_STAT_CODE],param_buf[ISP_PARAM_1], \
0008d2  6869              LDR      r1,[r5,#4]  ; param_buf
0008d4  220f              MOVS     r2,#0xf
0008d6  6820              LDR      r0,[r4,#0]  ; result_table
0008d8  f7fffffe          BL       i_to_a
0008dc  f7fffffe          BL       sendline_crlf
;;;927                PARAM_SIZE));
;;;928                sendline_crlf(i_to_a(result_table[IAP_RESULT_0],param_buf[ISP_PARAM_1], \
0008e0  6869              LDR      r1,[r5,#4]  ; param_buf
0008e2  220f              MOVS     r2,#0xf
0008e4  6860              LDR      r0,[r4,#4]  ; result_table
0008e6  f7fffffe          BL       i_to_a
0008ea  f7fffffe          BL       sendline_crlf
;;;929                PARAM_SIZE));
;;;930                sendline_crlf(i_to_a(result_table[IAP_RESULT_1],param_buf[ISP_PARAM_1], \
0008ee  6869              LDR      r1,[r5,#4]  ; param_buf
0008f0  220f              MOVS     r2,#0xf
0008f2  68a0              LDR      r0,[r4,#8]  ; result_table
0008f4  f7fffffe          BL       i_to_a
0008f8  f7fffffe          BL       sendline_crlf
;;;931                PARAM_SIZE));
;;;932                sendline_crlf(i_to_a(result_table[IAP_RESULT_2],param_buf[ISP_PARAM_1], \
0008fc  6869              LDR      r1,[r5,#4]  ; param_buf
0008fe  220f              MOVS     r2,#0xf
000900  68e0              LDR      r0,[r4,#0xc]  ; result_table
000902  f7fffffe          BL       i_to_a
000906  f7fffffe          BL       sendline_crlf
;;;933                PARAM_SIZE));
;;;934                sendline_crlf(i_to_a(result_table[IAP_RESULT_3],param_buf[ISP_PARAM_1], \
00090a  6869              LDR      r1,[r5,#4]  ; param_buf
00090c  6920              LDR      r0,[r4,#0x10]  ; result_table
                  |L1.2318|
00090e  220f              MOVS     r2,#0xf               ;919
000910  e01a              B        |L1.2376|
;;;935                PARAM_SIZE));
;;;936            break;
;;;937            /* Read Boot Code Version number command */
;;;938            case 'K':
;;;939                param_table[IAP_CMD_CODE] = READ_BOOT_VER;
000912  2037              MOVS     r0,#0x37
;;;940                iap_entry(param_table,result_table);
000914  6008              STR      r0,[r1,#0]  ; param_table
000916  494a              LDR      r1,|L1.2624|
000918  f1a10014          SUB      r0,r1,#0x14
00091c  f7fffffe          BL       iap_entry
;;;941                sendline_crlf(i_to_a(result_table[IAP_STAT_CODE],param_buf[ISP_PARAM_1], \
000920  6869              LDR      r1,[r5,#4]  ; param_buf
000922  220f              MOVS     r2,#0xf
000924  6820              LDR      r0,[r4,#0]  ; result_table
000926  f7fffffe          BL       i_to_a
00092a  f7fffffe          BL       sendline_crlf
;;;942                PARAM_SIZE));
;;;943                sendline_crlf(i_to_a((char)result_table[IAP_RESULT_0],param_buf[ISP_PARAM_1], \
00092e  7920              LDRB     r0,[r4,#4]  ; result_table
000930  220f              MOVS     r2,#0xf
000932  6869              LDR      r1,[r5,#4]  ; param_buf
000934  f7fffffe          BL       i_to_a
000938  f7fffffe          BL       sendline_crlf
;;;944                PARAM_SIZE));
;;;945                sendline_crlf(i_to_a((char)(result_table[IAP_RESULT_0]>>8),param_buf[ISP_PARAM_1], \
00093c  88a0              LDRH     r0,[r4,#4]  ; result_table
;;;946                PARAM_SIZE));
;;;947                break;
00093e  6869              LDR      r1,[r5,#4]  ; param_buf
000940  f3c02007          UBFX     r0,r0,#8,#8           ;945
000944  e7e3              B        |L1.2318|
                  |L1.2374|
000946  e014              B        |L1.2418|
                  |L1.2376|
;;;948            /* Prepare sector for write operation command */
;;;949            case 'P':
;;;950                prepare_sector();
;;;951                break;
;;;952            /* Copy RAM to FLASH command */
;;;953            case 'C':
;;;954                copy();
;;;955                break;
;;;956            /* Erase sector command */
;;;957            case 'E':
;;;958                erase();
;;;959                break;
;;;960            /* Blank check sector command */
;;;961            case 'I':
;;;962                blank_check();
;;;963                break;
;;;964            /* Compare Memory */
;;;965            case 'M':
;;;966                compare_mem();
;;;967                break;
;;;968            /* Invalid Command */
;;;969            default:
;;;970                sendline_crlf(i_to_a(INVALID_COMMAND,param_buf[ISP_PARAM_1], \
000948  f7fffffe          BL       i_to_a
00094c  e8bd4070          POP      {r4-r6,lr}
000950  f7ffbffe          B.W      sendline_crlf
000954  e8bd4070          POP      {r4-r6,lr}            ;950
000958  e7fe              B        prepare_sector
00095a  e8bd4070          POP      {r4-r6,lr}            ;954
00095e  e7fe              B        copy
000960  e8bd4070          POP      {r4-r6,lr}            ;958
000964  e7fe              B        erase
000966  e8bd4070          POP      {r4-r6,lr}            ;962
00096a  e7fe              B        blank_check
00096c  e8bd4070          POP      {r4-r6,lr}            ;966
000970  e7fe              B        compare_mem
                  |L1.2418|
000972  220f              MOVS     r2,#0xf
000974  2001              MOVS     r0,#1
;;;971                PARAM_SIZE));
;;;972                break;
000976  6869              LDR      r1,[r5,#4]  ; param_buf
000978  e7e6              B        |L1.2376|
;;;973            } /* switch(c) */
;;;974        } /* if c != NUL */
;;;975    } /* exec_isp_cmd */
;;;976    
                          ENDP

                  isp_cmd_loop PROC
;;;977    /* only returns if timeout occurred */
;;;978    void isp_cmd_loop(void)
00097a  e92d41fc          PUSH     {r2-r8,lr}
;;;979    {
;;;980        int cmd_len,no_of_param,crp_block_common_cmd,crp_block_crp2_crp3_cmd;
;;;981    	int result;
;;;982        
;;;983    	/* initialize to avoid compiler warning  */
;;;984        /* Lock Flash Write/Erase/Go Commands */
;;;985        lock = TRUE;
00097e  4d31              LDR      r5,|L1.2628|
000980  2001              MOVS     r0,#1
;;;986        
;;;987        /* intialize parameter buffer */
;;;988        param_buf[ISP_PARAM_0] = param0;
;;;989        param_buf[ISP_PARAM_1] = param1;
;;;990        param_buf[ISP_PARAM_2] = param2;
;;;991        param_buf[ISP_PARAM_3] = param3;
;;;992        param_buf[ISP_PARAM_4] = param4;
;;;993    
;;;994        /* Initialize cp_after_reset variable to allow ISP session to program 
;;;995           code protection enabled user application */
;;;996    	crp_after_reset = crp;
;;;997    
;;;998    	crp_block_crp2_crp3_cmd = TRUE;
;;;999    
;;;1000   	while(1)
;;;1001       {
;;;1002   	    result = getline(cmd_buf,CMD_SIZE,&cmd_len);
;;;1003           if(result == 0)
;;;1004           {
;;;1005               /* To safegaurd against insufficient parameters fill parameter buffers with
;;;1006                  Non numeric ascii charcaters */
;;;1007               for(no_of_param=0;no_of_param<NO_OF_ISP_PARAMS;no_of_param++)
;;;1008               {
;;;1009                   *(param_buf[no_of_param]) = 'z';
;;;1010               }
;;;1011               no_of_param = tokenize(&cmd_buf[0],cmd_len,&param_buf[0],NO_OF_ISP_PARAMS,PARAM_SIZE);  
;;;1012               if(no_of_param != 0)
;;;1013               {
;;;1014                  /* Common ISP commands to be blocked for code read protection Level 1, 2 or 3 */
;;;1015                  if( ( (*(param_buf[ISP_CMD_CODE]) == 'R') ||              \
;;;1016                        (*(param_buf[ISP_CMD_CODE]) == 'G') ||              \
;;;1017                        (*(param_buf[ISP_CMD_CODE]) == 'M') ) )
;;;1018                  {
;;;1019                     crp_block_common_cmd = TRUE;
;;;1020                  }
;;;1021                  else
;;;1022                  {
;;;1023                     crp_block_common_cmd = FALSE;
;;;1024                     /* ISP commands to be blocked for code read protection Level 2 and 3 */
;;;1025                     if( ( (*(param_buf[ISP_CMD_CODE]) == 'W') ||              \
;;;1026                           (*(param_buf[ISP_CMD_CODE]) == 'C') ) )
;;;1027                     {
;;;1028                        crp_block_crp2_crp3_cmd = TRUE;
;;;1029                     }
;;;1030                     else
;;;1031                     {
;;;1032                        crp_block_crp2_crp3_cmd = FALSE;
;;;1033                     }
;;;1034                  }
;;;1035   
;;;1036                  if( ( (crp_after_reset == CRP1) ||            \
;;;1037                        (crp_after_reset == CRP2) ||     \
000982  4f32              LDR      r7,|L1.2636|
000984  6028              STR      r0,[r5,#0]            ;988  ; lock
000986  482e              LDR      r0,|L1.2624|
;;;1038                        (crp_after_reset == CRP3) )      \
000988  ea4f4837          ROR      r8,r7,#16
00098c  3876              SUBS     r0,r0,#0x76           ;988
00098e  f100044e          ADD      r4,r0,#0x4e           ;988
000992  6020              STR      r0,[r4,#0]            ;989  ; param_buf
000994  300f              ADDS     r0,r0,#0xf            ;989
000996  6060              STR      r0,[r4,#4]            ;990  ; param_buf
000998  300f              ADDS     r0,r0,#0xf            ;990
00099a  60a0              STR      r0,[r4,#8]            ;991  ; param_buf
00099c  300f              ADDS     r0,r0,#0xf            ;991
00099e  60e0              STR      r0,[r4,#0xc]          ;992  ; param_buf
0009a0  300f              ADDS     r0,r0,#0xf            ;992
0009a2  6120              STR      r0,[r4,#0x10]         ;996  ; param_buf
0009a4  4828              LDR      r0,|L1.2632|
0009a6  2601              MOVS     r6,#1                 ;998
0009a8  6800              LDR      r0,[r0,#0]            ;996  ; crp
0009aa  6068              STR      r0,[r5,#4]  ; crp_after_reset
                  |L1.2476|
0009ac  4824              LDR      r0,|L1.2624|
0009ae  aa01              ADD      r2,sp,#4              ;1002
0009b0  2146              MOVS     r1,#0x46              ;1002
0009b2  38bc              SUBS     r0,r0,#0xbc           ;1002
0009b4  f7fffffe          BL       getline
0009b8  2800              CMP      r0,#0                 ;1003
0009ba  d13f              BNE      |L1.2620|
0009bc  f05f017a          MOVS.W   r1,#0x7a              ;1009
                  |L1.2496|
0009c0  f8542020          LDR      r2,[r4,r0,LSL #2]     ;1009
0009c4  1c40              ADDS     r0,r0,#1              ;1009
0009c6  2805              CMP      r0,#5                 ;1007
0009c8  7011              STRB     r1,[r2,#0]            ;1009
0009ca  dbf9              BLT      |L1.2496|
0009cc  4a1c              LDR      r2,|L1.2624|
0009ce  200f              MOVS     r0,#0xf               ;1011
0009d0  3a28              SUBS     r2,r2,#0x28           ;1011
0009d2  9000              STR      r0,[sp,#0]            ;1011
0009d4  2305              MOVS     r3,#5                 ;1011
0009d6  f1a20094          SUB      r0,r2,#0x94           ;1011
0009da  9901              LDR      r1,[sp,#4]            ;1011
0009dc  f7fffffe          BL       tokenize
0009e0  2800              CMP      r0,#0                 ;1012
0009e2  d0e3              BEQ      |L1.2476|
0009e4  6821              LDR      r1,[r4,#0]            ;1015  ; param_buf
0009e6  7809              LDRB     r1,[r1,#0]            ;1015
0009e8  2952              CMP      r1,#0x52              ;1015
0009ea  d01a              BEQ      |L1.2594|
0009ec  2947              CMP      r1,#0x47              ;1016
0009ee  d018              BEQ      |L1.2594|
0009f0  294d              CMP      r1,#0x4d              ;1017
0009f2  d016              BEQ      |L1.2594|
0009f4  2200              MOVS     r2,#0                 ;1023
0009f6  2957              CMP      r1,#0x57              ;1025
0009f8  d015              BEQ      |L1.2598|
0009fa  2943              CMP      r1,#0x43              ;1026
0009fc  d013              BEQ      |L1.2598|
0009fe  2600              MOVS     r6,#0                 ;1032
                  |L1.2560|
000a00  4b13              LDR      r3,|L1.2640|
000a02  6869              LDR      r1,[r5,#4]            ;1036  ; crp_after_reset
000a04  4299              CMP      r1,r3                 ;1036
000a06  d003              BEQ      |L1.2576|
000a08  42b9              CMP      r1,r7                 ;1037
000a0a  d001              BEQ      |L1.2576|
000a0c  4541              CMP      r1,r8
000a0e  d10c              BNE      |L1.2602|
                  |L1.2576|
;;;1039                                           &&                                 \
;;;1040                       ( crp_block_common_cmd == TRUE )
000a10  b15a              CBZ      r2,|L1.2602|
                  |L1.2578|
;;;1041                     )
;;;1042                   {
;;;1043                       /* Code read protection Level 1, 2 or 3 enabled. Block Read,
;;;1044                          Go and Compare ISP commands */
;;;1045                       sendline_crlf(i_to_a(CODE_READ_PROTECTION_ENABLED, \
000a12  220f              MOVS     r2,#0xf
000a14  2013              MOVS     r0,#0x13
000a16  6861              LDR      r1,[r4,#4]  ; param_buf
000a18  f7fffffe          BL       i_to_a
000a1c  f7fffffe          BL       sendline_crlf
000a20  e7c4              B        |L1.2476|
                  |L1.2594|
000a22  2201              MOVS     r2,#1                 ;1019
000a24  e7ec              B        |L1.2560|
                  |L1.2598|
000a26  2601              MOVS     r6,#1                 ;1028
000a28  e7ea              B        |L1.2560|
                  |L1.2602|
;;;1046                       param_buf[ISP_PARAM_1],PARAM_SIZE));
;;;1047                   }  
;;;1048                   else
;;;1049                   {
;;;1050                      if( ( (crp_after_reset == CRP2) ||            \
000a2a  42b9              CMP      r1,r7
000a2c  d001              BEQ      |L1.2610|
;;;1051                            (crp_after_reset == CRP3) )  
000a2e  4541              CMP      r1,r8
000a30  d101              BNE      |L1.2614|
                  |L1.2610|
;;;1052                                            &&                                   \
;;;1053                           ( crp_block_crp2_crp3_cmd == TRUE ) )
000a32  2e01              CMP      r6,#1
000a34  d0ed              BEQ      |L1.2578|
                  |L1.2614|
;;;1054                      {
;;;1055                       /* Code read protection Level 2 or 3 is enabled. Block Write
;;;1056                          and Copy ISP commands */
;;;1057                          sendline_crlf(i_to_a(CODE_READ_PROTECTION_ENABLED, \
;;;1058                          param_buf[ISP_PARAM_1],PARAM_SIZE));
;;;1059                      }
;;;1060                      else
;;;1061                      {
;;;1062                          exec_isp_cmd(no_of_param);
000a36  f7fffffe          BL       exec_isp_cmd
000a3a  e7b7              B        |L1.2476|
                  |L1.2620|
;;;1063                      }
;;;1064                   }
;;;1065               } /* if(no_of_param != 0) */
;;;1066           } /* if(serial_getline(cmd_buf,CMD_SIZE,&cmd_len) == 0) */
;;;1067   		else
;;;1068   		{
;;;1069   		  /* timeout */
;;;1070   		  return;
;;;1071   		}
;;;1072   	} /* While(1) loop */
;;;1073   } /* isp_cmd_loop */
000a3c  e8bd81fc          POP      {r2-r8,pc}
                          ENDP

                  |L1.2624|
                          DCD      ||.bss||+0xbc
                  |L1.2628|
                          DCD      ||.data||
                  |L1.2632|
                          DCD      ||crp||
                  |L1.2636|
                          DCD      0x87654321
                  |L1.2640|
                          DCD      0x12345678

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  cmd_buf
                          %        70
                  param0
                          %        15
                  param1
                          %        15
                  param2
                          %        15
                  param3
                          %        15
                  param4
                          %        18
                  param_buf
                          %        20
                  param_table
                          %        20
                  result_table
                          %        20

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  unlock_code
                          DCD      0x00005a5a

                          AREA ||area_number.6||, DATA, READONLY, ALIGN=0

                          EXPORTAS ||area_number.6||, ||.constdata||
                  ||ok||
000000  4f4b00            DCB      0x4f,0x4b,0x00
                  resend
000003  52                DCB      0x52
000004  4553454e          DCB      0x45,0x53,0x45,0x4e
000008  4400              DCB      0x44,0x00
                  sync_str
00000a  5379              DCB      0x53,0x79
00000c  6e636872          DCB      0x6e,0x63,0x68,0x72
000010  6f6e697a          DCB      0x6f,0x6e,0x69,0x7a
000014  656400            DCB      0x65,0x64,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  lock
                          DCD      0x00000000
                  crp_after_reset
                          DCD      0x00000000
